<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>02 Understanding Test Fundamentals</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">01 Getting Started</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-2-understanding-test-fundamentals">Chapter 2: Understanding Test Fundamentals</h1>
<h2 id="assertions-the-heart-of-testing">Assertions: The Heart of Testing</h2>
<h2 id="assertions-the-heart-of-testing_1">Assertions: The Heart of Testing</h2>
<p>At its core, every test performs a simple, crucial task: it checks if something is true. In programming, we call this check an <strong>assertion</strong>. An assertion is a statement that declares a condition we expect to be true at a specific point in our code's execution. If the condition is true, the test passes silently. If it's false, the test fails loudly, stopping execution and telling us exactly what went wrong.</p>
<p>Pytest uses Python's built-in <code>assert</code> statement, enhancing it with powerful introspection to provide detailed failure messages. This makes your tests clean, readable, and incredibly informative when they fail.</p>
<h3 id="phase-1-establish-the-reference-implementation">Phase 1: Establish the Reference Implementation</h3>
<p>Let's anchor our learning in a concrete example. Imagine we're building an e-commerce platform. A key piece of business logic is calculating customer discounts. Here is our initial function, which lives in a file named <code>pricing.py</code>.</p>
<p><strong>Anchor Example</strong>: <code>calculate_discount()</code></p>
<p>This function is supposed to give a 10% discount on orders of $100 or more, and a 5% discount on orders between $20 and $99.99.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/ecommerce/pricing.py</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate_discount</span><span class="p">(</span><span class="n">order_total</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a discount based on the order total.</span>
<span class="sd">    - 10% for orders &gt;= $100</span>
<span class="sd">    - 5% for orders &gt;= $20</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">order_total</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">order_total</span> <span class="o">*</span> <span class="mf">0.10</span>
    <span class="k">elif</span> <span class="n">order_total</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>  <span class="c1"># A subtle bug is lurking here!</span>
        <span class="k">return</span> <span class="n">order_total</span> <span class="o">*</span> <span class="mf">0.05</span>
    <span class="k">return</span> <span class="mf">0.0</span>
</code></pre></div>

<p>Now, let's write our first test to verify the 10% discount for a high-value order. We'll create a <code>tests</code> directory and place our test file there.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pricing.py</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">src.ecommerce.pricing</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_discount</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_discount_for_high_value_order</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests that a 10% discount is applied for orders of $100 or more.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Arrange: Set up the test data</span>
    <span class="n">order_total</span> <span class="o">=</span> <span class="mf">200.0</span>

    <span class="c1"># Act: Call the function we are testing</span>
    <span class="n">discount</span> <span class="o">=</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="n">order_total</span><span class="p">)</span>

    <span class="c1"># Assert: Check if the result is what we expect</span>
    <span class="k">assert</span> <span class="n">discount</span> <span class="o">==</span> <span class="mf">20.0</span>
</code></pre></div>

<p>This test follows the classic "Arrange-Act-Assert" pattern:
1.  <strong>Arrange</strong>: We set up the necessary inputs. Here, an <code>order_total</code> of 200.0.
2.  <strong>Act</strong>: We execute the code under test. We call <code>calculate_discount()</code>.
3.  <strong>Assert</strong>: We check the outcome. We assert that the <code>discount</code> is equal to 20.0.</p>
<p>Let's run this test. It should pass, as our function's logic for orders over $100 seems correct.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_pricing.py<span class="w"> </span>.<span class="w">                                          </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==========================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">==========================</span>
</code></pre></div>

<h3 id="iteration-1-exposing-a-bug-with-a-new-assertion">Iteration 1: Exposing a Bug with a New Assertion</h3>
<p>Our first test passed, but does that mean the function is perfect? A single test case rarely covers all business logic. Let's add a test for the 5% discount tier. According to the rules, an order of exactly $20.00 should receive a 5% discount, which is $1.00.</p>
<p>Here's the new test added to our file:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pricing.py (updated)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">src.ecommerce.pricing</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_discount</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_discount_for_high_value_order</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests that a 10% discount is applied for orders of $100 or more.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="mf">200.0</span><span class="p">)</span> <span class="o">==</span> <span class="mf">20.0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_discount_at_lower_boundary</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests that a 5% discount is applied for an order of exactly $20.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Arrange</span>
    <span class="n">order_total</span> <span class="o">=</span> <span class="mf">20.0</span>
    <span class="n">expected_discount</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># Act</span>
    <span class="n">actual_discount</span> <span class="o">=</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="n">order_total</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">actual_discount</span> <span class="o">==</span> <span class="n">expected_discount</span>
</code></pre></div>

<p>Now, let's run pytest again and see what happens.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_pricing.py<span class="w"> </span>.F<span class="w">                                         </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===============================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">===============================</span>
___________<span class="w"> </span>test_calculate_discount_at_lower_boundary<span class="w"> </span>____________

<span class="w">    </span>def<span class="w"> </span>test_calculate_discount_at_lower_boundary<span class="o">()</span>:
<span class="w">        </span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Tests that a 5% discount is applied for an order of exactly </span><span class="nv">$20</span><span class="s2">.</span>
<span class="s2">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="c1"># Arrange</span>
<span class="w">        </span><span class="nv">order_total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">20</span>.0
<span class="w">        </span><span class="nv">expected_discount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>.0

<span class="w">        </span><span class="c1"># Act</span>
<span class="w">        </span><span class="nv">actual_discount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>calculate_discount<span class="o">(</span>order_total<span class="o">)</span>

<span class="w">        </span><span class="c1"># Assert</span>
&gt;<span class="w">       </span>assert<span class="w"> </span><span class="nv">actual_discount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>expected_discount
E<span class="w">       </span>assert<span class="w"> </span><span class="m">0</span>.0<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span>.0

tests/test_pricing.py:22:<span class="w"> </span><span class="nv">AssertionError</span>
<span class="o">=======================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">========================</span>
FAILED<span class="w"> </span>tests/test_pricing.py::test_calculate_discount_at_lower_boundary<span class="w"> </span>-<span class="w"> </span>assert<span class="w"> </span><span class="m">0</span>.0<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span>.0
<span class="o">=====================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed,<span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">=====================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure">Diagnostic Analysis: Reading the Failure</h3>
<p>This output is a goldmine of information. Let's treat it as data, not a judgment.</p>
<p><strong>The complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_pricing.py<span class="w"> </span>.F<span class="w">                                         </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===============================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">===============================</span>
___________<span class="w"> </span>test_calculate_discount_at_lower_boundary<span class="w"> </span>____________

<span class="w">    </span>def<span class="w"> </span>test_calculate_discount_at_lower_boundary<span class="o">()</span>:
<span class="w">        </span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Tests that a 5% discount is applied for an order of exactly </span><span class="nv">$20</span><span class="s2">.</span>
<span class="s2">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="c1"># Arrange</span>
<span class="w">        </span><span class="nv">order_total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">20</span>.0
<span class="w">        </span><span class="nv">expected_discount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>.0

<span class="w">        </span><span class="c1"># Act</span>
<span class="w">        </span><span class="nv">actual_discount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>calculate_discount<span class="o">(</span>order_total<span class="o">)</span>

<span class="w">        </span><span class="c1"># Assert</span>
&gt;<span class="w">       </span>assert<span class="w"> </span><span class="nv">actual_discount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>expected_discount
E<span class="w">       </span>assert<span class="w"> </span><span class="m">0</span>.0<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span>.0

tests/test_pricing.py:22:<span class="w"> </span><span class="nv">AssertionError</span>
<span class="o">=======================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">========================</span>
FAILED<span class="w"> </span>tests/test_pricing.py::test_calculate_discount_at_lower_boundary<span class="w"> </span>-<span class="w"> </span>assert<span class="w"> </span><span class="m">0</span>.0<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span>.0
<span class="o">=====================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed,<span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">=====================</span>
</code></pre></div>

<p><strong>Let's parse this section by section</strong>:</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>FAILED tests/test_pricing.py::test_calculate_discount_at_lower_boundary - assert 0.0 == 1.0</code></p>
<ul>
<li><strong>What this tells us</strong>: The exact test function that failed (<code>test_calculate_discount_at_lower_boundary</code> in the file <code>tests/test_pricing.py</code>) and a summary of the assertion that broke.</li>
</ul>
</li>
<li>
<p><strong>The traceback</strong>:
    ```python
    &gt;       assert actual_discount == expected_discount
    E       assert 0.0 == 1.0</p>
<p>tests/test_pricing.py:22: AssertionError
<code>``
-   **What this tells us**: The failure happened on line 22 of</code>tests/test_pricing.py<code>. The</code>&gt;<code>points to the exact line of code.
-   **Key line**: The line starting with</code>E` (for Error) shows the values that were being compared when the assertion failed.</p>
</li>
<li>
<p><strong>The assertion introspection</strong>:
    <code>assert 0.0 == 1.0</code></p>
<ul>
<li><strong>What this tells us</strong>: This is pytest's magic. It didn't just tell us the assertion failed; it inspected the variables in the <code>assert</code> statement and showed us their values. We were expecting <code>actual_discount</code> to be <code>1.0</code>, but it was actually <code>0.0</code>. We don't need to add <code>print()</code> statements or use a debugger to see what went wrong.</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: The function returned a discount of <code>0.0</code> for an order of <code>20.0</code>, when we expected <code>1.0</code>.
<strong>Why the current approach can't solve this</strong>: Looking back at the source code, the bug is clear: <code>elif order_total &gt; 20:</code>. This condition is not met for an order of exactly 20. It should be <code>order_total &gt;= 20</code>.
<strong>What we need</strong>: A fix in the business logic to correctly handle the boundary condition.</p>
<h3 id="the-fix-and-verification">The Fix and Verification</h3>
<p>Let's correct the bug in <code>src/ecommerce/pricing.py</code>.</p>
<p><strong>Before</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/ecommerce/pricing.py (buggy version)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate_discount</span><span class="p">(</span><span class="n">order_total</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">elif</span> <span class="n">order_total</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>  <span class="c1"># The bug is here</span>
        <span class="k">return</span> <span class="n">order_total</span> <span class="o">*</span> <span class="mf">0.05</span>
    <span class="o">...</span>
</code></pre></div>

<p><strong>After</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/ecommerce/pricing.py (fixed version)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate_discount</span><span class="p">(</span><span class="n">order_total</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a discount based on the order total.</span>
<span class="sd">    - 10% for orders &gt;= $100</span>
<span class="sd">    - 5% for orders &gt;= $20</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">order_total</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">order_total</span> <span class="o">*</span> <span class="mf">0.10</span>
    <span class="k">elif</span> <span class="n">order_total</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">:</span>  <span class="c1"># The fix is here</span>
        <span class="k">return</span> <span class="n">order_total</span> <span class="o">*</span> <span class="mf">0.05</span>
    <span class="k">return</span> <span class="mf">0.0</span>
</code></pre></div>

<p>Now, we re-run our tests to verify the fix.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_pricing.py<span class="w"> </span>..<span class="w">                                         </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==========================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">==========================</span>
</code></pre></div>

<p>Success! The failing test now passes, and our first test still passes, giving us confidence that our fix didn't break existing functionality. This is the fundamental cycle of testing: write a test that captures a requirement, see it fail, write the code to make it pass, and repeat. The <code>assert</code> statement is the gatekeeper of this entire process.</p>
<h2 id="test-functions-vs-other-functions">Test Functions vs. Other Functions</h2>
<h2 id="test-functions-vs-other-functions_1">Test Functions vs. Other Functions</h2>
<p>In our test file, we have functions like <code>test_calculate_discount...</code>. These look like normal Python functions, but they are special. A <strong>test function</strong> is a function that pytest recognizes and executes as a test case. A regular Python function, by contrast, executes business logic or acts as a helper.</p>
<p>What makes a function a <em>test function</em> in the eyes of pytest? It's all about <strong>convention</strong>.</p>
<p>Let's compare the function we are testing with the function that tests it.</p>
<p><strong>Function Under Test (in <code>src/ecommerce/pricing.py</code>)</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">calculate_discount</span><span class="p">(</span><span class="n">order_total</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="c1"># ... business logic ...</span>
    <span class="k">return</span> <span class="n">discount</span>
</code></pre></div>

<p><strong>Test Function (in <code>tests/test_pricing.py</code>)</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_discount_at_lower_boundary</span><span class="p">():</span>
    <span class="c1"># ... arrange, act, assert ...</span>
    <span class="k">assert</span> <span class="n">actual_discount</span> <span class="o">==</span> <span class="n">expected_discount</span>
</code></pre></div>

<h3 id="key-differences">Key Differences</h3>
<ol>
<li>
<p><strong>Purpose</strong>:</p>
<ul>
<li><code>calculate_discount</code>: Performs a business task. It takes data, processes it, and <strong>returns a value</strong>. This is production code.</li>
<li><code>test_calculate_discount...</code>: Verifies behavior. It sets up a scenario, calls the production code, and <strong>makes an assertion</strong>. It typically <strong>does not return a value</strong>. Its success or failure is communicated by passing the assertion or raising an <code>AssertionError</code>.</li>
</ul>
</li>
<li>
<p><strong>Naming</strong>:</p>
<ul>
<li><code>calculate_discount</code>: Named for what it <em>does</em>.</li>
<li><code>test_calculate_discount...</code>: Must be prefixed with <code>test_</code>. This is the primary signal pytest uses to identify it as a test.</li>
</ul>
</li>
<li>
<p><strong>Execution</strong>:</p>
<ul>
<li><code>calculate_discount</code>: Called by your application's logic.</li>
<li><code>test_calculate_discount...</code>: Called automatically by the pytest test runner. You almost never call a test function directly yourself.</li>
</ul>
</li>
</ol>
<h3 id="helper-functions-in-test-files">Helper Functions in Test Files</h3>
<p>You can, and should, have other functions in your test files that are <em>not</em> tests. These are often called "helper functions." They exist to reduce code duplication and make your tests more readable.</p>
<p>Imagine we need to create complex order objects for our tests. We could write a helper.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pricing.py (with a helper)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">src.ecommerce.pricing</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_discount</span>

<span class="c1"># This is a HELPER function, not a test function.</span>
<span class="c1"># Pytest will ignore it because its name doesn&#39;t start with &quot;test_&quot;.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">create_order_with_total</span><span class="p">(</span><span class="n">total</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A helper to create a sample order dictionary.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;customer_id&quot;</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">total</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">[]}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_discount_for_high_value_order</span><span class="p">():</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">create_order_with_total</span><span class="p">(</span><span class="mf">200.0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mf">20.0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_discount_at_lower_boundary</span><span class="p">():</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">create_order_with_total</span><span class="p">(</span><span class="mf">20.0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mf">1.0</span>
</code></pre></div>

<p>In this example, <code>create_order_with_total</code> is a regular Python function. Pytest ignores it during test collection because its name doesn't start with <code>test_</code>. It simply serves to make the test functions cleaner.</p>
<p>This distinction is fundamental to the next topic: how pytest knows which functions to run in the first place.</p>
<h2 id="test-discovery-how-pytest-finds-your-tests">Test Discovery: How Pytest Finds Your Tests</h2>
<h2 id="test-discovery-how-pytest-finds-your-tests_1">Test Discovery: How Pytest Finds Your Tests</h2>
<p>When you type <code>pytest</code> in your terminal, it springs into action, searching your project for tests to run. This process is called <strong>test discovery</strong>. It's not magic; it's a simple set of rules and conventions. If you don't follow them, pytest won't find your tests.</p>
<h3 id="iteration-2-breaking-discovery">Iteration 2: Breaking Discovery</h3>
<p>Let's see this in action by deliberately breaking the convention. We'll take one of our working tests and rename it so it no longer starts with <code>test_</code>.</p>
<p><strong>Current State</strong>: Our <code>tests/test_pricing.py</code> file has two test functions that are correctly discovered and run.</p>
<p><strong>Limitation</strong>: Our understanding of <em>why</em> they are discovered is based on an assumption. Let's prove it.</p>
<p><strong>New Scenario</strong>: What happens if we rename <code>test_calculate_discount_at_lower_boundary</code> to <code>check_discount_at_lower_boundary</code>?</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pricing.py (with renamed function)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">src.ecommerce.pricing</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_discount</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_discount_for_high_value_order</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="mf">200.0</span><span class="p">)</span> <span class="o">==</span> <span class="mf">20.0</span>

<span class="c1"># This function will NOT be discovered by pytest</span>
<span class="k">def</span><span class="w"> </span><span class="nf">check_discount_at_lower_boundary</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="mf">20.0</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span>
</code></pre></div>

<p>Now, let's run pytest. Pay close attention to the output.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_pricing.py<span class="w"> </span>.<span class="w">                                          </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==========================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">==========================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure_1">Diagnostic Analysis: Reading the "Failure"</h3>
<p>The tests didn't fail, but something is wrong. This is a different kind of failure: a failure of the test suite itself.</p>
<p><strong>The complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_pricing.py<span class="w"> </span>.<span class="w">                                          </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==========================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">==========================</span>
</code></pre></div>

<p><strong>Let's parse this</strong>:</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>collected 1 item</code></p>
<ul>
<li><strong>What this tells us</strong>: This is the most important clue. Previously, pytest collected 2 items. Now it only finds one. This means one of our tests has become invisible to the test runner.</li>
</ul>
</li>
<li>
<p><strong>The test execution line</strong>: <code>tests/test_pricing.py .</code></p>
<ul>
<li><strong>What this tells us</strong>: Pytest ran the tests in <code>test_pricing.py</code> and found one test, which passed (indicated by the <code>.</code>).</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: Pytest did not run our second test because its name, <code>check_discount_at_lower_boundary</code>, does not follow the required naming convention.
<strong>Why the current approach can't solve this</strong>: The function is perfectly valid Python code, but it doesn't conform to the contract pytest expects for a test function.
<strong>What we need</strong>: To understand and adhere to pytest's discovery rules.</p>
<h3 id="pytests-discovery-rules">Pytest's Discovery Rules</h3>
<p>Pytest searches the current directory and subdirectories for test modules and functions based on these default conventions:</p>
<ol>
<li><strong>File Names</strong>: It looks for files named <code>test_*.py</code> or <code>*_test.py</code>.</li>
<li><strong>Function Names</strong>: Inside those files, it looks for functions prefixed with <code>test_</code>.</li>
<li><strong>Class Names</strong>: It will also discover tests inside classes prefixed with <code>Test</code> (e.g., <code>class TestPricing:</code>), as long as the methods inside are also prefixed with <code>test_</code>. We will cover test classes in a later chapter.</li>
</ol>
<p>Our function <code>check_discount_at_lower_boundary</code> failed rule #2.</p>
<h3 id="banish-magic-with-mechanics-pytest-collect-only">Banish Magic with Mechanics: <code>pytest --collect-only</code></h3>
<p>How can you see what pytest sees without actually running the tests? Pytest provides a powerful command-line flag for this: <code>--collect-only</code>. This command performs the entire discovery process and then prints a list of all the tests it found.</p>
<p>Let's run it on our broken version:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>--collect-only
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item
&lt;Module<span class="w"> </span>tests/test_pricing.py&gt;
<span class="w">  </span>&lt;Function<span class="w"> </span>test_calculate_discount_for_high_value_order&gt;

<span class="o">=======================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>item<span class="w"> </span>collected<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">=======================</span>
</code></pre></div>

<p>This output is crystal clear. Pytest reports that it found the module <code>tests/test_pricing.py</code> and, inside it, only one test function: <code>test_calculate_discount_for_high_value_order</code>. Our other function is completely absent from this list.</p>
<h3 id="the-fix-and-verification_1">The Fix and Verification</h3>
<p>Let's fix the problem by renaming the function back to its correct form.</p>
<p><strong>Before</strong>:
<code>def check_discount_at_lower_boundary():</code></p>
<p><strong>After</strong>:
<code>def test_calculate_discount_at_lower_boundary():</code></p>
<p>Now, let's run <code>pytest --collect-only</code> again.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>--collect-only
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items
&lt;Module<span class="w"> </span>tests/test_pricing.py&gt;
<span class="w">  </span>&lt;Function<span class="w"> </span>test_calculate_discount_for_high_value_order&gt;
<span class="w">  </span>&lt;Function<span class="w"> </span>test_calculate_discount_at_lower_boundary&gt;

<span class="o">=======================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>items<span class="w"> </span>collected<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">======================</span>
</code></pre></div>

<p>As expected, pytest now sees both of our tests. Running <code>pytest</code> will now execute both, and they will both pass. Adhering to the simple <code>test_</code> naming convention is the key that unlocks all of pytest's power.</p>
<h2 id="naming-conventions-that-matter">Naming Conventions That Matter</h2>
<h2 id="naming-conventions-that-matter_1">Naming Conventions That Matter</h2>
<p>We've established that test functions must start with <code>test_</code>. But what comes after the prefix is just as important. A well-named test serves as living documentation for your codebase. When a test fails a year from now, a descriptive name can save you hours of debugging.</p>
<p>Consider these two test names for the same test:</p>
<ol>
<li><code>test_function_1()</code></li>
<li><code>test_calculate_discount_for_order_total_of_20_is_5_percent()</code></li>
</ol>
<p>If <code>test_function_1()</code> fails, the output tells you almost nothing. You have to read the test's code to understand what it was trying to do. If the second test fails, you know the <em>exact business rule</em> that was violated before you even look at the code.</p>
<h3 id="a-practical-naming-pattern-test_when__should_">A Practical Naming Pattern: <code>test_when_..._should_...</code></h3>
<p>A highly effective and readable convention for naming tests is the "When/Should" or "Given/When/Then" pattern.</p>
<p>The structure is: <code>test_when_[Action or State]_should_[Expected Outcome]</code></p>
<p>Let's refactor our existing test names to follow this pattern.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pricing.py (with improved names)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">src.ecommerce.pricing</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_discount</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_when_order_total_is_high_should_apply_10_percent_discount</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given: An order total of $200</span>
<span class="sd">    When: The discount is calculated</span>
<span class="sd">    Then: The discount should be 10% ($20)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="mf">200.0</span><span class="p">)</span> <span class="o">==</span> <span class="mf">20.0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_when_order_total_is_at_5_percent_boundary_should_apply_discount</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given: An order total of exactly $20</span>
<span class="sd">    When: The discount is calculated</span>
<span class="sd">    Then: The discount should be 5% ($1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">calculate_discount</span><span class="p">(</span><span class="mf">20.0</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span>
</code></pre></div>

<h3 id="verbose-names-make-for-readable-reports">Verbose Names Make for Readable Reports</h3>
<p>This might seem overly verbose, but the payoff comes when you run your tests. By default, pytest's output is compact. However, using the verbose flag (<code>-v</code>), pytest will print each test's full name next to its result.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_pricing.py::test_when_order_total_is_high_should_apply_10_percent_discount<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
tests/test_pricing.py::test_when_order_total_is_at_5_percent_boundary_should_apply_discount<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==========================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">==========================</span>
</code></pre></div>

<p>This output reads like a checklist of your system's features. Each line is a verifiable statement about how your code behaves. When a line item turns from <code>PASSED</code> to <code>FAILED</code>, you know precisely which feature broke.</p>
<p>Good test names are one of the highest-leverage, lowest-effort practices you can adopt for a maintainable codebase.</p>
<h2 id="organizing-tests-in-your-project">Organizing Tests in Your Project</h2>
<h2 id="organizing-tests-in-your-project_1">Organizing Tests in Your Project</h2>
<p>As your project grows, you'll have dozens or even hundreds of test files. A logical and consistent project structure is essential for keeping your test suite manageable.</p>
<p>There are two common patterns for organizing tests in a Python project.</p>
<h3 id="pattern-1-the-tests-directory-recommended">Pattern 1: The <code>tests</code> Directory (Recommended)</h3>
<p>This is the most common and recommended structure. You create a top-level <code>tests</code> directory alongside your source code directory (often called <code>src</code> or named after your project).</p>
<div class="codehilite"><pre><span></span><code>my_ecommerce_project/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ ecommerce/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îî‚îÄ‚îÄ pricing.py      # &lt;-- Code under test
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ test_pricing.py     # &lt;-- Our test file
</code></pre></div>

<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>Clear Separation</strong>: Production code and test code are completely separate. This prevents you from accidentally packaging your tests into your final application distribution.</li>
<li><strong>Easy to Run</strong>: You can run all tests by simply typing <code>pytest</code> in the project root. Pytest will automatically discover the <code>tests</code> directory.</li>
<li><strong>Mirrors Structure</strong>: The structure inside <code>tests</code> can mirror the structure of your <code>src</code> directory, making it easy to find the tests for a specific module (e.g., <code>tests/api/test_client.py</code> tests <code>src/ecommerce/api/client.py</code>).</li>
</ul>
<h3 id="pattern-2-tests-alongside-code">Pattern 2: Tests Alongside Code</h3>
<p>In this pattern, test files are placed directly inside your source code packages.</p>
<div class="codehilite"><pre><span></span><code>my_ecommerce_project/
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ pyproject.toml
‚îî‚îÄ‚îÄ src/
    ‚îî‚îÄ‚îÄ ecommerce/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îú‚îÄ‚îÄ pricing.py
        ‚îî‚îÄ‚îÄ test_pricing.py  # &lt;-- Test file next to the code
</code></pre></div>

<p><strong>Advantages</strong>:</p>
<ul>
<li><strong>Proximity</strong>: Tests are located right next to the code they are testing, which can be convenient for small modules.</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li><strong>Packaging Complexity</strong>: You need to configure your build system (e.g., in <code>pyproject.toml</code>) to exclude the <code>test_*.py</code> files from your final production package. This is an extra step that is easy to get wrong.</li>
<li><strong>Clutter</strong>: It can clutter your source directories, mixing production logic with test logic.</li>
</ul>
<p>For these reasons, <strong>we will use and recommend the <code>tests</code> directory structure throughout this book.</strong> It is the standard for the vast majority of modern Python projects.</p>
<h3 id="the-role-of-__init__py">The Role of <code>__init__.py</code></h3>
<p>You'll notice empty <code>__init__.py</code> files in both the <code>src/ecommerce</code> and <code>tests</code> directories. These files tell Python to treat the directories as "packages." This allows you to use Python's import system cleanly. For example, it's what allows <code>from src.ecommerce.pricing import calculate_discount</code> to work correctly when you run <code>pytest</code> from the project root. Even if the files are empty, their presence is important.</p>
<h2 id="running-specific-tests">Running Specific Tests</h2>
<h2 id="running-specific-tests_1">Running Specific Tests</h2>
<p>As your test suite grows, running every single test every time you make a small change can become slow and inefficient. Pytest provides several powerful ways to run only the tests you care about, which is crucial for a fast and productive development workflow.</p>
<p>Let's expand our project slightly to demonstrate these features.</p>
<div class="codehilite"><pre><span></span><code>tests/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ test_inventory.py   # &lt;-- New file
‚îî‚îÄ‚îÄ test_pricing.py
</code></pre></div>

<p>Our new <code>test_inventory.py</code> file contains a simple test.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_inventory.py</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_stock_level_is_reduced_on_purchase</span><span class="p">():</span>
    <span class="c1"># A placeholder test for demonstration</span>
    <span class="k">assert</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_cannot_purchase_out_of_stock_item</span><span class="p">():</span>
    <span class="c1"># A placeholder test for demonstration</span>
    <span class="k">assert</span> <span class="kc">True</span>
</code></pre></div>

<p>Now, if we run <code>pytest --collect-only</code> from the root, we see all four tests.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>--collect-only
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">4</span><span class="w"> </span>items
&lt;Module<span class="w"> </span>tests/test_inventory.py&gt;
<span class="w">  </span>&lt;Function<span class="w"> </span>test_stock_level_is_reduced_on_purchase&gt;
<span class="w">  </span>&lt;Function<span class="w"> </span>test_cannot_purchase_out_of_stock_item&gt;
&lt;Module<span class="w"> </span>tests/test_pricing.py&gt;
<span class="w">  </span>&lt;Function<span class="w"> </span>test_when_order_total_is_high_should_apply_10_percent_discount&gt;
<span class="w">  </span>&lt;Function<span class="w"> </span>test_when_order_total_is_at_5_percent_boundary_should_apply_discount&gt;

<span class="o">=======================</span><span class="w"> </span><span class="m">4</span><span class="w"> </span>items<span class="w"> </span>collected<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">======================</span>
</code></pre></div>

<h3 id="running-tests-by-file-or-directory">Running Tests by File or Directory</h3>
<p>The simplest way to select tests is by providing a path.</p>
<p><strong>To run all tests in a directory</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># This will run all tests inside the tests/ directory (which is the default anyway)</span>
$<span class="w"> </span>pytest<span class="w"> </span>tests/

<span class="c1"># Output will show all 4 tests running</span>
...
<span class="o">==========================</span><span class="w"> </span><span class="m">4</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">==========================</span>
</code></pre></div>

<p><strong>To run all tests in a single file</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># This will only run the 2 tests inside test_pricing.py</span>
$<span class="w"> </span>pytest<span class="w"> </span>tests/test_pricing.py

<span class="c1"># Output will show only 2 tests running</span>
...
<span class="o">==========================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">==========================</span>
</code></pre></div>

<h3 id="running-a-single-test-by-node-id">Running a Single Test by Node ID</h3>
<p>If you want to run one specific test function, you can specify its "Node ID". The Node ID is the unique path to a test, in the format <code>path/to/file.py::test_function_name</code>.</p>
<p><strong>To run one specific test function</strong>:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>tests/test_pricing.py::test_when_order_total_is_high_should_apply_10_percent_discount

<span class="c1"># Output will show only 1 test running</span>
...
<span class="o">==========================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">==========================</span>
</code></pre></div>

<p>This is extremely useful when you are focusing on a single function and want immediate feedback without waiting for the entire suite to run.</p>
<h3 id="running-tests-by-keyword-expression-k">Running Tests by Keyword Expression (<code>-k</code>)</h3>
<p>Perhaps the most flexible method is using the <code>-k</code> flag, which allows you to select tests based on a keyword expression that matches their names.</p>
<p><strong>To run tests with "discount" in their name</strong>:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-k<span class="w"> </span><span class="s2">&quot;discount&quot;</span><span class="w"> </span>-v
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">4</span><span class="w"> </span>items<span class="w"> </span>/<span class="w"> </span><span class="m">2</span><span class="w"> </span>deselected<span class="w"> </span>/<span class="w"> </span><span class="m">2</span><span class="w"> </span>selected

tests/test_pricing.py::test_when_order_total_is_high_should_apply_10_percent_discount<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
tests/test_pricing.py::test_when_order_total_is_at_5_percent_boundary_should_apply_discount<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed,<span class="w"> </span><span class="m">2</span><span class="w"> </span>deselected<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===================</span>
</code></pre></div>

<p>Notice how pytest reports that it <code>deselected</code> 2 tests and <code>selected</code> 2.</p>
<p>You can also use boolean operators like <code>and</code>, <code>or</code>, and <code>not</code>. The expression is case-sensitive.</p>
<p><strong>To run tests with "stock" but NOT "purchase" in their name</strong>:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-k<span class="w"> </span><span class="s2">&quot;stock and not purchase&quot;</span><span class="w"> </span>-v
<span class="o">=========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==========================</span>
...
collected<span class="w"> </span><span class="m">4</span><span class="w"> </span>items<span class="w"> </span>/<span class="w"> </span><span class="m">3</span><span class="w"> </span>deselected<span class="w"> </span>/<span class="w"> </span><span class="m">1</span><span class="w"> </span>selected

tests/test_inventory.py::test_cannot_purchase_out_of_stock_item<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed,<span class="w"> </span><span class="m">3</span><span class="w"> </span>deselected<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===================</span>
</code></pre></div>

<p>Mastering these selection techniques is key to an efficient testing workflow. You can quickly zero in on the tests relevant to your current task, get fast feedback, and iterate rapidly.</p>
        </div>
        <div class="footer">
            Generated on 2025-11-24 14:31:15 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>