<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>04 Fixtures‚ÄîThe Foundation of Pytest</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">02 Core Testing Concepts</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-4-fixturesthe-foundation-of-pytest">Chapter 4: Fixtures‚ÄîThe Foundation of Pytest</h1>
<h2 id="what-are-fixtures">What Are Fixtures?</h2>
<h2 id="what-are-fixtures_1">What Are Fixtures?</h2>
<p>In the world of testing, we often find ourselves writing the same setup and cleanup code over and over again. Imagine testing a user management system. For each test, you might need to:</p>
<ol>
<li>Connect to a database.</li>
<li>Create a sample user.</li>
<li>Perform the test action (e.g., update the user's email).</li>
<li>Verify the result.</li>
<li>Remove the sample user.</li>
<li>Close the database connection.</li>
</ol>
<p>Repeating steps 1, 2, 5, and 6 for every single test is tedious, error-prone, and makes your tests hard to read. This is the exact problem fixtures are designed to solve.</p>
<p>A <strong>fixture</strong> is a function that provides a reliable, repeatable context for your tests. It handles the setup before a test runs and the cleanup after it finishes. Think of it as a service that prepares the stage for your test and cleans up the props afterward.</p>
<h3 id="the-pain-of-repetitive-setup">The Pain of Repetitive Setup</h3>
<p>Let's look at a simple example without fixtures. We have a <code>Wallet</code> class and we want to test adding and spending cash.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/wallet.py</span>

<span class="k">class</span><span class="w"> </span><span class="nc">InsufficientAmount</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Wallet</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_amount</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">=</span> <span class="n">initial_amount</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spend_cash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InsufficientAmount</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not enough available to spend </span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">-=</span> <span class="n">amount</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_cash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">balance</span> <span class="o">+=</span> <span class="n">amount</span>
</code></pre></div>

<p>Now, let's write some tests. Notice the repetition in creating a <code>Wallet</code> instance for each test.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_wallet_no_fixtures.py</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">src.wallet</span><span class="w"> </span><span class="kn">import</span> <span class="n">Wallet</span><span class="p">,</span> <span class="n">InsufficientAmount</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_default_initial_amount</span><span class="p">():</span>
    <span class="c1"># Setup</span>
    <span class="n">wallet</span> <span class="o">=</span> <span class="n">Wallet</span><span class="p">()</span>
    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">wallet</span><span class="o">.</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_setting_initial_amount</span><span class="p">():</span>
    <span class="c1"># Setup</span>
    <span class="n">wallet</span> <span class="o">=</span> <span class="n">Wallet</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">wallet</span><span class="o">.</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">100</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_wallet_add_cash</span><span class="p">():</span>
    <span class="c1"># Setup</span>
    <span class="n">wallet</span> <span class="o">=</span> <span class="n">Wallet</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="c1"># Action</span>
    <span class="n">wallet</span><span class="o">.</span><span class="n">add_cash</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>
    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">wallet</span><span class="o">.</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">100</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_wallet_spend_cash</span><span class="p">():</span>
    <span class="c1"># Setup</span>
    <span class="n">wallet</span> <span class="o">=</span> <span class="n">Wallet</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="c1"># Action</span>
    <span class="n">wallet</span><span class="o">.</span><span class="n">spend_cash</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">wallet</span><span class="o">.</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">10</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_wallet_spend_cash_raises_exception_on_insufficient_amount</span><span class="p">():</span>
    <span class="c1"># Setup</span>
    <span class="n">wallet</span> <span class="o">=</span> <span class="n">Wallet</span><span class="p">()</span>
    <span class="c1"># Action &amp; Assert</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="n">InsufficientAmount</span><span class="p">):</span>
        <span class="n">wallet</span><span class="o">.</span><span class="n">spend_cash</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div>

<p>This works, but the <code>wallet = Wallet(...)</code> line is repeated in every test. If the <code>Wallet</code> initialization became more complex (e.g., requiring a database connection or a configuration object), changing it in every test would be a nightmare.</p>
<h3 id="the-fixture-philosophy-dependency-injection">The Fixture Philosophy: Dependency Injection</h3>
<p>Pytest fixtures introduce a powerful concept from software engineering called <strong>dependency injection</strong>. Instead of creating objects inside your test functions, your test functions <em>declare</em> what they need as arguments. Pytest sees these arguments, finds the corresponding fixtures, runs them, and "injects" the results into your test.</p>
<p>The test says, "I need a wallet to run." Pytest says, "I know how to make a wallet. Here you go."</p>
<p>This approach has profound benefits:
1.  <strong>Decoupling</strong>: Your test logic is separated from the setup logic. The test cares about <em>what</em> it's testing, not <em>how</em> the object is created.
2.  <strong>Reusability</strong>: The same fixture can be used by hundreds of tests across your entire project.
3.  <strong>Maintainability</strong>: If the <code>Wallet</code> initialization changes, you only need to update the fixture in one place.</p>
<p>Fixtures are the backbone of a clean, scalable, and maintainable pytest suite. They are more than just setup/teardown helpers; they are a powerful system for managing the resources and state your tests depend on.</p>
<h2 id="simple-fixtures-setup-and-teardown">Simple Fixtures: Setup and Teardown</h2>
<h2 id="simple-fixtures-setup-and-teardown_1">Simple Fixtures: Setup and Teardown</h2>
<p>The most basic fixture provides an object or value to a test. Let's refactor our wallet tests to use one. A fixture is just a Python function decorated with <code>@pytest.fixture</code>.</p>
<h3 id="a-basic-setup-fixture">A Basic Setup Fixture</h3>
<p>We can create a fixture that provides an empty wallet. The name of the function (<code>wallet</code>) becomes the name of the fixture that tests can request.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_wallet_with_fixture.py</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.wallet</span><span class="w"> </span><span class="kn">import</span> <span class="n">Wallet</span><span class="p">,</span> <span class="n">InsufficientAmount</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">wallet</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a Wallet instance with a balance of 20.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Wallet</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_wallet_spend_cash</span><span class="p">(</span><span class="n">wallet</span><span class="p">):</span>
    <span class="c1"># The &#39;wallet&#39; argument is automatically provided by pytest</span>
    <span class="n">wallet</span><span class="o">.</span><span class="n">spend_cash</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">wallet</span><span class="o">.</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">10</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_wallet_add_cash</span><span class="p">(</span><span class="n">wallet</span><span class="p">):</span>
    <span class="c1"># This test also gets its own, separate Wallet instance</span>
    <span class="n">wallet</span><span class="o">.</span><span class="n">add_cash</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">wallet</span><span class="o">.</span><span class="n">balance</span> <span class="o">==</span> <span class="mi">100</span>
</code></pre></div>

<p>Look at how much cleaner the tests are! They declare their need for a <code>wallet</code>, and pytest provides it. Each test gets a <em>fresh</em> <code>Wallet</code> instance created by the fixture, ensuring that tests are isolated from each other.</p>
<h3 id="adding-teardown-with-yield">Adding Teardown with <code>yield</code></h3>
<p>What if our setup requires a corresponding cleanup action? For example, connecting to a database requires disconnecting later. Fixtures handle this elegantly using the <code>yield</code> keyword.</p>
<p>Code before the <code>yield</code> is the <strong>setup</strong> phase. The <code>yield</code> statement passes control to the test function, providing it with the resource. After the test function completes (whether it passes, fails, or raises an error), the code after the <code>yield</code> is executed as the <strong>teardown</strong> phase.</p>
<p>Let's create a simple example to see this in action. We'll use <code>print</code> statements to trace the execution flow.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_fixture_teardown.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">setup_and_teardown</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- SETUP: Code before yield ---&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">}</span>
    <span class="k">yield</span> <span class="n">data</span>  <span class="c1"># This is where the test runs</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- TEARDOWN: Code after yield ---&quot;</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_using_fixture</span><span class="p">(</span><span class="n">setup_and_teardown</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; RUNNING TEST: test_using_fixture &lt;&lt;&lt;&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s2">&quot;key&quot;</span> <span class="ow">in</span> <span class="n">setup_and_teardown</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_another_test</span><span class="p">(</span><span class="n">setup_and_teardown</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; RUNNING TEST: test_another_test &lt;&lt;&lt;&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">setup_and_teardown</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span>
</code></pre></div>

<p>Now, run this with the <code>-s</code> flag (to show print statements) and <code>-v</code> (for verbose output).</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>-v<span class="w"> </span>-s<span class="w"> </span>tests/test_fixture_teardown.py
</code></pre></div>

<p>The output clearly shows the execution order for each test:</p>
<div class="codehilite"><pre><span></span><code>=========================== test session starts ============================
...
collected 2 items

tests/test_fixture_teardown.py::test_using_fixture
--- SETUP: Code before yield ---

&gt;&gt;&gt; RUNNING TEST: test_using_fixture &lt;&lt;&lt;
PASSED
--- TEARDOWN: Code after yield ---

tests/test_fixture_teardown.py::test_another_test
--- SETUP: Code before yield ---

&gt;&gt;&gt; RUNNING TEST: test_another_test &lt;&lt;&lt;
PASSED
--- TEARDOWN: Code after yield ---

============================ 2 passed in ...s ==============================
</code></pre></div>

<p>Notice the pattern: <strong>Setup -&gt; Test -&gt; Teardown</strong>. This cycle repeats independently for each test that uses the fixture. This is the fundamental mechanism that guarantees test isolation.</p>
<h2 id="the-pytestfixture-decorator">The @pytest.fixture Decorator</h2>
<h2 id="the-pytestfixture-decorator_1">The @pytest.fixture Decorator</h2>
<p>The <code>@pytest.fixture</code> decorator is the entry point to this entire system. It signals to pytest that a function is not a test, but a factory for providing resources to tests.</p>
<p>Let's break down its role and common arguments.</p>
<h3 id="basic-usage">Basic Usage</h3>
<p>As we've seen, the simplest form is just the decorator itself:</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">my_data</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">,</span> <span class="s2">&quot;email&quot;</span><span class="p">:</span> <span class="s2">&quot;alice@example.com&quot;</span><span class="p">}</span>
</code></pre></div>

<p>Any test function that includes <code>my_data</code> as a parameter will receive the dictionary returned by this fixture.</p>
<h3 id="naming-fixtures">Naming Fixtures</h3>
<p>The name of the fixture is the name of the decorated function. It's a best practice to give fixtures descriptive names that clearly state what they provide, such as <code>db_connection</code>, <code>api_client</code>, or <code>sample_user_data</code>.</p>
<h3 id="using-autouse-for-automatic-execution">Using <code>autouse</code> for Automatic Execution</h3>
<p>Sometimes, you have a fixture that <em>every</em> test needs, but you don't want to add it as an argument to every single test function. A common example is a fixture that resets a database or clears a cache.</p>
<p>For this, you can use the <code>autouse=True</code> argument.</p>
<p>Let's create a fixture that prints a message before and after each test, without the tests needing to request it.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_autouse_fixture.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">announce_test_start_end</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A fixture that runs automatically for every test.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Test starting ---&quot;</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Test ending ---&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_example_1</span><span class="p">():</span>
    <span class="k">assert</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_example_2</span><span class="p">():</span>
    <span class="k">assert</span> <span class="s2">&quot;a&quot;</span> <span class="ow">in</span> <span class="s2">&quot;abc&quot;</span>
</code></pre></div>

<p>Running this with <code>pytest -s</code> shows that the fixture runs for both tests, even though they don't explicitly request it:</p>
<div class="codehilite"><pre><span></span><code>=========================== test session starts ============================
...
collected 2 items

tests/test_autouse_fixture.py::test_example_1
--- Test starting ---
PASSED
--- Test ending ---

tests/test_autouse_fixture.py::test_example_2
--- Test starting ---
PASSED
--- Test ending ---

============================ 2 passed in ...s ==============================
</code></pre></div>

<p><strong>A Word of Caution:</strong> Use <code>autouse=True</code> sparingly. It can make it harder to understand where a test's setup is coming from, as the dependency is no longer explicitly declared in the test's signature. It's best reserved for broad, cross-cutting concerns like logging setup, database cleaning, or performance monitoring.</p>
<h2 id="fixture-scope-function-class-module-and-session">Fixture Scope: Function, Class, Module, and Session</h2>
<h2 id="fixture-scope-function-class-module-and-session_1">Fixture Scope: Function, Class, Module, and Session</h2>
<p>By default, a fixture is set up and torn down for <strong>every single test function</strong>. This is the <code>function</code> scope, and it provides the highest level of isolation. However, sometimes this is inefficient. If you need to connect to a database, you don't want to establish a new connection for each of the 500 tests in your suite.</p>
<p>Pytest allows you to control the lifecycle of a fixture using the <code>scope</code> argument. This is one of the most important concepts for writing efficient test suites.</p>
<p>The available scopes are, in order of increasing lifetime:
1.  <code>function</code>: The default. Runs once per test function.
2.  <code>class</code>: Runs once per test class.
3.  <code>module</code>: Runs once per test module (i.e., per <code>.py</code> file).
4.  <code>session</code>: Runs once per test session (i.e., once for the entire <code>pytest</code> command invocation).</p>
<h3 id="visualizing-scopes">Visualizing Scopes</h3>
<p>The best way to understand scopes is to see them in action. Let's create one fixture for each scope and use <code>print</code> statements to watch when they are created and destroyed.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_scopes.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;session&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">session_fixture</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Setting up SESSION fixture&quot;</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tearing down SESSION fixture&quot;</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">module_fixture</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Setting up MODULE fixture&quot;</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tearing down MODULE fixture&quot;</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">class_fixture</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Setting up CLASS fixture&quot;</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tearing down CLASS fixture&quot;</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;function&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">function_fixture</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Setting up FUNCTION fixture&quot;</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tearing down FUNCTION fixture&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_standalone</span><span class="p">(</span><span class="n">session_fixture</span><span class="p">,</span> <span class="n">module_fixture</span><span class="p">,</span> <span class="n">function_fixture</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;&gt; Running standalone test&quot;</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">usefixtures</span><span class="p">(</span><span class="s2">&quot;class_fixture&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TestClass</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_method_1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session_fixture</span><span class="p">,</span> <span class="n">module_fixture</span><span class="p">,</span> <span class="n">function_fixture</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;&gt; Running test_method_1&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">test_method_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session_fixture</span><span class="p">,</span> <span class="n">module_fixture</span><span class="p">,</span> <span class="n">function_fixture</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;&gt; Running test_method_2&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Now, run this file with <code>pytest -v -s</code>. The output is a perfect map of the fixture lifecycle.</p>
<div class="codehilite"><pre><span></span><code>=========================== test session starts ============================
...
collected 3 items

tests/test_scopes.py::test_standalone
Setting up SESSION fixture
Setting up MODULE fixture
Setting up FUNCTION fixture
&gt;&gt; Running standalone test
PASSED
Tearing down FUNCTION fixture

tests/test_scopes.py::TestClass::test_method_1
Setting up CLASS fixture
Setting up FUNCTION fixture
&gt;&gt; Running test_method_1
PASSED
Tearing down FUNCTION fixture

tests/test_scopes.py::TestClass::test_method_2
Setting up FUNCTION fixture
&gt;&gt; Running test_method_2
PASSED
Tearing down FUNCTION fixture
Tearing down CLASS fixture
Tearing down MODULE fixture
Tearing down SESSION fixture

============================ 3 passed in ...s ==============================
</code></pre></div>

<p>Let's trace the execution:
1.  <code>session_fixture</code>: Sets up once at the very beginning. Tears down once at the very end.
2.  <code>module_fixture</code>: Sets up once before any test in <code>test_scopes.py</code> runs. Tears down after all tests in the file are complete.
3.  <code>class_fixture</code>: Sets up once before <code>test_method_1</code> (the first test in <code>TestClass</code>). Tears down after <code>test_method_2</code> (the last test in <code>TestClass</code>).
4.  <code>function_fixture</code>: Sets up and tears down around <em>each</em> of the three tests.</p>
<h3 id="choosing-the-right-scope">Choosing the Right Scope</h3>
<ul>
<li><strong><code>function</code> (Default):</strong> Use for mutable objects that need to be reset for every test to ensure isolation (e.g., an empty list, a user object you plan to modify).</li>
<li><strong><code>class</code>:</strong> Useful when you have a group of tests in a class that all operate on the same expensive-to-create resource, and the tests don't modify the resource in a way that would affect other tests.</li>
<li><strong><code>module</code>:</strong> Ideal for resources that are read-only or can be shared across all tests in a file, like loading a large configuration or data file.</li>
<li><strong><code>session</code>:</strong> Use for very expensive, globally shared resources like a database connection pool or a web server instance that can be used by the entire test suite.</li>
</ul>
<p><strong>Golden Rule:</strong> Use the narrowest scope you can. Start with <code>function</code> and only increase the scope (<code>class</code>, <code>module</code>, <code>session</code>) when you have a clear performance reason to do so, and you are sure that sharing the fixture won't cause tests to interfere with each other.</p>
<h2 id="using-fixtures-in-your-tests">Using Fixtures in Your Tests</h2>
<h2 id="using-fixtures-in-your-tests_1">Using Fixtures in Your Tests</h2>
<p>There are two primary ways to apply a fixture to a test: by adding it as a function argument or by using a marker.</p>
<h3 id="requesting-fixtures-as-arguments">Requesting Fixtures as Arguments</h3>
<p>This is the most common and explicit method. By including the fixture's name as a parameter in your test function, you are telling pytest, "This test depends on this fixture." Pytest will then execute the fixture and pass its return value (or the value from <code>yield</code>) to the test.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_requesting_fixtures.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">user_data</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Provides a dictionary of user data.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;John Doe&quot;</span><span class="p">,</span> <span class="s2">&quot;email&quot;</span><span class="p">:</span> <span class="s2">&quot;john.doe@example.com&quot;</span><span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_user_name</span><span class="p">(</span><span class="n">user_data</span><span class="p">):</span>
    <span class="c1"># The `user_data` argument is filled by the fixture&#39;s return value</span>
    <span class="k">assert</span> <span class="n">user_data</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;John Doe&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_user_email</span><span class="p">(</span><span class="n">user_data</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">user_data</span><span class="p">[</span><span class="s2">&quot;email&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;john.doe@example.com&quot;</span>
</code></pre></div>

<p>This method is preferred because it makes the test's dependencies crystal clear just by reading its signature.</p>
<h3 id="using-the-pytestmarkusefixtures-marker">Using the <code>@pytest.mark.usefixtures</code> Marker</h3>
<p>Sometimes, a fixture doesn't return a value; it just performs an action (like cleaning a database). In these cases, there's nothing to pass to the test function. For this, you can use the <code>@pytest.mark.usefixtures</code> marker.</p>
<p>This is useful for applying the same setup/teardown logic to an entire class of tests.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_usefixtures_marker.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">clean_database</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A fixture that doesn&#39;t return anything, just performs actions.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">... Cleaning database before test ...&quot;</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">... Cleaning database after test ...&quot;</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">usefixtures</span><span class="p">(</span><span class="s2">&quot;clean_database&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TestUserOperations</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_create_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;&gt; Running test_create_user&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">test_delete_user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;&gt; Running test_delete_user&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="kc">True</span>
</code></pre></div>

<p>When you run this file with <code>pytest -s</code>, you'll see the "Cleaning database" messages appear before and after each test method in the class, even though <code>clean_database</code> is not listed as an argument. The marker applies the fixture to every test within its scope (in this case, the <code>TestUserOperations</code> class).</p>
<h3 id="discovering-available-fixtures">Discovering Available Fixtures</h3>
<p>How does pytest even know what fixtures are available? You can ask it directly! The <code>--fixtures</code> command-line flag will list all available fixtures, including built-in ones and those you've defined.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Run this from your project&#39;s root directory</span>
pytest<span class="w"> </span>--fixtures
</code></pre></div>

<p>The output will be a detailed list of every fixture, where it's defined, and its docstring. This is an incredibly useful tool for understanding the testing environment and for debugging issues where a fixture might not be found.</p>
<div class="codehilite"><pre><span></span><code>=========================== test session starts ============================
...
======================= fixtures defined from ... ==========================
wallet
    tests/test_wallet_with_fixture.py:6
    Returns a Wallet instance with a balance of 20.

user_data
    tests/test_requesting_fixtures.py:4
    Provides a dictionary of user data.

... many built-in fixtures like capsys, tmp_path, etc. ...
</code></pre></div>

<p>This command banishes the "magic" and shows you exactly what pytest sees.</p>
<h2 id="fixture-dependencies-and-composition">Fixture Dependencies and Composition</h2>
<h2 id="fixture-dependencies-and-composition_1">Fixture Dependencies and Composition</h2>
<p>This is where the true power of pytest fixtures shines. <strong>Fixtures can request other fixtures.</strong> This allows you to build up complex test contexts from small, reusable, independent components. This is a classic example of the software design principle "composition over inheritance."</p>
<h3 id="the-problem-a-fat-fixture">The Problem: A "Fat" Fixture</h3>
<p>Imagine setting up a test that requires a logged-in user who has placed an order. A naive approach might be to create one giant fixture that does everything.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># (This is an anti-pattern example)</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fat_fixture_for_order_test</span><span class="p">():</span>
    <span class="c1"># 1. Connect to DB</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">connect_to_database</span><span class="p">()</span>

    <span class="c1"># 2. Create a user</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">create_user</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;testuser&quot;</span><span class="p">)</span>

    <span class="c1"># 3. Log the user in</span>
    <span class="n">api_client</span> <span class="o">=</span> <span class="n">APIClient</span><span class="p">()</span>
    <span class="n">api_client</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

    <span class="c1"># 4. Create an order for the user</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">create_order</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;item1&quot;</span><span class="p">,</span> <span class="s2">&quot;item2&quot;</span><span class="p">])</span>

    <span class="k">yield</span> <span class="n">api_client</span><span class="p">,</span> <span class="n">order</span>

    <span class="c1"># Teardown in reverse</span>
    <span class="n">db</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
</code></pre></div>

<p>This is hard to read, hard to maintain, and impossible to reuse. What if you need just a database connection? Or just a logged-in client? You'd have to duplicate code.</p>
<h3 id="the-solution-composable-fixtures">The Solution: Composable Fixtures</h3>
<p>Let's refactor this into small, focused fixtures that depend on each other.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_composition.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="c1"># Fixture 1: The base resource (e.g., a database connection)</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">db_connection</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Connecting to database...)&quot;</span><span class="p">)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="s2">&quot;connected&quot;</span><span class="p">}</span> <span class="c1"># Fake connection object</span>
    <span class="k">yield</span> <span class="n">connection</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Disconnecting from database...)&quot;</span><span class="p">)</span>
    <span class="n">connection</span><span class="p">[</span><span class="s2">&quot;status&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;disconnected&quot;</span>

<span class="c1"># Fixture 2: Depends on db_connection</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">api_client</span><span class="p">(</span><span class="n">db_connection</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Creating API client with </span><span class="si">{</span><span class="n">db_connection</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> DB)&quot;</span><span class="p">)</span>
    <span class="c1"># This fixture can use the db_connection</span>
    <span class="k">assert</span> <span class="n">db_connection</span><span class="p">[</span><span class="s2">&quot;status&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;connected&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
    <span class="k">yield</span> <span class="n">client</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Tearing down API client)&quot;</span><span class="p">)</span>

<span class="c1"># Fixture 3: Depends on api_client</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">logged_in_client</span><span class="p">(</span><span class="n">api_client</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Logging in client...)&quot;</span><span class="p">)</span>
    <span class="n">api_client</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;testuser&quot;</span>
    <span class="k">yield</span> <span class="n">api_client</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Logging out client...)&quot;</span><span class="p">)</span>
    <span class="n">api_client</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># The test requests the final, most complex fixture it needs.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_user_profile</span><span class="p">(</span><span class="n">logged_in_client</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt; Running test_user_profile&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">logged_in_client</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;testuser&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_guest_access</span><span class="p">(</span><span class="n">api_client</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt; Running test_guest_access&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">api_client</span><span class="p">[</span><span class="s2">&quot;user&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
</code></pre></div>

<p>Now, run this with <code>pytest -v -s</code>. Pay close attention to the setup order for <code>test_user_profile</code>.</p>
<div class="codehilite"><pre><span></span><code>=========================== test session starts ============================
...
collected 2 items

tests/test_composition.py::test_user_profile
(Connecting to database...)
(Creating API client with connected DB)
(Logging in client...)

&gt;&gt; Running test_user_profile
PASSED
(Logging out client...)

(Tearing down API client)

tests/test_composition.py::test_guest_access
(Creating API client with connected DB)

&gt;&gt; Running test_guest_access
PASSED
(Tearing down API client)

(Disconnecting from database...)

============================ 2 passed in ...s ==============================
</code></pre></div>

<p>Notice the elegant dependency resolution:
1.  <code>test_user_profile</code> needs <code>logged_in_client</code>.
2.  <code>logged_in_client</code> needs <code>api_client</code>.
3.  <code>api_client</code> needs <code>db_connection</code>.
4.  Pytest executes them in the correct order: <code>db_connection</code> -&gt; <code>api_client</code> -&gt; <code>logged_in_client</code> -&gt; test.
5.  The teardown happens in the exact reverse order.</p>
<p>For <code>test_guest_access</code>, which only needs <code>api_client</code>, pytest is smart enough to only run the <code>db_connection</code> and <code>api_client</code> fixtures.</p>
<p>This compositional pattern is the key to building a powerful and maintainable test suite. You create a library of building blocks (fixtures) and each test simply requests the final assembled product it needs.</p>
<h2 id="sharing-fixtures-across-files-conftestpy">Sharing Fixtures Across Files (conftest.py)</h2>
<h2 id="sharing-fixtures-across-files-conftestpy_1">Sharing Fixtures Across Files (conftest.py)</h2>
<p>As your test suite grows, you'll find that many fixtures are useful across multiple test files. For example, a <code>db_connection</code> fixture is likely needed by tests for users, products, and orders. Copying and pasting this fixture into every file would violate the DRY (Don't Repeat Yourself) principle.</p>
<p>Pytest solves this with a special file named <code>conftest.py</code>.</p>
<h3 id="the-role-of-conftestpy">The Role of <code>conftest.py</code></h3>
<p>When pytest runs, it searches for <code>conftest.py</code> files in the test directories. Any fixtures (and hooks, which we'll cover later) defined in a <code>conftest.py</code> file become automatically available to all tests in that directory and any of its subdirectories, without needing to be imported.</p>
<p>It acts as a local plugin or a shared utility module for your tests.</p>
<h3 id="example-a-shared-data-fixture">Example: A Shared <code>data</code> Fixture</h3>
<p>Let's set up a project structure like this:</p>
<div class="codehilite"><pre><span></span><code>project/
‚îú‚îÄ‚îÄ conftest.py
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ test_alpha.py
    ‚îî‚îÄ‚îÄ subdir/
        ‚îî‚îÄ‚îÄ test_beta.py
</code></pre></div>

<p>First, we define a shared fixture in the root <code>conftest.py</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># conftest.py</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;session&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">shared_data</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A session-scoped fixture available to all tests.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Setting up shared_data fixture)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;items&quot;</span><span class="p">:</span> <span class="p">[]}</span>
</code></pre></div>

<p>Now, we can use this fixture in <code>test_alpha.py</code> without importing anything.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_alpha.py</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_alpha_uses_shared_data</span><span class="p">(</span><span class="n">shared_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This test can access shared_data directly.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shared_data</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span>
    <span class="n">shared_data</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt; test_alpha: shared_data is </span><span class="si">{</span><span class="n">shared_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>And we can also use it in a test file in a subdirectory.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/subdir/test_beta.py</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_beta_uses_shared_data</span><span class="p">(</span><span class="n">shared_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This test, in a subdirectory, can also access it.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shared_data</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span>
    <span class="n">shared_data</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;beta&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt; test_beta: shared_data is </span><span class="si">{</span><span class="n">shared_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Finally, let's add one more test to see the final state of our session-scoped fixture.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_final_state.py</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_final_state_of_shared_data</span><span class="p">(</span><span class="n">shared_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks the state after other tests have run.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt; test_final_state: shared_data is </span><span class="si">{</span><span class="n">shared_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s2">&quot;alpha&quot;</span> <span class="ow">in</span> <span class="n">shared_data</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="s2">&quot;beta&quot;</span> <span class="ow">in</span> <span class="n">shared_data</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">]</span>
</code></pre></div>

<p>Run <code>pytest -v -s</code>. The output will show that the same <code>shared_data</code> dictionary instance was passed to all tests.</p>
<div class="codehilite"><pre><span></span><code>=========================== test session starts ============================
...
collected 3 items

(Setting up shared_data fixture)

tests/test_alpha.py::test_alpha_uses_shared_data
&gt;&gt; test_alpha: shared_data is {&#39;items&#39;: [&#39;alpha&#39;]}
PASSED

tests/subdir/test_beta.py::test_beta_uses_shared_data
&gt;&gt; test_beta: shared_data is {&#39;items&#39;: [&#39;alpha&#39;, &#39;beta&#39;]}
PASSED

tests/test_final_state.py::test_final_state_of_shared_data
&gt;&gt; test_final_state: shared_data is {&#39;items&#39;: [&#39;alpha&#39;, &#39;beta&#39;]}
PASSED

============================ 3 passed in ...s ==============================
</code></pre></div>

<p>This demonstrates both the power and the danger of higher-scoped fixtures. The <code>session</code> scope allowed us to share state, but it also means the tests are no longer perfectly isolated. <code>test_final_state</code> passes only because the other two tests ran first and modified the shared object. This is often undesirable, but <code>conftest.py</code> is the mechanism that enables it.</p>
<h3 id="best-practices-for-conftestpy">Best Practices for <code>conftest.py</code></h3>
<ul>
<li>Place your most general, widely-used fixtures (like database connections, API clients) in the root <code>conftest.py</code> of your <code>tests/</code> directory.</li>
<li>You can have multiple <code>conftest.py</code> files. A fixture in <code>tests/api/conftest.py</code> would be available to tests in <code>tests/api/</code> but not to tests in <code>tests/db/</code>. This allows you to scope your shared fixtures to specific parts of your application.</li>
<li><strong>Never</strong> <code>import</code> anything from a <code>conftest.py</code> file. Pytest's discovery mechanism handles it for you.</li>
</ul>
        </div>
        <div class="footer">
            Generated on 2025-11-22 17:25:04 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>