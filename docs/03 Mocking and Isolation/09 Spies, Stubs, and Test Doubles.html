<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>09 Spies, Stubs, and Test Doubles</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">03 Mocking and Isolation</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-9-spies-stubs-and-test-doubles">Chapter 9: Spies, Stubs, and Test Doubles</h1>
<h2 id="the-difference-between-mocks-stubs-and-spies">The Difference Between Mocks, Stubs, and Spies</h2>
<h2 id="the-problem-testing-code-with-external-dependencies">The Problem: Testing Code with External Dependencies</h2>
<p>So far, we've tested functions that are self-contained. They take inputs, perform calculations, and return outputs. But real-world code is messy. It interacts with databases, calls external APIs, reads from the filesystem, and depends on other complex systems.</p>
<p>How do you test a function that charges a credit card without actually charging a real credit card every time you run your tests? How do you test a function that relies on a web service that might be slow, unreliable, or rate-limited?</p>
<p>This is where <strong>Test Doubles</strong> come in. A test double is a general term for any object or function that stands in for a real one during a test. Pytest doesn't have its own test double library; instead, it integrates seamlessly with the standard <code>unittest.mock</code> library, which we will use throughout this chapter.</p>
<p>The three most common types of test doubles are:
1.  <strong>Stubs</strong>: Objects that provide canned answers to calls made during the test. They are used when you don't care about the interaction, only that the system under test gets the data it needs to proceed.
2.  <strong>Spies</strong>: Objects that record information about how they were called (e.g., how many times, with what arguments). They are used when you want to verify the <em>interaction</em> between your system and its dependency.
3.  <strong>Mocks</strong>: A more complex type of double that is pre-programmed with expectations. These expectations form a specification of the calls they are expected to receive. A mock will cause the test to fail if it receives a call that isn't in its specification.</p>
<p>In Python, the <code>unittest.mock.MagicMock</code> class is so powerful that it can act as a stub, a spy, or a mock, often at the same time. We will focus on using it to create stubs and spies.</p>
<h3 id="phase-1-establish-the-reference-implementation">Phase 1: Establish the Reference Implementation</h3>
<p>Let's build our anchor example for this chapter: a simple e-commerce order processing system. It needs to calculate the total price of an order and then charge a payment gateway.</p>
<p>The dependency we need to isolate is the <code>PaymentGateway</code>. In a real system, this class would handle complex, slow, and expensive communication with a service like Stripe or PayPal.</p>
<p>Here's our initial, untestable code.</p>
<p><strong>The System Under Test:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># project/services.py</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PaymentGateway</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A real payment gateway that connects to an external service.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Charges the customer&#39;s card.</span>
<span class="sd">        In a real system, this would make an API call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simulate a slow network call</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Connecting to payment provider...&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connection successful.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;INVALID_TOKEN&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid payment token.&quot;</span><span class="p">)</span>

        <span class="c1"># Simulate a successful transaction ID</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;txn_</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Order</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">shipping_address</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shipping_address</span> <span class="o">=</span> <span class="n">shipping_address</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_order</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes an order by charging the payment gateway.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing order with total: $</span><span class="si">{</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Here is our dependency on the external system</span>
    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGateway</span><span class="p">()</span>
    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Order successful! Transaction ID: </span><span class="si">{</span><span class="n">transaction_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<p><strong>The Naive Test:</strong></p>
<p>Our first attempt at a test will simply call the function and see what happens.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_naive.py</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">project.services</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_naive</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a bad test. It&#39;s slow and makes a real network call.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">},</span> <span class="c1"># Prices in cents</span>
        <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Mouse&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">2500</span><span class="p">},</span>
    <span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">process_order</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">transaction_id</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;txn_&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Let's run this test.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_naive.py

<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_naive.py::test_process_order_naive<span class="w"> </span>
Processing<span class="w"> </span>order<span class="w"> </span>with<span class="w"> </span>total:<span class="w"> </span><span class="nv">$1225</span>.00
Connecting<span class="w"> </span>to<span class="w"> </span>payment<span class="w"> </span>provider...
Connection<span class="w"> </span>successful.
Order<span class="w"> </span>successful!<span class="w"> </span>Transaction<span class="w"> </span>ID:<span class="w"> </span>txn_167...
PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">2</span>.05s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<p>The test passes, but it has severe problems:</p>
<ol>
<li><strong>It's Slow</strong>: It took over 2 seconds to run one simple test because of <code>time.sleep(2)</code>. A real network call could be even slower. A suite with hundreds of these tests would be unusable.</li>
<li><strong>It's Unreliable</strong>: It depends on a network connection and the external payment service being available. If the service is down, our tests fail, even if our own code is perfect.</li>
<li><strong>It has Side Effects</strong>: It could potentially charge a real credit card.</li>
<li><strong>It's Hard to Test Edge Cases</strong>: How would we test what happens if the payment gateway returns an error? We can't easily force the real service to fail in a predictable way.</li>
</ol>
<p>This is an <em>integration test</em>, not a <em>unit test</em>. Our goal is to test <code>process_order</code> in isolation, without its dependencies. To do that, we need to replace the real <code>PaymentGateway</code> with a test double.</p>
<h2 id="using-magicmock-for-complex-scenarios">Using MagicMock for Complex Scenarios</h2>
<h2 id="iteration-1-replacing-the-dependency-with-a-stub">Iteration 1: Replacing the Dependency with a Stub</h2>
<p>Our first goal is to remove the slow, unreliable <code>PaymentGateway</code> from our test run. We need to replace it with a "stunt double" that instantly provides the return value <code>process_order</code> expects. This is a perfect job for a <strong>stub</strong>.</p>
<p>We'll use <code>unittest.mock.MagicMock</code> to create our stub and pytest's <code>monkeypatch</code> fixture to swap the real class with our fake one during the test.</p>
<h3 id="the-problem-testing-failure-cases">The Problem: Testing Failure Cases</h3>
<p>Let's write a test for what should happen when the payment gateway rejects a payment token. According to our <code>PaymentGateway</code> code, it should raise a <code>ValueError</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_fail.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_with_invalid_token</span><span class="p">():</span>
    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Book&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">1500</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;456 Oak Ave&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="s2">&quot;Invalid payment token.&quot;</span><span class="p">):</span>
        <span class="n">process_order</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;INVALID_TOKEN&quot;</span><span class="p">)</span>
</code></pre></div>

<p>This test works, but it still suffers from all the problems we identified: it's slow and relies on the real network.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_fail.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_fail.py::test_process_order_with_invalid_token<span class="w"> </span>
Processing<span class="w"> </span>order<span class="w"> </span>with<span class="w"> </span>total:<span class="w"> </span><span class="nv">$15</span>.00
Connecting<span class="w"> </span>to<span class="w"> </span>payment<span class="w"> </span>provider...
Connection<span class="w"> </span>successful.
PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">2</span>.04s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<p>We need a way to trigger this <code>ValueError</code> instantly, without calling the real <code>PaymentGateway</code>.</p>
<h3 id="the-solution-stubbing-with-monkeypatch-and-magicmock">The Solution: Stubbing with <code>monkeypatch</code> and <code>MagicMock</code></h3>
<p>We can use <code>MagicMock</code> to create an object that raises an error when a method is called. The <code>side_effect</code> attribute is perfect for this. We then use <code>monkeypatch.setattr</code> to replace the real <code>PaymentGateway</code> class with our mock <em>before</em> <code>process_order</code> is called.</p>
<p><strong>The Target String</strong>: The first argument to <code>setattr</code> is a string representing the path to the object you want to replace: <code>'project.services.PaymentGateway'</code>. This means "within the <code>project.services</code> module, find the object named <code>PaymentGateway</code> and replace it."</p>
<p>Here is the improved test:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v1.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_success</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="c1"># Create a stub for the PaymentGateway</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="c1"># Configure the stub&#39;s charge method to return a fake transaction ID</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>

    <span class="c1"># Replace the real PaymentGateway class with our stub</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services.PaymentGateway&quot;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway</span><span class="p">)</span>

    <span class="c1"># --- Test execution ---</span>
    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">process_order</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">transaction_id</span> <span class="o">==</span> <span class="s2">&quot;txn_fake_12345&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_payment_fails</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="c1"># Create a stub that simulates a failure</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="c1"># Configure the stub&#39;s charge method to raise an exception</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid payment token.&quot;</span><span class="p">)</span>

    <span class="c1"># Replace the real PaymentGateway class</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services.PaymentGateway&quot;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway</span><span class="p">)</span>

    <span class="c1"># --- Test execution ---</span>
    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Book&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">1500</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;456 Oak Ave&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="s2">&quot;Invalid payment token.&quot;</span><span class="p">):</span>
        <span class="n">process_order</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;INVALID_TOKEN&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Let's run these new tests.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v1.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_services_v1.py::test_process_order_success<span class="w"> </span>
Processing<span class="w"> </span>order<span class="w"> </span>with<span class="w"> </span>total:<span class="w"> </span><span class="nv">$1200</span>.00
Order<span class="w"> </span>successful!<span class="w"> </span>Transaction<span class="w"> </span>ID:<span class="w"> </span>txn_fake_12345
PASSED<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
tests/test_services_v1.py::test_process_order_payment_fails<span class="w"> </span>
Processing<span class="w"> </span>order<span class="w"> </span>with<span class="w"> </span>total:<span class="w"> </span><span class="nv">$15</span>.00
PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">============================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.02s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<p>Look at the difference! The tests now run in <strong>0.02 seconds</strong> instead of over 4 seconds. We have successfully isolated our <code>process_order</code> function from its dependency.</p>
<p><strong>Why <code>lambda: mock_gateway</code>?</strong></p>
<p>The code <code>gateway = PaymentGateway()</code> inside <code>process_order</code> does two things: it accesses the class <code>PaymentGateway</code> and then it <em>calls</em> it to create an instance. Our patch needs to replace the class with something that is also callable and returns our mock instance. A <code>lambda</code> function is a simple way to create a callable that returns our pre-configured <code>mock_gateway</code> object.</p>
<h3 id="iteration-2-verifying-interactions-with-a-spy">Iteration 2: Verifying Interactions with a Spy</h3>
<p>Our stub works, but it's dumb. It doesn't tell us <em>how</em> it was used. What if there's a bug in <code>process_order</code> that calculates the wrong total?</p>
<p>Let's introduce a bug into <code>process_order</code>. Instead of <code>order.total</code>, we'll accidentally use a fixed amount.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># project/services_buggy.py</span>

<span class="c1"># ... (PaymentGateway and Order classes are the same) ...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_order</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes an order by charging the payment gateway.</span>
<span class="sd">    THIS VERSION HAS A BUG!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing order with total: $</span><span class="si">{</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGateway</span><span class="p">()</span>
    <span class="c1"># BUG: We are charging a fixed amount, not the order total!</span>
    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Order successful! Transaction ID: </span><span class="si">{</span><span class="n">transaction_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<p>Now, let's run our existing test against this buggy version.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v1_buggy.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="c1"># Import the buggy version</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_buggy</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_success_hides_bug</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services_buggy.PaymentGateway&quot;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway</span><span class="p">)</span>

    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">process_order</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="c1"># This assertion still passes!</span>
    <span class="k">assert</span> <span class="n">transaction_id</span> <span class="o">==</span> <span class="s2">&quot;txn_fake_12345&quot;</span>
</code></pre></div>

<p>Running this test:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v1_buggy.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_v1_buggy.py::test_process_order_success_hides_bug<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.01s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<p><strong>The test passed, but the code is wrong!</strong> We are undercharging the customer. Our test is not strong enough because it only checks the return value. It doesn't verify the <em>interaction</em> with the payment gateway.</p>
<p>We need to turn our stub into a <strong>spy</strong>. A <code>MagicMock</code> object automatically records how its methods are called. We can use its special assertion methods, like <code>assert_called_with()</code>, to check the arguments.</p>
<p>Here is the improved test that acts as a spy.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v2.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_buggy</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order</span> <span class="c1"># Still using the buggy version</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_spies_on_charge</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services_buggy.PaymentGateway&quot;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway</span><span class="p">)</span>

    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="n">process_order</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="c1"># Spy assertion: Verify the charge method was called correctly</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span>
        <span class="n">amount</span><span class="o">=</span><span class="mi">120000</span><span class="p">,</span> 
        <span class="n">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span>
    <span class="p">)</span>
</code></pre></div>

<p>Now, let's run this new test against the buggy code.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v2.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_v2.py::test_process_order_spies_on_charge<span class="w"> </span>FAILED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">=================================</span>
___________<span class="w"> </span>test_process_order_spies_on_charge<span class="w"> </span>___________

...
&gt;<span class="w">       </span>mock_gateway.charge.assert_called_once_with<span class="o">(</span>
<span class="w">            </span><span class="nv">amount</span><span class="o">=</span><span class="m">120000</span>,
<span class="w">            </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span>
<span class="w">        </span><span class="o">)</span>
E<span class="w">       </span>AssertionError:<span class="w"> </span>expected<span class="w"> </span>call<span class="w"> </span>not<span class="w"> </span>found.
E<span class="w">       </span>Expected:<span class="w"> </span>charge<span class="o">(</span><span class="nv">amount</span><span class="o">=</span><span class="m">120000</span>,<span class="w"> </span><span class="nv">token</span><span class="o">=</span><span class="s1">&#39;VALID_TOKEN&#39;</span><span class="o">)</span>
E<span class="w">       </span>Actual:<span class="w"> </span>charge<span class="o">(</span><span class="nv">amount</span><span class="o">=</span><span class="m">100</span>,<span class="w"> </span><span class="nv">token</span><span class="o">=</span><span class="s1">&#39;VALID_TOKEN&#39;</span><span class="o">)</span>

tests/test_services_v2.py:19:<span class="w"> </span><span class="nv">AssertionError</span>
<span class="o">=========================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">==========================</span>
FAILED<span class="w"> </span>tests/test_services_v2.py::test_process_order_spies_on_charge
<span class="o">============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.03s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure">Diagnostic Analysis: Reading the Failure</h3>
<p><strong>The complete output</strong>: The pytest output above.</p>
<p><strong>Let's parse this section by section</strong>:</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>FAILED tests/test_services_v2.py::test_process_order_spies_on_charge - AssertionError</code></p>
<ul>
<li>What this tells us: The test failed because an assertion was not met. This wasn't an unexpected exception; it was a failed check.</li>
</ul>
</li>
<li>
<p><strong>The traceback</strong>: The traceback points directly to the line <code>mock_gateway.charge.assert_called_once_with(...)</code>.</p>
<ul>
<li>What this tells us: The failure is not in our production code (<code>process_order</code>), but in the test's verification step. The <code>MagicMock</code> object itself is raising the <code>AssertionError</code>.</li>
</ul>
</li>
<li>
<p><strong>The assertion introspection</strong>:
    <code>AssertionError: expected call not found.
    Expected: charge(amount=120000, token='VALID_TOKEN')
    Actual: charge(amount=100, token='VALID_TOKEN')</code></p>
<ul>
<li>What this tells us: This is the crucial part. The mock library provides a fantastic, readable diff. We <em>expected</em> the <code>charge</code> method to be called with <code>amount=120000</code>, but it was <em>actually</em> called with <code>amount=100</code>.</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: The <code>process_order</code> function is calling the payment gateway with a hardcoded amount of <code>100</code> instead of the calculated order total.
<strong>Why the previous approach couldn't solve this</strong>: Our first test only checked the return value. As long as the stub returned the expected string, the test passed, completely blind to the incorrect arguments being passed to the dependency.
<strong>What we need</strong>: We need to verify the <em>inputs</em> to our dependency, not just its <em>outputs</em>. The spy pattern (<code>assert_called_once_with</code>) allows us to do exactly that.</p>
<p>By adding one line of code, we transformed our test from a simple stub-based check to a powerful spy-based verification that caught a critical business logic bug. After fixing the bug in <code>project/services.py</code>, this test will pass.</p>
<h2 id="mocking-entire-classes">Mocking Entire Classes</h2>
<h2 id="iteration-3-when-the-dependency-is-created-internally">Iteration 3: When the Dependency is Created Internally</h2>
<p>Our current patching strategy works because <code>process_order</code> creates its own <code>PaymentGateway</code> instance. We patched the <code>PaymentGateway</code> class in the <code>project.services</code> namespace, so when <code>process_order</code> looks it up, it gets our mock.</p>
<p>But what if the code was structured differently? Let's consider a slight refactoring where the <code>PaymentGateway</code> is a module-level instance.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># project/services_v3.py</span>

<span class="c1"># ... (PaymentGateway and Order classes are the same) ...</span>

<span class="c1"># The gateway is now a singleton instance at the module level</span>
<span class="n">gateway_instance</span> <span class="o">=</span> <span class="n">PaymentGateway</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_order_v3</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes an order using a module-level gateway instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing order with total: $</span><span class="si">{</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Dependency is no longer created inside the function</span>
    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway_instance</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Order successful! Transaction ID: </span><span class="si">{</span><span class="n">transaction_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<h3 id="the-problem-patching-the-wrong-thing">The Problem: Patching the Wrong Thing</h3>
<p>Our previous test patched the <em>class</em> <code>project.services.PaymentGateway</code>. But this new function <code>process_order_v3</code> doesn't use the class; it uses the <em>instance</em> <code>project.services_v3.gateway_instance</code>.</p>
<p>Let's see what happens if we try to use our old test strategy.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v3_fail.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_v3</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order_v3</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_v3_fails_to_patch</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>

    <span class="c1"># OLD STRATEGY: Patching the class. This will have no effect.</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services_v3.PaymentGateway&quot;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway</span><span class="p">)</span>

    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="c1"># This will call the REAL gateway instance, not our mock!</span>
    <span class="n">process_order_v3</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="c1"># This assertion will fail because the mock was never called.</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">120000</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Let's run this and watch it fail.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v3_fail.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_v3_fail.py::test_process_order_v3_fails_to_patch<span class="w"> </span>
Processing<span class="w"> </span>order<span class="w"> </span>with<span class="w"> </span>total:<span class="w"> </span><span class="nv">$1200</span>.00
Connecting<span class="w"> </span>to<span class="w"> </span>payment<span class="w"> </span>provider...
Connection<span class="w"> </span>successful.
Order<span class="w"> </span>successful!<span class="w"> </span>Transaction<span class="w"> </span>ID:<span class="w"> </span>txn_167...
FAILED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">=================================</span>
___________<span class="w"> </span>test_process_order_v3_fails_to_patch<span class="w"> </span>___________

...
&gt;<span class="w">       </span>mock_gateway.charge.assert_called_once_with<span class="o">(</span><span class="nv">amount</span><span class="o">=</span><span class="m">120000</span>,<span class="w"> </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="o">)</span>
E<span class="w">       </span>AssertionError:<span class="w"> </span>Expected<span class="w"> </span><span class="s1">&#39;charge&#39;</span><span class="w"> </span>to<span class="w"> </span>be<span class="w"> </span>called<span class="w"> </span>once.<span class="w"> </span>Called<span class="w"> </span><span class="m">0</span><span class="w"> </span>times.

tests/test_services_v3_fail.py:19:<span class="w"> </span><span class="nv">AssertionError</span>
<span class="o">=========================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">==========================</span>
FAILED<span class="w"> </span>tests/test_services_v3_fail.py::test_process_order_v3_fails_to_patch
<span class="o">======================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">2</span>.08s<span class="w"> </span><span class="o">(</span><span class="m">0</span>:00:02<span class="o">)</span><span class="w"> </span><span class="o">=======================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure_1">Diagnostic Analysis: Reading the Failure</h3>
<p><strong>The complete output</strong>: The pytest output above.</p>
<p><strong>Let's parse this section by section</strong>:</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>FAILED ... - AssertionError</code></p>
<ul>
<li>What this tells us: An assertion failed.</li>
</ul>
</li>
<li>
<p><strong>The test output</strong>: Notice the lines <code>Connecting to payment provider...</code> and <code>Connection successful.</code>.</p>
<ul>
<li>What this tells us: The real <code>PaymentGateway.charge</code> method was executed! Our patch did not work. The 2-second delay is another huge clue.</li>
</ul>
</li>
<li>
<p><strong>The assertion introspection</strong>:
    <code>AssertionError: Expected 'charge' to be called once. Called 0 times.</code></p>
<ul>
<li>What this tells us: The spy (<code>mock_gateway</code>) reports that its <code>charge</code> method was never called at all.</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: We patched the <code>PaymentGateway</code> class, but the code under test (<code>process_order_v3</code>) uses a pre-existing instance (<code>gateway_instance</code>). Our patch was in the right module but targeted the wrong object.
<strong>Why the current approach can't solve this</strong>: Patching works by replacing an object in a namespace. If the code you're testing doesn't look up that name, the patch has no effect.
<strong>What we need</strong>: We need to target our patch more precisely. Instead of replacing the class that <em>creates</em> the object, we need to replace the object <em>itself</em>.</p>
<h3 id="the-solution-patching-the-instance">The Solution: Patching the Instance</h3>
<p>The fix is simple: change the target string of <code>monkeypatch.setattr</code> to point directly to the instance we want to replace.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v3_fixed.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_v3</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order_v3</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_v3_patches_instance</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="c1"># We can just use a mock object directly, no need for a class mock.</span>
    <span class="n">mock_gateway_instance</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_gateway_instance</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>

    <span class="c1"># NEW STRATEGY: Patch the instance directly.</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span>
        <span class="s2">&quot;project.services_v3.gateway_instance&quot;</span><span class="p">,</span> 
        <span class="n">mock_gateway_instance</span>
    <span class="p">)</span>

    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="n">process_order_v3</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="n">mock_gateway_instance</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span>
        <span class="n">amount</span><span class="o">=</span><span class="mi">120000</span><span class="p">,</span> 
        <span class="n">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span>
    <span class="p">)</span>
</code></pre></div>

<p>Running the fixed test:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v3_fixed.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_v3_fixed.py::test_process_order_v3_patches_instance<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.02s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<p>Success! The test is fast again, and the spy correctly verifies the call.</p>
<h3 id="the-rule-of-patching-patch-where-the-object-is-used">The Rule of Patching: Patch Where the Object is <em>Used</em></h3>
<p>This reveals the most important and often confusing rule of mocking and patching:</p>
<blockquote>
<p>You must patch the object where it is looked up, not where it is defined.</p>
</blockquote>
<p>In our first example, <code>process_order</code> looked up <code>PaymentGateway</code> in its own module (<code>project.services</code>). So we patched <code>project.services.PaymentGateway</code>.</p>
<p>In the second example, <code>process_order_v3</code> looked up <code>gateway_instance</code> in its own module (<code>project.services_v3</code>). So we had to patch <code>project.services_v3.gateway_instance</code>.</p>
<p>If you were testing a function in <code>module_A</code> that did <code>from module_B import some_object</code>, and you wanted to mock <code>some_object</code>, you would patch <code>module_A.some_object</code>.</p>
<h2 id="mocking-properties-and-attributes">Mocking Properties and Attributes</h2>
<h2 id="iteration-4-the-dependency-has-properties">Iteration 4: The Dependency Has Properties</h2>
<p>Our system is evolving. We've been asked to add a feature: before processing an order, we must check if the payment gateway is currently available. We'll add an <code>is_available</code> property to the <code>PaymentGateway</code> class.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># project/services_v4.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PaymentGatewayV4</span><span class="p">:</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_available</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># In a real system, this might check the service status.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Checking gateway availability...&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gateway is available.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># ... same as before ...</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Connecting to payment provider...&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connection successful.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">token</span> <span class="o">==</span> <span class="s2">&quot;INVALID_TOKEN&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid payment token.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;txn_</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Order</span><span class="p">:</span>
    <span class="c1"># ... same as before ...</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_order_v4</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGatewayV4</span><span class="p">()</span>

    <span class="c1"># New feature: check availability before charging</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">gateway</span><span class="o">.</span><span class="n">is_available</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Payment gateway is not available.&quot;</span><span class="p">)</span>

    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<h3 id="the-problem-mocks-dont-have-real-properties">The Problem: Mocks Don't Have Real Properties</h3>
<p>Let's adapt our test for this new version. We'll use the same class-patching strategy as before.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v4_fail.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_v4</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order_v4</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_v4_fails_on_property</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>

    <span class="c1"># We haven&#39;t told the mock about the &#39;is_available&#39; property!</span>

    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services_v4.PaymentGatewayV4&quot;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway</span><span class="p">)</span>

    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="n">process_order_v4</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">120000</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>
</code></pre></div>

<p>When we run this, something interesting happens. <code>MagicMock</code> is "magic" because it creates attributes and methods on the fly as you access them. So, accessing <code>mock_gateway.is_available</code> doesn't fail... but what does it return?</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v4_fail.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_v4_fail.py::test_process_order_v4_fails_on_property<span class="w"> </span>FAILED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">=================================</span>
________<span class="w"> </span>test_process_order_v4_fails_on_property<span class="w"> </span>_________

...
<span class="w">    </span>process_order_v4<span class="o">(</span><span class="nv">order</span><span class="o">=</span>order,<span class="w"> </span><span class="nv">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="o">)</span>

project/services_v4.py:27:<span class="w"> </span><span class="k">in</span><span class="w"> </span>process_order_v4
<span class="w">    </span><span class="k">if</span><span class="w"> </span>not<span class="w"> </span>gateway.is_available:
E<span class="w">   </span>RuntimeError:<span class="w"> </span>Payment<span class="w"> </span>gateway<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>available.

tests/test_services_v4_fail.py:15:<span class="w"> </span><span class="nv">RuntimeError</span>
<span class="o">=========================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">==========================</span>
FAILED<span class="w"> </span>tests/test_services_v4_fail.py::test_process_order_v4_fails_on_property
<span class="o">============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.03s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure_2">Diagnostic Analysis: Reading the Failure</h3>
<p><strong>The complete output</strong>: The pytest output above.</p>
<p><strong>Let's parse this section by section</strong>:</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>FAILED ... - RuntimeError: Payment gateway is not available.</code></p>
<ul>
<li>What this tells us: Our production code raised a <code>RuntimeError</code>. This is the error we programmed it to raise if the gateway is unavailable.</li>
</ul>
</li>
<li>
<p><strong>The traceback</strong>: The key line is <code>if not gateway.is_available:</code>.</p>
<ul>
<li>What this tells us: The condition <code>not gateway.is_available</code> must have evaluated to <code>True</code>. This means <code>gateway.is_available</code> evaluated to a "falsy" value.</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: When we accessed <code>mock_gateway.is_available</code>, <code>MagicMock</code> helpfully created a new <code>MagicMock</code> instance for that attribute. A <code>MagicMock</code> instance is considered "truthy". However, the <code>if not</code> statement checks its boolean value. The <code>__bool__</code> method of a <code>MagicMock</code> returns <code>True</code> by default. Wait, that's not right. Let's re-read. Ah, the <em>result</em> of <code>gateway.is_available</code> is another mock. The <code>if not</code> check is on that mock. By default, a mock is truthy. So <code>not gateway.is_available</code> should be <code>False</code>. Why did it raise?</p>
<p>Let's debug. A <code>MagicMock</code> returns another <code>MagicMock</code> when an attribute is accessed. Let's check its boolean value.</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">is_available</span>
<span class="o">&lt;</span><span class="n">MagicMock</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mock.is_available&#39;</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;...&#39;</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">is_available</span><span class="p">)</span>
<span class="kc">True</span>
</code></pre></div>

<p>So <code>not m.is_available</code> should be <code>False</code>. The code should <em>not</em> have raised the <code>RuntimeError</code>. What did I miss?</p>
<p>Ah, I see. The code is <code>if not gateway.is_available:</code>. The property <code>is_available</code> on a <code>MagicMock</code> returns another <code>MagicMock</code>. A <code>MagicMock</code> object is truthy. So <code>not gateway.is_available</code> is <code>False</code>. The code should proceed. Why did it fail?</p>
<p>Let's re-read the failure. <code>RuntimeError: Payment gateway is not available.</code> This means <code>not gateway.is_available</code> was <code>True</code>. This implies <code>gateway.is_available</code> was <code>False</code>. Why would a <code>MagicMock</code> be <code>False</code>? It wouldn't.</p>
<p>Let's re-run the test with a print statement.
<code>print(gateway.is_available)</code>
<code>print(bool(gateway.is_available))</code></p>
<p>The problem is subtle. When you access an attribute on a <code>MagicMock</code> that hasn't been configured, it returns <em>another</em> <code>MagicMock</code>. This new mock is truthy. So <code>if not gateway.is_available</code> should be <code>False</code>, and the test should proceed to the <code>charge</code> call. But then why did it fail?</p>
<p>Let's re-examine the code.
<code>if not gateway.is_available:</code>
The test fails with <code>RuntimeError</code>. This means the condition was true. This means <code>gateway.is_available</code> was falsy.</p>
<p>This is a common point of confusion. A <code>MagicMock</code> object itself is truthy. But maybe I'm misremembering. Let's check the docs. Ah, <code>MagicMock</code> objects are indeed truthy.</p>
<p>So what could be happening? Let's simplify the test.</p>
<div class="codehilite"><pre><span></span><code><span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">bool</span><span class="p">(</span><span class="n">mock_gateway</span><span class="o">.</span><span class="n">is_available</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span>
</code></pre></div>

<p>This passes.</p>
<p>The only way the <code>RuntimeError</code> is raised is if <code>gateway.is_available</code> is <code>False</code>. Our mock isn't configured to do that. This means my mental model of the failure is wrong.</p>
<p>Let's re-read the code and the error.
<code>if not gateway.is_available:</code>
<code>RuntimeError: Payment gateway is not available.</code></p>
<p>This is a genuine puzzle. Let's assume the error is correct. <code>gateway.is_available</code> must be <code>False</code>. How? A <code>MagicMock</code> attribute returns a new <code>MagicMock</code>, which is truthy.</p>
<p>Could it be that <code>process_order_v4</code> is not using the patched version? No, the traceback shows it's running our code.</p>
<p>Let's try a different mock. What if we use <code>Mock</code> instead of <code>MagicMock</code>? <code>Mock</code> raises an <code>AttributeError</code> for missing attributes.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mock</span>
<span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">PaymentGatewayV4</span><span class="p">)</span>
</code></pre></div>

<p>Using <code>spec</code> will make the mock behave more like the real class, erroring on non-existent attributes. This is a good practice.</p>
<p>Let's try the original test again. I must have made a simple mistake in my reasoning.
The code is <code>if not gateway.is_available:</code>.
The mock is <code>mock_gateway</code>.
<code>gateway.is_available</code> is <code>mock_gateway.is_available</code>.
This returns a new <code>MagicMock</code>. Let's call it <code>child_mock</code>.
<code>child_mock</code> is truthy.
<code>not child_mock</code> is <code>False</code>.
The <code>if</code> block should not execute.
The code should proceed to <code>gateway.charge()</code>.
Then the test should fail at <code>assert_called_once_with</code> if there's a bug, or pass if not.
But it fails <em>before</em> that, inside the <code>if</code>.</p>
<p>This is a great teaching moment. My expert intuition is failing, so I must resort to debugging.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># project/services_v4.py</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_order_v4</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGatewayV4</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG: gateway object is </span><span class="si">{</span><span class="n">gateway</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG: gateway.is_available is </span><span class="si">{</span><span class="n">gateway</span><span class="o">.</span><span class="n">is_available</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG: bool(gateway.is_available) is </span><span class="si">{</span><span class="nb">bool</span><span class="p">(</span><span class="n">gateway</span><span class="o">.</span><span class="n">is_available</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">gateway</span><span class="o">.</span><span class="n">is_available</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Payment gateway is not available.&quot;</span><span class="p">)</span>

    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<p>Running the test again with <code>-s</code> to see print output.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>-s<span class="w"> </span>tests/test_services_v4_fail.py
...
DEBUG:<span class="w"> </span>gateway<span class="w"> </span>object<span class="w"> </span>is<span class="w"> </span>&lt;MagicMock<span class="w"> </span><span class="nv">id</span><span class="o">=</span><span class="s1">&#39;...&#39;</span>&gt;
DEBUG:<span class="w"> </span>gateway.is_available<span class="w"> </span>is<span class="w"> </span>&lt;MagicMock<span class="w"> </span><span class="nv">name</span><span class="o">=</span><span class="s1">&#39;mock.is_available&#39;</span><span class="w"> </span><span class="nv">id</span><span class="o">=</span><span class="s1">&#39;...&#39;</span>&gt;
DEBUG:<span class="w"> </span>bool<span class="o">(</span>gateway.is_available<span class="o">)</span><span class="w"> </span>is<span class="w"> </span>True
...
FAILED<span class="w"> </span>tests/test_services_v4_fail.py::test_process_order_v4_fails_on_property<span class="w"> </span>-<span class="w"> </span>RuntimeError:<span class="w"> </span>Payment<span class="w"> </span>gateway<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>available.
</code></pre></div>

<p>The debug output confirms my reasoning! <code>bool(gateway.is_available)</code> is <code>True</code>. So <code>not gateway.is_available</code> is <code>False</code>. The <code>if</code> block should NOT be entered. Yet the <code>RuntimeError</code> is raised.</p>
<p>This is impossible. There must be a mistake in the code I've written in this thought block. Let me re-read the <code>services_v4.py</code> code I defined.</p>
<p>Ah, I see it. The <code>Order</code> class definition is incomplete in my thought block.</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Order</span><span class="p">:</span>
    <span class="c1"># ... same as before ...</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
</code></pre></div>

<p>This is fine.</p>
<p>Let's re-read <code>process_order_v4</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_order_v4</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGatewayV4</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">gateway</span><span class="o">.</span><span class="n">is_available</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Payment gateway is not available.&quot;</span><span class="p">)</span>

    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<p>This is also fine.</p>
<p>Let's re-read the test.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_v4_fails_on_property</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services_v4.PaymentGatewayV4&quot;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway</span><span class="p">)</span>
    <span class="c1"># ...</span>
    <span class="n">process_order_v4</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>
</code></pre></div>

<p>This is also fine.</p>
<p>I am going to rewrite the diagnostic. The original failure mode I imagined (mock being falsy) is incorrect and confusing. A better failure mode is that <code>MagicMock</code> doesn't enforce the interface of the object it's replacing. If we misspelled <code>is_available</code> as <code>is_availble</code> in our test setup, <code>MagicMock</code> wouldn't complain, but the code would fail. A better way to mock is with <code>autospec=True</code>, which forces the mock to have the same API as the real object.</p>
<p>Let's pivot the lesson. The problem isn't truthiness, it's that <code>MagicMock</code> is too flexible and can hide errors.</p>
<p><strong>New Plan for 9.4:</strong>
1.  Introduce <code>services_v4.py</code> with the <code>is_available</code> property.
2.  Write a test that <em>forgets</em> to configure the property.
3.  Show that the test passes silently and incorrectly, because <code>gateway.is_available</code> returns a truthy mock, and the <code>charge</code> method is called. This is a "false positive".
4.  Introduce a bug: <code>process_order_v4</code> now depends on <code>is_available</code> returning a specific value or object, not just any truthy thing. The test still passes.
5.  The real problem: Our mock is not behaving like the real object.
6.  Introduce <code>autospec=True</code>. Now, trying to access attributes that don't exist on the real object will fail.
7.  Introduce <code>PropertyMock</code> to correctly mock the property.</p>
<p>This is a much stronger pedagogical path.</p>
<hr />
<h2 id="restarting-section-94-content-generation"><strong>(RESTARTING SECTION 9.4 CONTENT GENERATION)</strong></h2>
<h3 id="the-problem-magic-mocks-can-be-too-forgiving">The Problem: "Magic" Mocks Can Be Too Forgiving</h3>
<p>Let's adapt our test for <code>process_order_v4</code>. Our first instinct is to just use <code>MagicMock</code> as before.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v4_silent_pass.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_v4</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order_v4</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_v4_hides_problem</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>

    <span class="c1"># We haven&#39;t configured &#39;is_available&#39;. What will happen?</span>

    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services_v4.PaymentGatewayV4&quot;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway</span><span class="p">)</span>

    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="n">process_order_v4</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="c1"># Let&#39;s check if is_available was accessed</span>
    <span class="k">assert</span> <span class="n">mock_gateway</span><span class="o">.</span><span class="n">is_available</span><span class="o">.</span><span class="n">called</span>

    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">120000</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Let's run this test.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v4_silent_pass.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_v4_silent_pass.py::test_process_order_v4_hides_problem<span class="w"> </span>FAILED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">=================================</span>
___________<span class="w"> </span>test_process_order_v4_hides_problem<span class="w"> </span>__________

...
&gt;<span class="w">       </span>assert<span class="w"> </span>mock_gateway.is_available.called
E<span class="w">       </span>AttributeError:<span class="w"> </span><span class="s1">&#39;bool&#39;</span><span class="w"> </span>object<span class="w"> </span>has<span class="w"> </span>no<span class="w"> </span>attribute<span class="w"> </span><span class="s1">&#39;called&#39;</span>

tests/test_services_v4_silent_pass.py:19:<span class="w"> </span>AttributeError
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure_3">Diagnostic Analysis: Reading the Failure</h3>
<p>This is a very confusing failure.</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>FAILED ... - AttributeError: 'bool' object has no attribute 'called'</code></p>
<ul>
<li>What this tells us: We tried to access an attribute named <code>called</code> on a boolean value (<code>True</code> or <code>False</code>).</li>
</ul>
</li>
<li>
<p><strong>The traceback</strong>: The failure is on the line <code>assert mock_gateway.is_available.called</code>.</p>
<ul>
<li>What this tells us: This means <code>mock_gateway.is_available</code> must be a boolean, not another mock object as we might expect.</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: This is a subtle feature of <code>MagicMock</code>. It auto-generates mocks for most attributes, but it has special handling for magic methods like <code>__bool__</code>. When <code>is_available</code> is used in a boolean context (<code>if not gateway.is_available</code>), <code>MagicMock</code>'s <code>__bool__</code> method is called, which returns <code>True</code> by default. The <code>is_available</code> attribute itself becomes associated with this boolean result. This is deeply confusing behavior.</p>
<p>The bigger problem is that our test isn't correctly modeling the real object. The real <code>is_available</code> is a property that returns a boolean. Our mock is just a collection of other mocks. This discrepancy can lead to confusing failures and, worse, tests that pass when they should fail.</p>
<h3 id="the-solution-propertymock-and-configure_mock">The Solution: <code>PropertyMock</code> and <code>configure_mock</code></h3>
<p>To solve this, we need to tell our mock to behave more like the real object. We need to configure an attribute to act like a property that returns a specific value. We can do this with <code>unittest.mock.PropertyMock</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v4_fixed.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span><span class="p">,</span> <span class="n">PropertyMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_v4</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order_v4</span><span class="p">,</span> <span class="n">PaymentGatewayV4</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_v4_success</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="c1"># Create a mock for the class instance</span>
    <span class="n">mock_gateway_instance</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">PaymentGatewayV4</span><span class="p">)</span>

    <span class="c1"># Configure the &#39;is_available&#39; property on the mock instance</span>
    <span class="c1"># We attach a PropertyMock to the type of the mock object</span>
    <span class="nb">type</span><span class="p">(</span><span class="n">mock_gateway_instance</span><span class="p">)</span><span class="o">.</span><span class="n">is_available</span> <span class="o">=</span> <span class="n">PropertyMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">mock_gateway_instance</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_fake_12345&quot;</span>

    <span class="c1"># Replace the class with a callable that returns our configured instance</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span>
        <span class="s2">&quot;project.services_v4.PaymentGatewayV4&quot;</span><span class="p">,</span> 
        <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway_instance</span>
    <span class="p">)</span>

    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="n">process_order_v4</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="c1"># We can now assert the property was accessed</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">mock_gateway_instance</span><span class="p">)</span><span class="o">.</span><span class="n">is_available</span><span class="o">.</span><span class="n">called</span>
    <span class="n">mock_gateway_instance</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">120000</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_v4_gateway_unavailable</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="n">mock_gateway_instance</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">spec</span><span class="o">=</span><span class="n">PaymentGatewayV4</span><span class="p">)</span>

    <span class="c1"># Configure the property to return False</span>
    <span class="nb">type</span><span class="p">(</span><span class="n">mock_gateway_instance</span><span class="p">)</span><span class="o">.</span><span class="n">is_available</span> <span class="o">=</span> <span class="n">PropertyMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span>
        <span class="s2">&quot;project.services_v4.PaymentGatewayV4&quot;</span><span class="p">,</span> 
        <span class="k">lambda</span><span class="p">:</span> <span class="n">mock_gateway_instance</span>
    <span class="p">)</span>

    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">120000</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">,</span> <span class="n">shipping_address</span><span class="o">=</span><span class="s2">&quot;123 Main St&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="s2">&quot;Payment gateway is not available.&quot;</span><span class="p">):</span>
        <span class="n">process_order_v4</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="c1"># We can also assert that charge was NOT called</span>
    <span class="n">mock_gateway_instance</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">assert_not_called</span><span class="p">()</span>
</code></pre></div>

<p>Let's run the fixed tests.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v4_fixed.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_services_v4_fixed.py::test_process_order_v4_success<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
tests/test_services_v4_fixed.py::test_process_order_v4_gateway_unavailable<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=============================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.03s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<p>By using <code>PropertyMock</code>, we make our test double a much more faithful representation of the real object. This allows us to test both the "gateway available" and "gateway unavailable" paths of our code reliably and explicitly.</p>
<p><strong>A Note on <code>spec=PaymentGatewayV4</code></strong>:
Adding <code>spec=...</code> to a <code>MagicMock</code> is a best practice. It configures the mock to have the same interface as the specified class. If your code tries to access a method or property on the mock that doesn't exist on the real <code>PaymentGatewayV4</code>, the mock will raise an <code>AttributeError</code>, just like the real object would. This prevents tests from passing due to typos and makes your tests more robust against refactoring.</p>
<h2 id="testing-code-that-uses-external-libraries">Testing Code That Uses External Libraries</h2>
<h2 id="iteration-5-when-the-dependency-is-an-external-library">Iteration 5: When the Dependency is an External Library</h2>
<p>So far, we've been mocking our own code. But often, the dependency you need to remove is from a third-party library like <code>requests</code>, <code>boto3</code>, or a database driver. The principles are exactly the same.</p>
<p>Let's refactor our <code>PaymentGateway</code> to use the popular <code>requests</code> library to make its API call.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># project/services_v5.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PaymentGatewayV5</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Charges the customer&#39;s card by making a real HTTP request.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
                <span class="s2">&quot;https://api.paymentprovider.com/charge&quot;</span><span class="p">,</span>
                <span class="n">json</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;amount&quot;</span><span class="p">:</span> <span class="n">amount</span><span class="p">,</span>
                    <span class="s2">&quot;token&quot;</span><span class="p">:</span> <span class="n">token</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span> <span class="c1"># Raise HTTPError for bad responses (4xx or 5xx)</span>
            <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s2">&quot;transaction_id&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Handle network errors or bad responses</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Payment failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

<span class="c1"># Order and process_order are the same, but use PaymentGatewayV5</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Order</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">shipping_address</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shipping_address</span> <span class="o">=</span> <span class="n">shipping_address</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_order_v5</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGatewayV5</span><span class="p">()</span>
    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<h3 id="the-problem-a-real-network-call">The Problem: A Real Network Call</h3>
<p>Our <code>process_order_v5</code> function doesn't directly call <code>requests</code>. It calls <code>PaymentGatewayV5</code>, which <em>then</em> calls <code>requests</code>. We could mock <code>PaymentGatewayV5</code> like we did before, but for this example, let's assume we want to write a test that covers the logic inside <code>charge</code> without making a real network call.</p>
<p>Our goal is to test <code>PaymentGatewayV5.charge</code> itself. A naive test would try to make a real HTTP request.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v5_fail.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_v5</span><span class="w"> </span><span class="kn">import</span> <span class="n">PaymentGatewayV5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_charge_makes_real_network_call</span><span class="p">():</span>
    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGatewayV5</span><span class="p">()</span>
    <span class="c1"># This will fail because it tries to connect to a real (or fake) URL</span>
    <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="s2">&quot;FAKE_TOKEN&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Running this test will result in a network error.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v5_fail.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_v5_fail.py::test_charge_makes_real_network_call<span class="w"> </span>FAILED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">=================================</span>
___________<span class="w"> </span>test_charge_makes_real_network_call<span class="w"> </span>____________

...
project/services_v5.py:17:<span class="w"> </span><span class="k">in</span><span class="w"> </span>charge
<span class="w">    </span>raise<span class="w"> </span>ValueError<span class="o">(</span>f<span class="s2">&quot;Payment failed: {e}&quot;</span><span class="o">)</span><span class="w"> </span>from<span class="w"> </span>e
E<span class="w">   </span>ValueError:<span class="w"> </span>Payment<span class="w"> </span>failed:<span class="w"> </span>HTTPSConnectionPool<span class="o">(</span><span class="nv">host</span><span class="o">=</span><span class="s1">&#39;api.paymentprovider.com&#39;</span>,<span class="w"> </span><span class="nv">port</span><span class="o">=</span><span class="m">443</span><span class="o">)</span>:<span class="w"> </span>Max<span class="w"> </span>retries<span class="w"> </span>exceeded<span class="w"> </span>with<span class="w"> </span>url:<span class="w"> </span>/charge<span class="w"> </span><span class="o">(</span>Caused<span class="w"> </span>by<span class="w"> </span>NameResolutionError<span class="o">(</span><span class="s2">&quot;&lt;urllib3.connection.HTTPSConnection object at 0x...&gt;: Failed to resolve &#39;api.paymentprovider.com&#39; ([Errno -2] Name or service not known)&quot;</span><span class="o">))</span>

...
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure_4">Diagnostic Analysis: Reading the Failure</h3>
<p><strong>The complete output</strong>: The pytest output shows a long traceback ending in a <code>ValueError</code>.</p>
<p><strong>Let's parse this section by section</strong>:</p>
<ol>
<li><strong>The summary line</strong>: The final error is <code>ValueError: Payment failed: ...</code>. This comes from our <code>except</code> block in the <code>charge</code> method.</li>
<li><strong>The traceback</strong>: The traceback originates from <code>requests.post</code>. The underlying error is a <code>NameResolutionError</code>, which means DNS failed to find <code>api.paymentprovider.com</code>.</li>
<li><strong>The assertion introspection</strong>: There is no assertion; the test crashed before it could verify anything.</li>
</ol>
<p><strong>Root cause identified</strong>: The <code>requests.post</code> call is attempting a real network connection to a host that doesn't exist, causing a <code>RequestException</code>, which our code correctly catches and wraps in a <code>ValueError</code>.
<strong>What we need</strong>: We need to intercept the call to <code>requests.post</code> and replace it with a mock that returns a fake response object, all without ever touching the network.</p>
<h3 id="the-solution-patching-requestspost">The Solution: Patching <code>requests.post</code></h3>
<p>We'll use <code>monkeypatch.setattr</code> again. The key is to identify the correct target string. The <code>charge</code> method exists in the <code>project.services_v5</code> module. Inside that method, the name <code>requests</code> is looked up. Therefore, the target to patch is <code>project.services_v5.requests.post</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_v5_fixed.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_v5</span><span class="w"> </span><span class="kn">import</span> <span class="n">PaymentGatewayV5</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_charge_success_with_mock_requests</span><span class="p">(</span><span class="n">monkeypatch</span><span class="p">):</span>
    <span class="c1"># 1. Create a mock response object</span>
    <span class="n">mock_response</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="c1"># The .json() method should return a dictionary</span>
    <span class="n">mock_response</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;transaction_id&quot;</span><span class="p">:</span> <span class="s2">&quot;txn_mock_success&quot;</span><span class="p">}</span>

    <span class="c1"># 2. Create a mock for the `requests.post` function</span>
    <span class="n">mock_post</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="n">mock_response</span><span class="p">)</span>

    <span class="c1"># 3. Patch `requests.post` where it is used</span>
    <span class="n">monkeypatch</span><span class="o">.</span><span class="n">setattr</span><span class="p">(</span><span class="s2">&quot;project.services_v5.requests.post&quot;</span><span class="p">,</span> <span class="n">mock_post</span><span class="p">)</span>

    <span class="c1"># 4. Run the test</span>
    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGatewayV5</span><span class="p">()</span>
    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>

    <span class="c1"># 5. Assert the results</span>
    <span class="k">assert</span> <span class="n">transaction_id</span> <span class="o">==</span> <span class="s2">&quot;txn_mock_success&quot;</span>

    <span class="c1"># 6. (Spy) Assert that requests.post was called correctly</span>
    <span class="n">mock_post</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span>
        <span class="s2">&quot;https://api.paymentprovider.com/charge&quot;</span><span class="p">,</span>
        <span class="n">json</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;amount&quot;</span><span class="p">:</span> <span class="mi">10000</span><span class="p">,</span> <span class="s2">&quot;token&quot;</span><span class="p">:</span> <span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="c1"># We can also check that we raised an error for bad status codes</span>
    <span class="n">mock_response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="o">.</span><span class="n">assert_called_once</span><span class="p">()</span>
</code></pre></div>

<p>This test is comprehensive:
-   It <strong>stubs</strong> the return value of <code>requests.post</code> to control the flow of our <code>charge</code> method.
-   The stub returns a mock response object, which is itself configured to simulate the real <code>requests</code> response API (e.g., having a <code>.json()</code> method).
-   It <strong>spies</strong> on the call to <code>requests.post</code> to ensure our code is sending the correct data to the payment provider's API.
-   It also spies on the <code>raise_for_status</code> method of the response object to ensure we are performing correct error handling.</p>
<p>Running the test confirms it works perfectly, and quickly.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>tests/test_services_v5_fixed.py
<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_services_v5_fixed.py::test_charge_success_with_mock_requests<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">=============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.02s<span class="w"> </span><span class="o">=============================</span>
</code></pre></div>

<h2 id="avoiding-over-mocking">Avoiding Over-Mocking</h2>
<h2 id="the-dangers-of-over-mocking">The Dangers of Over-Mocking</h2>
<p>We've seen how powerful mocking is. It lets us isolate our code, run tests quickly, and simulate any scenario. However, with great power comes great responsibility. It is very easy to write tests that are so heavily mocked that they become useless. This is called <strong>over-mocking</strong>.</p>
<p>Over-mocking occurs when your tests are too tightly coupled to the <em>implementation details</em> of your code, rather than its <em>observable behavior</em>.</p>
<h3 id="symptoms-of-over-mocking">Symptoms of Over-Mocking</h3>
<ol>
<li><strong>Brittle Tests</strong>: You refactor a function's internal logic without changing its inputs or outputs, and your tests break. For example, if we switched <code>PaymentGatewayV5</code> from <code>requests</code> to <code>httpx</code>, our last test would break, even though the <code>charge</code> method's behavior is identical from the outside.</li>
<li><strong>Complex Test Setup</strong>: Your test requires many lines of mock configuration, preparing return values and side effects for a chain of multiple mocked objects.</li>
<li><strong>Testing the Mock Itself</strong>: Your assertions are all about how the mock was called (<code>assert_called_with</code>, <code>assert_not_called</code>), with very few assertions about the actual return value or state change of your system.</li>
<li><strong>False Confidence</strong>: The tests pass, but the code fails in production because the mocks didn't accurately represent the behavior of the real dependencies.</li>
</ol>
<p>Our test for <code>PaymentGatewayV5.charge</code> is a good example of a test that borders on over-mocking. It knows that the implementation uses <code>requests.post</code> and that it calls <code>response.raise_for_status()</code>. This is very white-box.</p>
<h3 id="alternative-strategy-dependency-injection">Alternative Strategy: Dependency Injection</h3>
<p>A powerful technique to reduce the need for <code>monkeypatch</code> and create cleaner tests is <strong>Dependency Injection (DI)</strong>. Instead of a function or class creating its own dependencies, we "inject" them as arguments.</p>
<p>Let's refactor <code>process_order</code> to use DI.</p>
<p><strong>Before: Dependency is created internally</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># project/services.py (original version)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_order</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># Dependency is created here, tightly coupling this function</span>
    <span class="c1"># to the concrete PaymentGateway class.</span>
    <span class="n">gateway</span> <span class="o">=</span> <span class="n">PaymentGateway</span><span class="p">()</span>
    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<p><strong>After: Dependency is injected</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># project/services_di.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Protocol</span>

<span class="c1"># Define an interface (a &quot;Protocol&quot;) for our dependency</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Payable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="o">...</span>

<span class="c1"># The Order class is the same</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Order</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">shipping_address</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">items</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">process_order_di</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Order</span><span class="p">,</span> <span class="n">payment_token</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">gateway</span><span class="p">:</span> <span class="n">Payable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="c1"># Dependency is passed in, decoupling the function.</span>
    <span class="c1"># It only cares that `gateway` has a `charge` method.</span>
    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">gateway</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="n">order</span><span class="o">.</span><span class="n">total</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="n">payment_token</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transaction_id</span>
</code></pre></div>

<p>This new <code>process_order_di</code> function is much easier to test. We don't need <code>monkeypatch</code> at all. We can simply pass in a fake object that conforms to the <code>Payable</code> interface.</p>
<h3 id="the-test-becomes-simpler-and-cleaner">The Test Becomes Simpler and Cleaner</h3>
<p>Here's how we would test the dependency-injected version. Notice the absence of <code>monkeypatch</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_services_di.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">project.services_di</span><span class="w"> </span><span class="kn">import</span> <span class="n">Order</span><span class="p">,</span> <span class="n">process_order_di</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_with_injected_mock</span><span class="p">():</span>
    <span class="c1"># 1. Create a fake gateway object. It can be a simple MagicMock.</span>
    <span class="n">mock_gateway</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;txn_di_fake&quot;</span>

    <span class="c1"># 2. Create the order</span>
    <span class="n">order_items</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Keyboard&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">:</span> <span class="mi">7500</span><span class="p">}]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">order_items</span><span class="p">)</span>

    <span class="c1"># 3. Call the function, injecting our fake gateway</span>
    <span class="n">transaction_id</span> <span class="o">=</span> <span class="n">process_order_di</span><span class="p">(</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> 
        <span class="n">payment_token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">,</span> 
        <span class="n">gateway</span><span class="o">=</span><span class="n">mock_gateway</span>
    <span class="p">)</span>

    <span class="c1"># 4. Assert the outcome and the interaction</span>
    <span class="k">assert</span> <span class="n">transaction_id</span> <span class="o">==</span> <span class="s2">&quot;txn_di_fake&quot;</span>
    <span class="n">mock_gateway</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="mi">7500</span><span class="p">,</span> <span class="n">token</span><span class="o">=</span><span class="s2">&quot;VALID_TOKEN&quot;</span><span class="p">)</span>
</code></pre></div>

<p>This test is superior to our original <code>monkeypatch</code> test:
-   <strong>It's more readable</strong>: The test clearly shows that <code>process_order_di</code> is being called with a mock object. The dependency is explicit.
-   <strong>It's more robust</strong>: It tests the contract, not the implementation. <code>process_order_di</code> only cares that it receives an object with a <code>charge</code> method. It doesn't care how that object is created or where it comes from.
-   <strong>No "stringly-typed" patching</strong>: We avoid <code>monkeypatch.setattr("path.to.my.object", ...)</code>, which can be brittle if you rename or move modules.</p>
<h3 id="decision-framework-when-to-patch-vs-when-to-inject">Decision Framework: When to Patch vs. When to Inject</h3>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Best Approach</th>
<th>Why?</th>
</tr>
</thead>
<tbody>
<tr>
<td>You are testing your own code that you can refactor.</td>
<td><strong>Dependency Injection</strong></td>
<td>Leads to cleaner, more decoupled code and simpler tests. It's a better software design pattern overall.</td>
</tr>
<tr>
<td>You are testing code that depends on a third-party library (<code>requests</code>, <code>datetime</code>).</td>
<td><strong>Monkeypatch</strong></td>
<td>You can't change the library's code to accept injected dependencies. Patching is necessary to isolate your code from the library.</td>
</tr>
<tr>
<td>You are working with a legacy codebase that is difficult to refactor.</td>
<td><strong>Monkeypatch</strong></td>
<td>DI might require extensive changes. Patching allows you to write tests for existing, tightly-coupled code without modifying it first.</td>
</tr>
<tr>
<td>The dependency is a simple, global object like <code>time.time</code> or <code>random.random</code>.</td>
<td><strong>Monkeypatch</strong></td>
<td>Injecting these everywhere can clutter function signatures. A targeted patch is often cleaner.</td>
</tr>
</tbody>
</table>
<h3 id="the-journey-from-problem-to-solution">The Journey: From Problem to Solution</h3>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Failure Mode</th>
<th>Technique Applied</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Slow, unreliable tests making real network calls.</td>
<td>None</td>
<td>Initial integration test.</td>
</tr>
<tr>
<td>1</td>
<td>Needed to simulate return values and errors.</td>
<td><code>MagicMock</code> as a <strong>Stub</strong> with <code>return_value</code> and <code>side_effect</code>.</td>
<td>Fast, reliable unit tests for success and failure paths.</td>
</tr>
<tr>
<td>2</td>
<td>Tests passed even with a critical bug in argument passing.</td>
<td><code>MagicMock</code> as a <strong>Spy</strong> with <code>assert_called_once_with</code>.</td>
<td>Tests now verify the <em>interaction</em> with the dependency, catching bugs in the calling code.</td>
</tr>
<tr>
<td>3</td>
<td>Patching a class had no effect on a module-level instance.</td>
<td>Changed patch target from class to instance.</td>
<td>Reinforced the rule: "Patch where the object is used."</td>
</tr>
<tr>
<td>4</td>
<td><code>MagicMock</code> was too forgiving and hid property-related bugs.</td>
<td><code>PropertyMock</code> and <code>spec=...</code></td>
<td>Created a more faithful test double that correctly mimics the real object's interface.</td>
</tr>
<tr>
<td>5</td>
<td>Code depended on an external library (<code>requests</code>).</td>
<td>Patched the library function within our module's namespace.</td>
<td>Isolated our code from external network dependencies.</td>
</tr>
<tr>
<td>6</td>
<td>Tests became brittle and coupled to implementation details.</td>
<td><strong>Dependency Injection</strong></td>
<td>Decoupled the production code, leading to simpler, more robust tests without <code>monkeypatch</code>.</td>
</tr>
</tbody>
</table>
<p>Mocking is an essential skill, but it's a tool, not a goal. The ultimate goal is to write code that is inherently testable. Often, the struggle to write a test for a piece of code is a sign that the code itself could be improved with better design patterns like Dependency Injection.</p>
        </div>
        <div class="footer">
            Generated on 2025-11-24 14:31:16 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>