<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10 Testing Synchronous Code</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">04 Testing Patterns and Advanced Scenarios</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-10-testing-synchronous-code">Chapter 10: Testing Synchronous Code</h1>
<h2 id="testing-functions-and-methods">Testing Functions and Methods</h2>
<h2 id="the-foundation-testing-pure-functions">The Foundation: Testing Pure Functions</h2>
<p>At the heart of any application lies logic, encapsulated in functions and methods. The simplest and most reliable code to test is a <strong>pure function</strong>: a function that, for the same input, will always return the same output and has no observable side effects.</p>
<p>We will build our understanding around a common e-commerce scenario: processing a customer's order. This will be our <strong>anchor example</strong> for the entire chapter, evolving from a simple function into a complex class with dependencies.</p>
<h3 id="phase-1-establish-the-reference-implementation">Phase 1: Establish the Reference Implementation</h3>
<p>Let's start with a simple function to calculate the total price of an order.</p>
<p>First, we need a representation of a product. We'll use a simple data structure.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/product.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Product</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">price</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Price cannot be negative.&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Now, let's create our core business logic function.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/order_processing.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate_order_total</span><span class="p">(</span><span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculates the total price for a given product and quantity.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">quantity</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Quantity must be at least 1.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">product</span><span class="o">.</span><span class="n">price</span> <span class="o">*</span> <span class="n">quantity</span>
</code></pre></div>

<p>This function is a perfect candidate for our first test. It takes inputs, performs a calculation, and returns a value. It doesn't write to a file, access a database, or call an API. It's pure.</p>
<p>Let's write a straightforward pytest test for the "happy path"‚Äîa valid product and quantity.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_order_processing.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.order_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_order_total</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_order_total_success</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests that the total is calculated correctly for a valid product and quantity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Arrange</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">)</span>
    <span class="n">quantity</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="c1"># Act</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">calculate_order_total</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">total</span> <span class="o">==</span> <span class="mf">3000.0</span>
</code></pre></div>

<p>Running this test is simple and gives us immediate confidence.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_order_processing.py<span class="w"> </span>.<span class="w">                                         </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<p>This is the essence of unit testing: verifying a small, isolated piece of logic.</p>
<h3 id="iteration-1-from-function-to-method">Iteration 1: From Function to Method</h3>
<p>As our application grows, standalone functions often become methods of a class to manage related state and behavior. Let's refactor our logic into an <code>OrderProcessor</code> class. This is a common evolutionary step in software design.</p>
<p>Here is the new class structure. For now, it's just a container for our calculation method.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/order_processor.py (New File)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="k">class</span><span class="w"> </span><span class="nc">OrderProcessor</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_order_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the total price for a given product and quantity.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Quantity must be at least 1.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">product</span><span class="o">.</span><span class="n">price</span> <span class="o">*</span> <span class="n">quantity</span>
</code></pre></div>

<p>How does this change our test? The core logic is the same, but the way we call it is different. We now need an <em>instance</em> of the <code>OrderProcessor</code> class.</p>
<p>Here is the updated test file.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_order_processor.py (New Test File)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.order_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderProcessor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_calculate_order_total_success</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests that the total is calculated correctly for a valid product and quantity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Arrange</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">()</span>  <span class="c1"># We need an instance now</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">)</span>
    <span class="n">quantity</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="c1"># Act</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">calculate_order_total</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">total</span> <span class="o">==</span> <span class="mf">3000.0</span>
</code></pre></div>

<p>The test still passes, and the change seems trivial. However, this shift from a stateless function to a stateful class is the most significant leap in testing complexity. It opens the door to new challenges related to state management, dependencies, and side effects, which we will tackle in the upcoming sections.</p>
<h2 id="testing-classes-and-object-oriented-code">Testing Classes and Object-Oriented Code</h2>
<h2 id="the-challenge-of-state">The Challenge of State</h2>
<p>Classes are more than just collections of methods; they encapsulate <strong>state</strong> (data) and <strong>behavior</strong> (methods). While our <code>OrderProcessor</code> is currently stateless, any realistic implementation would need to track information, such as a history of processed orders.</p>
<p>Testing stateful objects introduces a critical new requirement: <strong>test isolation</strong>. One test must not be affected by the state changes caused by another.</p>
<h3 id="iteration-2-introducing-state-and-a-new-bug">Iteration 2: Introducing State and a New Bug</h3>
<p>Let's add a feature to our <code>OrderProcessor</code>: it will now keep a record of every order ID it processes.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/order_processor.py (Updated)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="k">class</span><span class="w"> </span><span class="nc">OrderProcessor</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_orders</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_order_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a unique order ID.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Processes an order and records it.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Quantity must be at least 1.&quot;</span><span class="p">)</span>

        <span class="n">order_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_order_id</span><span class="p">()</span>
        <span class="c1"># In a real system, this would do more (e.g., charge card, update inventory)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">order_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed order </span><span class="si">{</span><span class="n">order_id</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">quantity</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">product</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">order_id</span>
</code></pre></div>

<p>Our old test for <code>calculate_order_total</code> is now obsolete. We need new tests for <code>process_order</code> that verify two things:
1.  It returns an order ID (behavior).
2.  It adds the order ID to <code>processed_orders</code> (state change).</p>
<p>Let's write two tests. A common but flawed approach for beginners is to use a single, shared instance of the class for all tests.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_order_processor.py (Problematic Version)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.order_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderProcessor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="c1"># Create a single instance to be shared by all tests in this module</span>
<span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">()</span>
<span class="n">product</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Keyboard&quot;</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mf">75.0</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_adds_to_history</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that a processed order is added to the processor&#39;s history.&quot;&quot;&quot;</span>
    <span class="n">initial_history_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span>

    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="n">initial_history_count</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_single_item_order</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that processing an order for a single item works.&quot;&quot;&quot;</span>
    <span class="c1"># This test has a hidden assumption: that processed_orders is empty.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>Now, let's run pytest. One of our tests is going to fail.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_order_processor.py::test_process_order_adds_to_history<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
tests/test_order_processor.py::test_process_single_item_order<span class="w"> </span>FAILED<span class="w">   </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">===================================</span>
_______________________<span class="w"> </span>test_process_single_item_order<span class="w"> </span>_______________________

<span class="w">    </span>def<span class="w"> </span>test_process_single_item_order<span class="o">()</span>:
<span class="w">        </span><span class="s2">&quot;&quot;&quot;Verify that processing an order for a single item works.&quot;&quot;&quot;</span>
<span class="w">        </span><span class="c1"># This test has a hidden assumption: that processed_orders is empty.</span>
&gt;<span class="w">       </span>assert<span class="w"> </span>len<span class="o">(</span>processor.processed_orders<span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span>
E<span class="w">       </span>assert<span class="w"> </span><span class="nv">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span>
E<span class="w">        </span>+<span class="w">  </span>where<span class="w"> </span><span class="nv">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>len<span class="o">([</span><span class="s1">&#39;...&#39;</span><span class="o">])</span>

tests/test_order_processor.py:20:<span class="w"> </span><span class="nv">AssertionError</span>
<span class="o">===========================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">============================</span>
FAILED<span class="w"> </span>tests/test_order_processor.py::test_process_single_item_order<span class="w"> </span>-<span class="w"> </span>assert<span class="w"> </span><span class="nv">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nv">0</span>
<span class="o">=========================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed,<span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">=========================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure">Diagnostic Analysis: Reading the Failure</h3>
<p><strong>The complete output</strong>: The summary shows one test passed and one failed. The failure is <code>test_process_single_item_order</code>.</p>
<p><strong>Let's parse this section by section</strong>:</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>FAILED tests/test_order_processor.py::test_process_single_item_order - assert 1 == 0</code></p>
<ul>
<li><strong>What this tells us</strong>: The test failed because of an <code>AssertionError</code>. The specific assertion that failed was comparing <code>1</code> and <code>0</code>.</li>
</ul>
</li>
<li>
<p><strong>The traceback</strong>:
    ```python
    def test_process_single_item_order():
        """Verify that processing an order for a single item works."""
        # This test has a hidden assumption: that processed_orders is empty.</p>
<blockquote>
<div class="codehilite"><pre><span></span><code>  assert len(processor.processed_orders) == 0
```
</code></pre></div>

</blockquote>
<ul>
<li><strong>What this tells us</strong>: The failure occurred on line 20 of our test file.</li>
<li><strong>Key line</strong>: <code>assert len(processor.processed_orders) == 0</code> is the exact point of failure.</li>
</ul>
</li>
<li>
<p><strong>The assertion introspection</strong>:
    <code>E       assert 1 == 0
    E        +  where 1 = len(['...'])</code></p>
<ul>
<li><strong>What this tells us</strong>: Pytest's powerful introspection shows us the <em>values</em> at the time of the assertion. The left side of the <code>==</code>, which was <code>len(processor.processed_orders)</code>, evaluated to <code>1</code>. The right side was <code>0</code>. The assertion <code>1 == 0</code> is correctly identified as false.</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: The <code>test_process_single_item_order</code> test incorrectly assumed that the <code>processor.processed_orders</code> list would be empty at the start of the test. It was not; it contained one item.</p>
<p><strong>Why the current approach can't solve this</strong>: By creating a single <code>processor</code> instance at the module level, we created shared state. The first test to run (<code>test_process_order_adds_to_history</code>) modified this shared state by adding an order ID to the list. The second test inherited this modified state, causing its initial assumption to be violated. The order of test execution determined the outcome, a classic sign of a fragile test suite.</p>
<p><strong>What we need</strong>: A mechanism to ensure that every single test function gets a fresh, clean instance of <code>OrderProcessor</code>, guaranteeing test isolation.</p>
<h3 id="the-solution-fixtures-for-isolation">The Solution: Fixtures for Isolation</h3>
<p>This is precisely the problem that pytest fixtures are designed to solve. A fixture is a function that provides a resource (like a class instance, a database connection, or a dataset) to your tests. Pytest ensures that fixtures are set up and torn down cleanly for each test that uses them.</p>
<p>Let's refactor our tests to use a fixture. By convention, fixtures are often placed in a <code>conftest.py</code> file to be shared across multiple test files, but for a single file, defining it locally is fine.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_order_processor.py (Corrected Version)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.order_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderProcessor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">processor</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a fresh OrderProcessor instance for each test.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">OrderProcessor</span><span class="p">()</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">product</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a sample product for tests.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Keyboard&quot;</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="mf">75.0</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_adds_to_history</span><span class="p">(</span><span class="n">processor</span><span class="p">,</span> <span class="n">product</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that a processed order is added to the processor&#39;s history.&quot;&quot;&quot;</span>
    <span class="n">initial_history_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">initial_history_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1"># We can now safely assume this</span>

    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="n">initial_history_count</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_single_item_order</span><span class="p">(</span><span class="n">processor</span><span class="p">,</span> <span class="n">product</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that processing an order for a single item works.&quot;&quot;&quot;</span>
    <span class="c1"># This test now gets its own &#39;processor&#39; instance.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>Let's run the tests again.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_order_processor.py::test_process_order_adds_to_history<span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
tests/test_order_processor.py::test_process_single_item_order<span class="w"> </span>PASSED<span class="w">   </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<p><strong>Success!</strong> By declaring <code>processor</code> and <code>product</code> as arguments in our test functions, we told pytest to execute the corresponding fixture functions and pass their return values to our tests. Because the default <strong>scope</strong> of a fixture is <code>function</code>, pytest creates a brand new <code>OrderProcessor</code> and <code>Product</code> for each test, guaranteeing isolation. The <code>test_process_single_item_order</code> now receives an instance whose <code>processed_orders</code> list is guaranteed to be empty.</p>
<p>This solves the state management problem, but our <code>OrderProcessor</code> has a hidden implementation detail (<code>_generate_order_id</code>) that we might be tempted to test directly.</p>
<h2 id="testing-private-methods-and-why-you-might-not-want-to">Testing Private Methods (And Why You Might Not Want To)</h2>
<h2 id="the-temptation-of-implementation-details">The Temptation of Implementation Details</h2>
<p>Our <code>OrderProcessor</code> has a "private" method, <code>_generate_order_id</code>, indicated by the leading underscore. This is a Python convention signifying that the method is an internal implementation detail and not part of the class's public API.</p>
<p>A common question arises: "Should I write a test specifically for <code>_generate_order_id</code>?"</p>
<p>The short answer is usually <strong>no</strong>.</p>
<h3 id="the-philosophy-test-behavior-not-implementation">The Philosophy: Test Behavior, Not Implementation</h3>
<p>Your tests should act as the first user of your code. A user of the <code>OrderProcessor</code> class doesn't care <em>how</em> the order ID is generated; they only care that when they call the public method <code>process_order</code>, they get a unique ID back and the order is processed correctly.</p>
<ul>
<li><strong>Testing Public Behavior</strong>: When you test <code>process_order</code>, you are implicitly testing <code>_generate_order_id</code>. If the ID generation were to break (e.g., return <code>None</code>), your test for <code>process_order</code> would fail. This is good! The test tells you that a user-facing behavior is broken.</li>
<li><strong>Testing Private Implementation</strong>: If you write a separate test for <code>_generate_order_id</code>, you are coupling your test suite to the internal structure of your class.</li>
</ul>
<p>Let's see what happens when we refactor the implementation without changing the behavior.</p>
<h3 id="iteration-3-a-refactor-that-breaks-a-bad-test">Iteration 3: A Refactor that Breaks a Bad Test</h3>
<p>Imagine we decide to change the order ID format to be prefixed with <code>ORD-</code>. The public behavior is unchanged‚Äîit still returns a unique string.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/order_processor.py (Refactored)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="k">class</span><span class="w"> </span><span class="nc">OrderProcessor</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_orders</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_order_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates a unique order ID with a prefix.&quot;&quot;&quot;</span>
        <span class="c1"># We changed the implementation detail.</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;ORD-</span><span class="si">{</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Processes an order and records it.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Quantity must be at least 1.&quot;</span><span class="p">)</span>

        <span class="n">order_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_order_id</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">order_id</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed order </span><span class="si">{</span><span class="n">order_id</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">quantity</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">product</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">order_id</span>
</code></pre></div>

<p>Our existing tests for <code>process_order</code> still pass perfectly because they only check that an ID was added to the history. They don't care about the ID's format. This is the hallmark of a robust test suite.</p>
<p>Now, let's demonstrate the <strong>wrong way</strong>. Suppose we had written a test that was tightly coupled to the implementation of <code>_generate_order_id</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_order_processor_bad.py (A new file demonstrating a bad practice)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.order_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderProcessor</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_generate_order_id_is_valid_uuid</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a BRITTLE test. It tests a private implementation detail.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">()</span>
    <span class="c1"># We access the private method directly</span>
    <span class="n">order_id</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">_generate_order_id</span><span class="p">()</span>

    <span class="c1"># This assertion is tied to the OLD implementation.</span>
    <span class="c1"># It assumes the ID is a pure UUID string.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="n">order_id</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">pytest</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">order_id</span><span class="si">}</span><span class="s2">&#39; is not a valid UUID.&quot;</span><span class="p">)</span>
</code></pre></div>

<p>With our refactored <code>OrderProcessor</code>, this new "bad" test will now fail.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>tests/test_order_processor_bad.py
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_order_processor_bad.py<span class="w"> </span>F<span class="w">                                      </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">===================================</span>
______________________<span class="w"> </span>test_generate_order_id_is_valid_uuid<span class="w"> </span>______________________

<span class="w">    </span>def<span class="w"> </span>test_generate_order_id_is_valid_uuid<span class="o">()</span>:
<span class="w">        </span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        This is a BRITTLE test. It tests a private implementation detail.</span>
<span class="s2">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="nv">processor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>OrderProcessor<span class="o">()</span>
<span class="w">        </span><span class="c1"># We access the private method directly</span>
<span class="w">        </span><span class="nv">order_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>processor._generate_order_id<span class="o">()</span>

<span class="w">        </span><span class="c1"># This assertion is tied to the OLD implementation.</span>
<span class="w">        </span><span class="c1"># It assumes the ID is a pure UUID string.</span>
<span class="w">        </span>try:
<span class="w">            </span>uuid.UUID<span class="o">(</span>order_id<span class="o">)</span>
<span class="w">        </span>except<span class="w"> </span>ValueError:
&gt;<span class="w">           </span>pytest.fail<span class="o">(</span>f<span class="s2">&quot;&#39;{order_id}&#39; is not a valid UUID.&quot;</span><span class="o">)</span>
E<span class="w">           </span>Failed:<span class="w"> </span><span class="s1">&#39;ORD-...&#39;</span><span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>a<span class="w"> </span>valid<span class="w"> </span>UUID.

tests/test_order_processor_bad.py:17:<span class="w"> </span><span class="nv">Failed</span>
<span class="o">===========================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">============================</span>
FAILED<span class="w"> </span>tests/test_order_processor_bad.py::test_generate_order_id_is_valid_uuid
<span class="o">==============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-the-cost-of-brittle-tests">Diagnostic Analysis: The Cost of Brittle Tests</h3>
<p>The test failed because the code worked as intended! We changed an internal detail (<code>_generate_order_id</code>) without breaking the public contract (<code>process_order</code>). The test failed not because of a bug in the application code, but because the test itself was too specific and fragile.</p>
<p><strong>Root cause identified</strong>: The test was coupled to the implementation, not the behavior.</p>
<p><strong>Why this is a problem</strong>:
1.  <strong>Increased Maintenance</strong>: Every time you refactor internal code, you have to fix a series of failing tests, even if the public behavior is unchanged. This slows down development and discourages refactoring.
2.  <strong>Reduced Clarity</strong>: The test failure doesn't indicate a real bug. It's noise that hides real problems.</p>
<h3 id="when-to-reconsider">When to Reconsider</h3>
<p>There are exceptions. If a private method contains extremely complex, critical logic (e.g., a sophisticated pricing algorithm), you might argue for testing it directly. However, a better approach is often to ask: "If this logic is so important, why is it a private method?"</p>
<p>Often, the need to test a private method is a "code smell" suggesting that the class is doing too much. The complex logic might be better off extracted into its own, separate class or module. That new component would have a public API, which you could then test thoroughly and with confidence.</p>
<p><strong>Guideline</strong>: Start by testing only public methods. If you feel a strong urge to test a private one, first consider refactoring your code to make that logic part of a public API on another, more focused object.</p>
<h2 id="testing-code-with-side-effects">Testing Code with Side Effects</h2>
<h2 id="the-world-outside-your-function">The World Outside Your Function</h2>
<p>So far, our <code>OrderProcessor</code> has lived in a vacuum. A real-world order processor must interact with other systems: it needs to check inventory, charge a credit card, and maybe send an email. These interactions are called <strong>side effects</strong>.</p>
<p>Side effects make testing dramatically harder. If your test debits a real inventory database or calls a real payment API, it becomes:
*   <strong>Slow</strong>: Network calls and database queries are orders of magnitude slower than in-memory operations.
*   <strong>Expensive</strong>: You might be charged for API calls.
*   <strong>Unreliable</strong>: The test could fail due to network issues or a third-party service being down.
*   <strong>Destructive</strong>: The test changes the state of an external system, violating test isolation.</p>
<p>The solution is to isolate our code from its dependencies during testing using <strong>Test Doubles</strong>.</p>
<h3 id="iteration-4-introducing-dependencies-and-side-effects">Iteration 4: Introducing Dependencies and Side Effects</h3>
<p>Let's make our <code>OrderProcessor</code> more realistic. It will now depend on an <code>InventorySystem</code> and a <code>PaymentGateway</code>. We'll use the principle of <strong>Dependency Injection</strong>: instead of creating its dependencies, the <code>OrderProcessor</code> will receive them in its constructor. This is crucial for testability.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/dependencies.py (New File)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="k">class</span><span class="w"> </span><span class="nc">InventorySystem</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># In a real app, this would connect to a database.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stock</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Laptop&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
            <span class="s2">&quot;Keyboard&quot;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_stock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DATABASE: Checking stock for </span><span class="si">{</span><span class="n">product</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">product</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">quantity</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reduce_stock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DATABASE: Reducing stock for </span><span class="si">{</span><span class="n">product</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="n">quantity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stock</span><span class="p">[</span><span class="n">product</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">-=</span> <span class="n">quantity</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PaymentGateway</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">card_details</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;API: Charging card </span><span class="si">{</span><span class="n">card_details</span><span class="si">}</span><span class="s2"> for $</span><span class="si">{</span><span class="n">amount</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># In a real app, this would call a third-party API like Stripe.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">card_details</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># src/order_processor.py (Updated with Dependencies)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.dependencies</span><span class="w"> </span><span class="kn">import</span> <span class="n">InventorySystem</span><span class="p">,</span> <span class="n">PaymentGateway</span>

<span class="k">class</span><span class="w"> </span><span class="nc">OrderProcessor</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inventory</span><span class="p">:</span> <span class="n">InventorySystem</span><span class="p">,</span> <span class="n">payment</span><span class="p">:</span> <span class="n">PaymentGateway</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inventory</span> <span class="o">=</span> <span class="n">inventory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">payment</span> <span class="o">=</span> <span class="n">payment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_orders</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_order_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;ORD-</span><span class="si">{</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">card_details</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inventory</span><span class="o">.</span><span class="n">check_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough stock.&quot;</span><span class="p">)</span>

        <span class="n">total_price</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">price</span> <span class="o">*</span> <span class="n">quantity</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">payment</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">total_price</span><span class="p">,</span> <span class="n">card_details</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Payment failed.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inventory</span><span class="o">.</span><span class="n">reduce_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>

        <span class="n">order_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_order_id</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">order_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">order_id</span>
</code></pre></div>

<p>Now, let's write a test for the happy path. A naive approach would be to use the real dependencies.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_order_processor.py (New test with real dependencies)</span>
<span class="c1"># ... (previous fixtures and tests) ...</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">src.dependencies</span><span class="w"> </span><span class="kn">import</span> <span class="n">InventorySystem</span><span class="p">,</span> <span class="n">PaymentGateway</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_with_real_dependencies_fails_on_second_run</span><span class="p">():</span>
    <span class="c1"># Arrange</span>
    <span class="n">inventory</span> <span class="o">=</span> <span class="n">InventorySystem</span><span class="p">()</span> <span class="c1"># Real dependency</span>
    <span class="n">payment</span> <span class="o">=</span> <span class="n">PaymentGateway</span><span class="p">()</span>    <span class="c1"># Real dependency</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">(</span><span class="n">inventory</span><span class="p">,</span> <span class="n">payment</span><span class="p">)</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">)</span>

    <span class="c1"># Act</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">card_details</span><span class="o">=</span><span class="s2">&quot;1234-5678&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="c1"># We can&#39;t easily check the database, but we can check our own state</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="c1"># Let&#39;s try to check the inventory state</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">inventory</span><span class="o">.</span><span class="n">check_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># 10 - 8 = 2 left, so 5 is not available</span>
</code></pre></div>

<p>This test might pass the first time. But what happens if we run it twice? Or what if we run another test that also uses the "Laptop" inventory? Let's run this specific test twice in a row using <code>pytest -k ... -v --count=2</code>.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-k<span class="w"> </span>test_process_order_with_real_dependencies<span class="w"> </span>-v<span class="w"> </span>--count<span class="o">=</span><span class="nv">2</span>
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item<span class="w"> </span>/<span class="w"> </span><span class="m">1</span><span class="w"> </span>deselected<span class="w"> </span>/<span class="w"> </span><span class="m">1</span><span class="w"> </span>selected

tests/test_order_processor.py::test_process_order_with_real_dependencies_fails_on_second_run<span class="w"> </span><span class="o">[</span><span class="m">1</span>/2<span class="o">]</span><span class="w"> </span>PASSED<span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
tests/test_order_processor.py::test_process_order_with_real_dependencies_fails_on_second_run<span class="w"> </span><span class="o">[</span><span class="m">2</span>/2<span class="o">]</span><span class="w"> </span>FAILED<span class="w"> </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">===================================</span>
_<span class="w"> </span>test_process_order_with_real_dependencies_fails_on_second_run<span class="w"> </span>_

<span class="w">    </span>def<span class="w"> </span>test_process_order_with_real_dependencies_fails_on_second_run<span class="o">()</span>:
<span class="w">        </span><span class="c1"># ...</span>
<span class="w">        </span><span class="nv">processor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>OrderProcessor<span class="o">(</span>inventory,<span class="w"> </span>payment<span class="o">)</span>
<span class="w">        </span><span class="nv">product</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>Product<span class="o">(</span><span class="s2">&quot;Laptop&quot;</span>,<span class="w"> </span><span class="m">1000</span>.0<span class="o">)</span>

<span class="w">        </span><span class="c1"># Act</span>
&gt;<span class="w">       </span>processor.process_order<span class="o">(</span>product,<span class="w"> </span><span class="nv">quantity</span><span class="o">=</span><span class="m">8</span>,<span class="w"> </span><span class="nv">card_details</span><span class="o">=</span><span class="s2">&quot;1234-5678&quot;</span><span class="o">)</span>

tests/test_order_processor.py:50:<span class="w"> </span>
_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>_<span class="w"> </span>
src/order_processor.py:19:<span class="w"> </span><span class="k">in</span><span class="w"> </span>process_order
<span class="w">    </span>raise<span class="w"> </span>ValueError<span class="o">(</span><span class="s2">&quot;Not enough stock.&quot;</span><span class="o">)</span>
E<span class="w">   </span>ValueError:<span class="w"> </span>Not<span class="w"> </span>enough<span class="w"> </span>stock.
<span class="o">===========================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">============================</span>
FAILED<span class="w"> </span>tests/test_order_processor.py::test_process_order_with_real_dependencies_fails_on_second_run<span class="w"> </span>-<span class="w"> </span>ValueError:<span class="w"> </span>Not<span class="w"> </span>enough<span class="w"> </span>stock.
<span class="o">=========================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed,<span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">=========================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure_1">Diagnostic Analysis: Reading the Failure</h3>
<p><strong>The complete output</strong>: The first run passed, but the second run failed with a <code>ValueError</code>.</p>
<p><strong>Let's parse this section by section</strong>:</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>FAILED ... - ValueError: Not enough stock.</code></p>
<ul>
<li><strong>What this tells us</strong>: The test failed because our application code raised a <code>ValueError</code> with a specific message. This wasn't an <code>AssertionError</code>; the test crashed before it could even get to the assertion.</li>
</ul>
</li>
<li>
<p><strong>The traceback</strong>:
    <code>python
    src/order_processor.py:19: in process_order
        raise ValueError("Not enough stock.")</code></p>
<ul>
<li><strong>What this tells us</strong>: The crash happened inside our application code, in the <code>process_order</code> method, when it tried to raise the "Not enough stock" error. This means the <code>inventory.check_stock(product, quantity)</code> call must have returned <code>False</code>.</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: The first test run reduced the stock of "Laptop" from 10 to 2. The second test run tried to order 8 more, but since only 2 were available, <code>check_stock</code> returned <code>False</code>, and our code correctly raised an exception. The test failed because of a side effect from a previous run.</p>
<p><strong>What we need</strong>: A way to control the behavior of the dependencies within our test. We need an <code>InventorySystem</code> that we can configure with any stock level we want, and that doesn't affect other tests. We need a <code>PaymentGateway</code> that doesn't actually make network calls but simply tells us if it was called correctly.</p>
<h3 id="the-solution-fakes-and-mocks">The Solution: Fakes and Mocks</h3>
<p>We will create "Fake" objects‚Äîsimplified, in-memory implementations of our dependencies that are designed for testing.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/fakes.py (New File)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FakeInventory</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stock</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stock</span> <span class="o">=</span> <span class="n">stock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stock_reduced_for</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_stock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stock</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">product</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">quantity</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reduce_stock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stock</span><span class="p">[</span><span class="n">product</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">-=</span> <span class="n">quantity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stock_reduced_for</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FakePaymentGateway</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_amount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_card</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">card_details</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_amount</span> <span class="o">=</span> <span class="n">amount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_card</span> <span class="o">=</span> <span class="n">card_details</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>

<p>These fakes mimic the interface of the real objects but give us complete control. We can set the initial stock and inspect their state after the test (<code>charged_amount</code>, <code>stock_reduced_for</code>) to verify interactions.</p>
<p>Now, let's rewrite our test using these fakes.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_order_processor.py (Rewritten with Fakes)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.order_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderProcessor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.fakes</span><span class="w"> </span><span class="kn">import</span> <span class="n">FakeInventory</span><span class="p">,</span> <span class="n">FakePaymentGateway</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">product</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="s2">&quot;Laptop&quot;</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_successfully</span><span class="p">(</span><span class="n">product</span><span class="p">):</span>
    <span class="c1"># Arrange</span>
    <span class="n">inventory</span> <span class="o">=</span> <span class="n">FakeInventory</span><span class="p">(</span><span class="n">stock</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Laptop&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>
    <span class="n">payment</span> <span class="o">=</span> <span class="n">FakePaymentGateway</span><span class="p">()</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">(</span><span class="n">inventory</span><span class="p">,</span> <span class="n">payment</span><span class="p">)</span>

    <span class="c1"># Act</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">card_details</span><span class="o">=</span><span class="s2">&quot;1234-5678&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="c1"># 1. Check interactions with dependencies</span>
    <span class="k">assert</span> <span class="n">inventory</span><span class="o">.</span><span class="n">stock_reduced_for</span> <span class="o">==</span> <span class="s2">&quot;Laptop&quot;</span>
    <span class="k">assert</span> <span class="n">payment</span><span class="o">.</span><span class="n">charged_amount</span> <span class="o">==</span> <span class="mf">8000.0</span>
    <span class="k">assert</span> <span class="n">payment</span><span class="o">.</span><span class="n">charged_card</span> <span class="o">==</span> <span class="s2">&quot;1234-5678&quot;</span>

    <span class="c1"># 2. Check internal state of the object under test</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_fails_when_not_enough_stock</span><span class="p">(</span><span class="n">product</span><span class="p">):</span>
    <span class="c1"># Arrange</span>
    <span class="n">inventory</span> <span class="o">=</span> <span class="n">FakeInventory</span><span class="p">(</span><span class="n">stock</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Laptop&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span> <span class="c1"># Not enough stock</span>
    <span class="n">payment</span> <span class="o">=</span> <span class="n">FakePaymentGateway</span><span class="p">()</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">(</span><span class="n">inventory</span><span class="p">,</span> <span class="n">payment</span><span class="p">)</span>

    <span class="c1"># Act &amp; Assert</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="s2">&quot;Not enough stock.&quot;</span><span class="p">):</span>
        <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">card_details</span><span class="o">=</span><span class="s2">&quot;1234-5678&quot;</span><span class="p">)</span>
</code></pre></div>

<p>These tests are now fast, reliable, and isolated. They test the logic of <code>OrderProcessor</code> without touching any external systems. We have successfully unit-tested code with side effects.</p>
<p>However, this introduces a new risk: what if our <code>FakeInventory</code> behaves differently from the <code>RealInventory</code>? Our unit tests would pass, but the application would fail in production. This is where integration testing comes in.</p>
<h2 id="integration-testing-within-your-codebase">Integration Testing Within Your Codebase</h2>
<h2 id="verifying-the-contracts-between-components">Verifying the Contracts Between Components</h2>
<p>Unit tests are essential for verifying the logic of a single component in isolation. We've successfully tested our <code>OrderProcessor</code> by replacing its dependencies with fakes.</p>
<p>But this creates a blind spot. Our tests prove that <code>OrderProcessor</code> works with <code>FakeInventory</code>, but they <em>don't</em> prove it works with the <code>RealInventory</code>. We are trusting that our fake perfectly mimics the real object's contract (method names, arguments, return values, exceptions). If the real <code>InventorySystem</code> changes its <code>reduce_stock</code> method to <code>debit_stock</code>, our unit tests for <code>OrderProcessor</code> would still pass, but the application would break.</p>
<p><strong>Integration tests</strong> fill this gap. They test the interaction <em>between</em> two or more real components to ensure they work together as expected.</p>
<h3 id="iteration-5-testing-the-collaboration">Iteration 5: Testing the Collaboration</h3>
<p>Let's write an integration test that uses the real <code>OrderProcessor</code> and the real <code>InventorySystem</code>. We will still fake the <code>PaymentGateway</code>, as we want to avoid external network calls, but we will test the direct integration between the order logic and the inventory logic.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_integration.py (New File)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.order_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderProcessor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.dependencies</span><span class="w"> </span><span class="kn">import</span> <span class="n">InventorySystem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.fakes</span><span class="w"> </span><span class="kn">import</span> <span class="n">FakePaymentGateway</span> <span class="c1"># We still fake the external service</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">product</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Product</span><span class="p">(</span><span class="s2">&quot;Keyboard&quot;</span><span class="p">,</span> <span class="mf">75.0</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_order_processing_updates_real_inventory</span><span class="p">(</span><span class="n">product</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An integration test to verify OrderProcessor and InventorySystem work together.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Arrange</span>
    <span class="c1"># Use the REAL InventorySystem</span>
    <span class="n">inventory</span> <span class="o">=</span> <span class="n">InventorySystem</span><span class="p">()</span> 
    <span class="c1"># Use a FAKE PaymentGateway to avoid external calls</span>
    <span class="n">payment</span> <span class="o">=</span> <span class="n">FakePaymentGateway</span><span class="p">()</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">(</span><span class="n">inventory</span><span class="p">,</span> <span class="n">payment</span><span class="p">)</span>

    <span class="c1"># Check initial stock level</span>
    <span class="k">assert</span> <span class="n">inventory</span><span class="o">.</span><span class="n">check_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>

    <span class="c1"># Act</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">card_details</span><span class="o">=</span><span class="s2">&quot;valid-card&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="c1"># Verify the side effect on the real inventory object</span>
    <span class="k">assert</span> <span class="n">inventory</span><span class="o">.</span><span class="n">check_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span> <span class="c1"># 25 - 15 = 10 left</span>
    <span class="k">assert</span> <span class="n">inventory</span><span class="o">.</span><span class="n">check_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
</code></pre></div>

<p>This test provides a higher level of confidence. It proves that <code>OrderProcessor</code> calls the correct methods on <code>InventorySystem</code> and that the state of <code>InventorySystem</code> is updated as expected.</p>
<h3 id="the-test-pyramid-balancing-unit-and-integration-tests">The Test Pyramid: Balancing Unit and Integration Tests</h3>
<p>This brings us to the concept of the Test Pyramid.</p>
<ul>
<li><strong>Unit Tests (Base)</strong>: You should have many of these. They are fast, stable, and precisely locate failures. Our tests using <code>FakeInventory</code> and <code>FakePaymentGateway</code> are unit tests.</li>
<li><strong>Integration Tests (Middle)</strong>: You should have a moderate number of these. They are slower and more brittle than unit tests but verify that components collaborate correctly. Our <code>test_order_processing_updates_real_inventory</code> is an integration test.</li>
<li><strong>End-to-End (E2E) Tests (Top)</strong>: You should have very few of these. They test the entire application stack, often by driving a web browser or a public API. They are very slow, brittle, and expensive to run, but provide the highest confidence that the whole system works.</li>
</ul>
<p>You should focus most of your effort on unit tests, as they provide the best return on investment for catching bugs quickly. Use integration tests strategically to cover the critical seams between your application's components.</p>
<h3 id="the-journey-from-problem-to-solution">The Journey: From Problem to Solution</h3>
<p>Let's review the path we took to build a robust test suite for our synchronous code.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Iteration</th>
<th style="text-align: left;">Problem / Failure Mode</th>
<th style="text-align: left;">Technique Applied</th>
<th style="text-align: left;">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">0</td>
<td style="text-align: left;">Testing a simple, pure function.</td>
<td style="text-align: left;">Basic <code>assert</code> statement.</td>
<td style="text-align: left;">Confidence in a single algorithm.</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">Logic moved into a class method.</td>
<td style="text-align: left;">Instantiate the class in the test.</td>
<td style="text-align: left;">Test adapted to object-oriented structure.</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">Shared class instance causes test interdependence.</td>
<td style="text-align: left;"><code>pytest.fixture</code> for test isolation.</td>
<td style="text-align: left;">Each test gets a fresh instance; tests are reliable.</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;">Temptation to test private methods.</td>
<td style="text-align: left;">Philosophy: Test public behavior, not implementation.</td>
<td style="text-align: left;">A robust test suite that isn't brittle to refactoring.</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;">Side effects (database, API) make tests slow/unreliable.</td>
<td style="text-align: left;">Test Doubles (Fakes) and Dependency Injection.</td>
<td style="text-align: left;">Fast, isolated unit tests for complex logic.</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;">Unit tests don't verify component contracts.</td>
<td style="text-align: left;">Integration tests for key component collaborations.</td>
<td style="text-align: left;">Confidence that components work together correctly.</td>
</tr>
</tbody>
</table>
<h3 id="final-implementation">Final Implementation</h3>
<p>Here is the final state of our <code>OrderProcessor</code> and a selection of the tests we built, representing a healthy mix of unit and integration testing.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/order_processor.py (Final)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.product</span><span class="w"> </span><span class="kn">import</span> <span class="n">Product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.dependencies</span><span class="w"> </span><span class="kn">import</span> <span class="n">InventorySystem</span><span class="p">,</span> <span class="n">PaymentGateway</span>

<span class="k">class</span><span class="w"> </span><span class="nc">OrderProcessor</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inventory</span><span class="p">:</span> <span class="n">InventorySystem</span><span class="p">,</span> <span class="n">payment</span><span class="p">:</span> <span class="n">PaymentGateway</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inventory</span> <span class="o">=</span> <span class="n">inventory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">payment</span> <span class="o">=</span> <span class="n">payment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_orders</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_order_id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;ORD-</span><span class="si">{</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product</span><span class="p">:</span> <span class="n">Product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">card_details</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inventory</span><span class="o">.</span><span class="n">check_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough stock.&quot;</span><span class="p">)</span>

        <span class="n">total_price</span> <span class="o">=</span> <span class="n">product</span><span class="o">.</span><span class="n">price</span> <span class="o">*</span> <span class="n">quantity</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">payment</span><span class="o">.</span><span class="n">charge</span><span class="p">(</span><span class="n">total_price</span><span class="p">,</span> <span class="n">card_details</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Payment failed.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inventory</span><span class="o">.</span><span class="n">reduce_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>

        <span class="n">order_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_order_id</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">order_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">order_id</span>

<span class="c1"># tests/test_order_processor.py (Final Unit Test)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_process_order_successfully</span><span class="p">(</span><span class="n">product</span><span class="p">):</span>
    <span class="c1"># Arrange</span>
    <span class="n">inventory</span> <span class="o">=</span> <span class="n">FakeInventory</span><span class="p">(</span><span class="n">stock</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Laptop&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>
    <span class="n">payment</span> <span class="o">=</span> <span class="n">FakePaymentGateway</span><span class="p">()</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">(</span><span class="n">inventory</span><span class="p">,</span> <span class="n">payment</span><span class="p">)</span>

    <span class="c1"># Act</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">card_details</span><span class="o">=</span><span class="s2">&quot;1234-5678&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">inventory</span><span class="o">.</span><span class="n">stock_reduced_for</span> <span class="o">==</span> <span class="s2">&quot;Laptop&quot;</span>
    <span class="k">assert</span> <span class="n">payment</span><span class="o">.</span><span class="n">charged_amount</span> <span class="o">==</span> <span class="mf">8000.0</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">processed_orders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="c1"># tests/test_integration.py (Final Integration Test)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_order_processing_updates_real_inventory</span><span class="p">(</span><span class="n">product</span><span class="p">):</span>
    <span class="c1"># Arrange</span>
    <span class="n">inventory</span> <span class="o">=</span> <span class="n">InventorySystem</span><span class="p">()</span> 
    <span class="n">payment</span> <span class="o">=</span> <span class="n">FakePaymentGateway</span><span class="p">()</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">OrderProcessor</span><span class="p">(</span><span class="n">inventory</span><span class="p">,</span> <span class="n">payment</span><span class="p">)</span>

    <span class="c1"># Act</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">process_order</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">quantity</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">card_details</span><span class="o">=</span><span class="s2">&quot;valid-card&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">inventory</span><span class="o">.</span><span class="n">check_stock</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
</code></pre></div>

<h3 id="decision-framework-unit-vs-integration-test">Decision Framework: Unit vs. Integration Test</h3>
<p>When should you write which type of test?</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Characteristic</th>
<th style="text-align: left;">Choose a <strong>Unit Test</strong> When...</th>
<th style="text-align: left;">Choose an <strong>Integration Test</strong> When...</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Goal</strong></td>
<td style="text-align: left;">You want to verify the internal logic of a single component.</td>
<td style="text-align: left;">You want to verify the contract/collaboration between components.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Dependencies</strong></td>
<td style="text-align: left;">All external dependencies (DB, API, other classes) are replaced with Test Doubles.</td>
<td style="text-align: left;">One or more dependencies are real, concrete objects.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Speed</strong></td>
<td style="text-align: left;">You need the test to be extremely fast (milliseconds).</td>
<td style="text-align: left;">You can tolerate a slower test (tens or hundreds of ms).</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Scope</strong></td>
<td style="text-align: left;">The test focuses on edge cases, business rules, and algorithms within one class.</td>
<td style="text-align: left;">The test focuses on data flow and side effects across classes.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Failure Insight</strong></td>
<td style="text-align: left;">A failure precisely pinpoints the bug in a specific class.</td>
<td style="text-align: left;">A failure indicates a problem in the interaction, requiring more debugging.</td>
</tr>
</tbody>
</table>
        </div>
        <div class="footer">
            Generated on 2025-11-24 14:31:16 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>