<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11 Testing Asynchronous Code</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">04 Testing Patterns and Advanced Scenarios</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-11-testing-asynchronous-code">Chapter 11: Testing Asynchronous Code</h1>
<h2 id="the-basics-of-asyncawait">The Basics of Async/Await</h2>
<h2 id="understanding-asynchronous-code">Understanding Asynchronous Code</h2>
<p>Before we can test async code, we need to understand what makes it different from synchronous code. Asynchronous programming allows your program to handle multiple operations concurrently without blocking‚Äîparticularly useful for I/O-bound operations like network requests, database queries, or file operations.</p>
<h3 id="the-problem-async-solves">The Problem Async Solves</h3>
<p>Consider a function that fetches user data from an API:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">requests</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fetch_user_data</span><span class="p">(</span><span class="n">user_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Synchronous version - blocks while waiting for response&quot;&quot;&quot;</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;https://api.example.com/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_multiple_users</span><span class="p">(</span><span class="n">user_ids</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This takes 3 seconds if each request takes 1 second&quot;&quot;&quot;</span>
    <span class="n">users</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">user_id</span> <span class="ow">in</span> <span class="n">user_ids</span><span class="p">:</span>
        <span class="n">users</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fetch_user_data</span><span class="p">(</span><span class="n">user_id</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">users</span>

<span class="c1"># If we fetch 3 users, this takes ~3 seconds</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">users</span> <span class="o">=</span> <span class="n">get_multiple_users</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Each request waits for the previous one to complete. With async code, we can start all three requests simultaneously:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">aiohttp</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_user_data_async</span><span class="p">(</span><span class="n">user_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Async version - doesn&#39;t block while waiting&quot;&quot;&quot;</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;https://api.example.com/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">get_multiple_users_async</span><span class="p">(</span><span class="n">user_ids</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This takes ~1 second total - all requests run concurrently&quot;&quot;&quot;</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">fetch_user_data_async</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">user_id</span> <span class="ow">in</span> <span class="n">user_ids</span><span class="p">]</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

<span class="c1"># If we fetch 3 users, this takes ~1 second</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">users</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">get_multiple_users_async</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="the-core-async-keywords">The Core Async Keywords</h3>
<p><strong><code>async def</code></strong>: Declares a coroutine function. When called, it returns a coroutine object (not the result).</p>
<p><strong><code>await</code></strong>: Pauses execution of the current coroutine until the awaited operation completes. Can only be used inside <code>async def</code> functions.</p>
<p><strong><code>asyncio.run()</code></strong>: Runs a coroutine from synchronous code. This is the entry point to the async world.</p>
<h3 id="what-happens-under-the-hood">What Happens Under the Hood</h3>
<p>When you call an async function, it doesn't execute immediately:</p>
<div class="codehilite"><pre><span></span><code><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Hello, </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># This doesn&#39;t print &quot;Hello, Alice&quot; - it creates a coroutine object</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">greet</span><span class="p">(</span><span class="s2">&quot;Alice&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># &lt;coroutine object greet at 0x...&gt;</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>  <span class="c1"># &lt;class &#39;coroutine&#39;&gt;</span>
</code></pre></div>

<p>To actually execute it, you need an event loop:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Hello, </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># This actually executes the coroutine</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">greet</span><span class="p">(</span><span class="s2">&quot;Alice&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># Hello, Alice</span>
</code></pre></div>

<h3 id="the-event-loop-the-engine-of-async">The Event Loop: The Engine of Async</h3>
<p>The event loop is the mechanism that manages and executes async operations. Think of it as a task scheduler:</p>
<ol>
<li>You submit coroutines to the loop</li>
<li>The loop runs them, pausing at <code>await</code> points</li>
<li>When an awaited operation completes, the loop resumes the coroutine</li>
<li>The loop switches between coroutines, creating the illusion of concurrency</li>
</ol>
<p>Here's a visualization of how the event loop handles multiple operations:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">task_with_delay</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Starting&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>  <span class="c1"># Simulates I/O operation</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Finished after </span><span class="si">{</span><span class="n">delay</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> result&quot;</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Create three tasks that run concurrently</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">task_with_delay</span><span class="p">(</span><span class="s2">&quot;Task 1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">task_with_delay</span><span class="p">(</span><span class="s2">&quot;Task 2&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">task3</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">task_with_delay</span><span class="p">(</span><span class="s2">&quot;Task 3&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Wait for all tasks to complete</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">,</span> <span class="n">task3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>

<span class="c1"># Run the main coroutine</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All results: </span><span class="si">{</span><span class="n">results</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>Task 1: Starting
Task 2: Starting
Task 3: Starting
Task 2: Finished after 1s
Task 1: Finished after 2s
Task 3: Finished after 3s
All results: [&#39;Task 1 result&#39;, &#39;Task 2 result&#39;, &#39;Task 3 result&#39;]
</code></pre></div>

<p>Notice how all tasks start immediately, but finish in order of their delay times. The total execution time is ~3 seconds (the longest task), not 6 seconds (sum of all delays).</p>
<h3 id="our-reference-example-an-async-api-client">Our Reference Example: An Async API Client</h3>
<p>For this chapter, we'll build and test an async API client that fetches user data. This is a realistic scenario that demonstrates the key challenges of async testing:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># api_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">aiohttp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>

<span class="k">class</span><span class="w"> </span><span class="nc">UserAPIClient</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Async client for fetching user data from an API&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="n">base_url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fetch a single user by ID&quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_url</span><span class="si">}</span><span class="s2">/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">timeout</span><span class="o">=</span><span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientTimeout</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
                <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
                <span class="k">return</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_multiple_users</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fetch multiple users concurrently&quot;&quot;&quot;</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">user_id</span> <span class="ow">in</span> <span class="n">user_ids</span><span class="p">]</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">search_users</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Search for users by name&quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_url</span><span class="si">}</span><span class="s2">/users/search&quot;</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;q&quot;</span><span class="p">:</span> <span class="n">query</span><span class="p">},</span>
                <span class="n">timeout</span><span class="o">=</span><span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientTimeout</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
                <span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
                <span class="k">return</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
</code></pre></div>

<p>This client will be our anchor example throughout the chapter. We'll progressively discover the challenges of testing async code and learn the techniques to handle them.</p>
<h3 id="why-async-code-needs-special-testing-considerations">Why Async Code Needs Special Testing Considerations</h3>
<p>You might think: "Can't I just call my async functions in tests like normal functions?" Let's try:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_naive.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Naive attempt to test async code&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_api_client_naive.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_api_client_naive.py::test_fetch_user FAILED                         [100%]

=================================== FAILURES ===================================
______________________________ test_fetch_user _________________________________

    def test_fetch_user():
        &quot;&quot;&quot;Naive attempt to test async code&quot;&quot;&quot;
        client = UserAPIClient(&quot;https://api.example.com&quot;)
<span class="k">&gt; </span><span class="ge">      user = client.fetch_user(1)</span>
E       TypeError: object Dict can&#39;t be used in &#39;await&#39; expression

test_api_client_naive.py:5: TypeError

During handling of the above exception, another exception occurred:

    def test_fetch_user():
        &quot;&quot;&quot;Naive attempt to test async code&quot;&quot;&quot;
        client = UserAPIClient(&quot;https://api.example.com&quot;)
        user = client.fetch_user(1)
<span class="k">&gt; </span><span class="ge">      assert user[&quot;id&quot;] == 1</span>
E       TypeError: &#39;coroutine&#39; object is not subscriptable

test_api_client_naive.py:6: TypeError
=========================== 1 failed in 0.12s ==================================
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure">Diagnostic Analysis: Reading the Failure</h3>
<p><strong>The complete output shows two problems</strong>:</p>
<ol>
<li><strong>First error</strong>: <code>TypeError: object Dict can't be used in 'await' expression</code></li>
<li>
<p>This is a red herring from the type hint system</p>
</li>
<li>
<p><strong>Second error</strong>: <code>TypeError: 'coroutine' object is not subscriptable</code></p>
</li>
<li>This is the real problem</li>
<li><code>user</code> is not a dictionary‚Äîit's a coroutine object</li>
<li>We tried to access <code>user["id"]</code> on a coroutine, which doesn't support subscripting</li>
</ol>
<p><strong>Root cause identified</strong>: We called an async function (<code>fetch_user</code>) from synchronous code without awaiting it. The function returned a coroutine object instead of executing.</p>
<p><strong>Why the current approach can't solve this</strong>: Regular test functions are synchronous. They can't use <code>await</code>. We need a way to run async code within our tests.</p>
<p><strong>What we need</strong>: A mechanism to execute async test functions within an event loop‚Äîthis is what <code>pytest-asyncio</code> provides.</p>
<p>This failure demonstrates the fundamental challenge of async testing: <strong>async code requires an event loop to execute, but regular test functions don't provide one</strong>. In the next section, we'll learn how to properly test async code using pytest-asyncio.</p>
<h2 id="testing-coroutines-with-pytest-asyncio">Testing Coroutines with pytest-asyncio</h2>
<h2 id="installing-pytest-asyncio">Installing pytest-asyncio</h2>
<p>The <code>pytest-asyncio</code> plugin extends pytest to support async test functions. Install it:</p>
<div class="codehilite"><pre><span></span><code>pip<span class="w"> </span>install<span class="w"> </span>pytest-asyncio
</code></pre></div>

<h3 id="iteration-1-making-our-test-async">Iteration 1: Making Our Test Async</h3>
<p><strong>Current state recap</strong>: Our naive test failed because we called an async function from synchronous code without an event loop.</p>
<p><strong>The solution</strong>: Use <code>pytest-asyncio</code> to mark our test function as async. This tells pytest to run it within an event loop.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_v1.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;First working async test&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p><strong>Key changes</strong>:
1. Added <code>@pytest.mark.asyncio</code> decorator
2. Changed <code>def</code> to <code>async def</code>
3. Added <code>await</code> before <code>client.fetch_user(1)</code></p>
<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_api_client_v1.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Output</strong> (assuming the API is available):</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_api_client_v1.py::test_fetch_user PASSED                            [100%]

============================== 1 passed in 0.45s ===============================
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: The test now executes the async function properly. The coroutine runs within an event loop provided by pytest-asyncio, and we get the actual user data instead of a coroutine object.</p>
<p><strong>Current limitation</strong>: This test makes a real HTTP request to an external API. This is slow, unreliable (network issues), and not suitable for unit testing. We need to mock the HTTP calls.</p>
<h3 id="how-pytest-asyncio-works">How pytest-asyncio Works</h3>
<p>When pytest encounters a test marked with <code>@pytest.mark.asyncio</code>, it:</p>
<ol>
<li>Creates an event loop for that test</li>
<li>Submits the test coroutine to the loop</li>
<li>Runs the loop until the test completes</li>
<li>Cleans up the loop</li>
</ol>
<p>You can see this in action by examining the event loop:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_event_loop_exists</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that an event loop is running&quot;&quot;&quot;</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">loop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="n">loop</span><span class="o">.</span><span class="n">is_running</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Event loop: </span><span class="si">{</span><span class="n">loop</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="testing-multiple-async-operations">Testing Multiple Async Operations</h3>
<p>Our <code>UserAPIClient</code> has a method that fetches multiple users concurrently. Let's test it:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_v2.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_multiple_users</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test concurrent user fetching&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="n">user_ids</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">users</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_multiple_users</span><span class="p">(</span><span class="n">user_ids</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="n">users</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">users</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">users</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
</code></pre></div>

<p>This test verifies that:
1. All three users are fetched
2. They're returned in the correct order
3. Each user has the expected ID</p>
<p><strong>Current limitation</strong>: We're still making real HTTP requests. Before we can write reliable tests, we need to mock the network calls. But first, let's understand how to configure pytest-asyncio.</p>
<h3 id="configuring-pytest-asyncio">Configuring pytest-asyncio</h3>
<p>By default, pytest-asyncio requires the <code>@pytest.mark.asyncio</code> decorator on every async test. You can change this behavior in your pytest configuration:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># pytest.ini</span>
<span class="k">[pytest]</span>
<span class="na">asyncio_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">auto</span>
</code></pre></div>

<p>With <code>asyncio_mode = auto</code>, pytest automatically detects async test functions without requiring the decorator:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_auto.py</span>
<span class="c1"># No @pytest.mark.asyncio needed with asyncio_mode = auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Async test without explicit marker&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p><strong>When to use <code>asyncio_mode = auto</code></strong>:
- <strong>Use it when</strong>: Your project is heavily async and most tests are async
- <strong>Avoid it when</strong>: You have a mix of sync and async tests and want explicit marking for clarity
- <strong>Trade-off</strong>: Convenience vs. explicitness</p>
<h3 id="common-failure-mode-forgetting-await">Common Failure Mode: Forgetting await</h3>
<p>Let's see what happens if we forget to <code>await</code> an async call:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_missing_await.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_missing_await</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;What happens when we forget await?&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Missing await!</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_api_client_missing_await.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="o">=============================</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">session</span><span class="w"> </span><span class="n">starts</span><span class="w"> </span><span class="o">==============================</span>
<span class="n">collected</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">item</span>

<span class="n">test_api_client_missing_await</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_fetch_user_missing_await</span><span class="w"> </span><span class="n">FAILED</span><span class="w">   </span><span class="o">[</span><span class="n">100%</span><span class="o">]</span>

<span class="o">===================================</span><span class="w"> </span><span class="n">FAILURES</span><span class="w"> </span><span class="o">===================================</span>
<span class="n">______________________</span><span class="w"> </span><span class="n">test_fetch_user_missing_await</span><span class="w"> </span><span class="n">___________________________</span>

<span class="w">    </span><span class="nv">@pytest</span><span class="p">.</span><span class="n">mark</span><span class="p">.</span><span class="n">asyncio</span>
<span class="w">    </span><span class="n">async</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">test_fetch_user_missing_await</span><span class="p">()</span><span class="err">:</span>
<span class="w">        </span><span class="ss">&quot;&quot;&quot;What happens when we forget await?&quot;&quot;&quot;</span>
<span class="w">        </span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UserAPIClient</span><span class="p">(</span><span class="ss">&quot;https://api.example.com&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="k">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">Missing</span><span class="w"> </span><span class="n">await</span><span class="err">!</span>
<span class="o">&gt;</span><span class="w">       </span><span class="n">assert</span><span class="w"> </span><span class="k">user</span><span class="o">[</span><span class="n">&quot;id&quot;</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
<span class="n">E</span><span class="w">       </span><span class="nl">TypeError</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;coroutine&#39;</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">subscriptable</span>

<span class="n">test_api_client_missing_await</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="mi">8</span><span class="err">:</span><span class="w"> </span><span class="n">TypeError</span>
<span class="c1">----------------------------- Captured warnings --------------------------------</span>
<span class="n">test_api_client_missing_await</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_fetch_user_missing_await</span>
<span class="w">  </span><span class="nl">RuntimeWarning</span><span class="p">:</span><span class="w"> </span><span class="n">coroutine</span><span class="w"> </span><span class="s1">&#39;UserAPIClient.fetch_user&#39;</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">never</span><span class="w"> </span><span class="n">awaited</span>
<span class="w">    </span><span class="k">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">Missing</span><span class="w"> </span><span class="n">await</span><span class="err">!</span>

<span class="o">===========================</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mf">0.12</span><span class="n">s</span><span class="w"> </span><span class="o">==================================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-missing-await">Diagnostic Analysis: Missing await</h3>
<p><strong>The complete output reveals</strong>:</p>
<ol>
<li><strong>The error</strong>: <code>TypeError: 'coroutine' object is not subscriptable</code></li>
<li>Same error as our first naive attempt</li>
<li>
<p><code>user</code> is a coroutine, not a dictionary</p>
</li>
<li>
<p><strong>The warning</strong>: <code>RuntimeWarning: coroutine 'UserAPIClient.fetch_user' was never awaited</code></p>
</li>
<li>This is the key diagnostic clue</li>
<li>Python detected that we created a coroutine but never executed it</li>
</ol>
<p><strong>Root cause identified</strong>: Even though our test function is async, we forgot to <code>await</code> the async call. The coroutine was created but never executed.</p>
<p><strong>Solution</strong>: Always <code>await</code> async function calls. Modern IDEs and linters (like pylint with the <code>await-outside-async</code> check) can catch this error.</p>
<h3 id="testing-async-context-managers">Testing Async Context Managers</h3>
<p>Our <code>UserAPIClient</code> uses <code>async with</code> for session management. Let's test code that uses async context managers:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># async_file_handler.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">aiofiles</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AsyncFileHandler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Handles async file operations&quot;&quot;&quot;</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">read_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read all lines from a file asynchronously&quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">aiofiles</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">contents</span> <span class="o">=</span> <span class="k">await</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">contents</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">write_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write lines to a file asynchronously&quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">aiofiles</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
</code></pre></div>

<p>Testing this requires the same pattern:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_async_file_handler.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">async_file_handler</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncFileHandler</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_read_write_lines</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test async file operations&quot;&quot;&quot;</span>
    <span class="n">handler</span> <span class="o">=</span> <span class="n">AsyncFileHandler</span><span class="p">()</span>

    <span class="c1"># Create a temporary file</span>
    <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">temp_path</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Write lines</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Line 1&quot;</span><span class="p">,</span> <span class="s2">&quot;Line 2&quot;</span><span class="p">,</span> <span class="s2">&quot;Line 3&quot;</span><span class="p">]</span>
        <span class="k">await</span> <span class="n">handler</span><span class="o">.</span><span class="n">write_lines</span><span class="p">(</span><span class="n">temp_path</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>

        <span class="c1"># Read them back</span>
        <span class="n">read_lines</span> <span class="o">=</span> <span class="k">await</span> <span class="n">handler</span><span class="o">.</span><span class="n">read_lines</span><span class="p">(</span><span class="n">temp_path</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">read_lines</span> <span class="o">==</span> <span class="n">lines</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Clean up</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">temp_path</span><span class="p">)</span>
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: The test successfully exercises async context managers. The <code>async with</code> statements work correctly within our async test function.</p>
<p><strong>Current limitation</strong>: We're using manual cleanup with try/finally. In the next section, we'll learn how to use async fixtures to handle setup and teardown more elegantly.</p>
<h3 id="the-journey-so-far">The Journey So Far</h3>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Problem</th>
<th>Solution</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Calling async from sync code</td>
<td>None</td>
<td>TypeError: coroutine</td>
</tr>
<tr>
<td>1</td>
<td>Need event loop for async tests</td>
<td>@pytest.mark.asyncio</td>
<td>Tests execute properly</td>
</tr>
<tr>
<td>2</td>
<td>Forgot to await</td>
<td>Always await async calls</td>
<td>Caught by runtime warning</td>
</tr>
<tr>
<td>3</td>
<td>Manual cleanup in async tests</td>
<td>Need async fixtures</td>
<td>Works but verbose</td>
</tr>
</tbody>
</table>
<p>In the next section, we'll learn how to use async fixtures to handle setup and teardown, making our tests cleaner and more maintainable.</p>
<h2 id="fixtures-for-async-tests">Fixtures for Async Tests</h2>
<h2 id="the-problem-with-synchronous-fixtures">The Problem with Synchronous Fixtures</h2>
<p>Let's try to use a regular fixture to set up our API client:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_sync_fixture.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">api_client</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Synchronous fixture for API client&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">client</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_with_fixture</span><span class="p">(</span><span class="n">api_client</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Using a sync fixture in an async test&quot;&quot;&quot;</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">api_client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>This works fine for simple setup. But what if our fixture needs to perform async operations? For example, what if we need to authenticate the client or set up a database connection?</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># api_client_with_auth.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">aiohttp</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AuthenticatedAPIClient</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;API client that requires async authentication&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_url</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="n">base_url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">authenticate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">password</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Authenticate and get access token&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_url</span><span class="si">}</span><span class="s2">/auth/login&quot;</span><span class="p">,</span>
            <span class="n">json</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="n">username</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="n">password</span><span class="p">}</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;access_token&quot;</span><span class="p">]</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fetch user with authentication&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Client not authenticated&quot;</span><span class="p">)</span>

        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_url</span><span class="si">}</span><span class="s2">/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">headers</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Authorization&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Bearer </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">token</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean up session&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>

<p>Now let's try to create a fixture that sets up this authenticated client:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_authenticated_client_broken.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client_with_auth</span><span class="w"> </span><span class="kn">import</span> <span class="n">AuthenticatedAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">authenticated_client</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Broken: trying to do async work in sync fixture&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">AuthenticatedAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="c1"># This won&#39;t work - can&#39;t await in a sync function!</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;testuser&quot;</span><span class="p">,</span> <span class="s2">&quot;testpass&quot;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">client</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_authenticated</span><span class="p">(</span><span class="n">authenticated_client</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">authenticated_client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_authenticated_client_broken.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="o">=============================</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">session</span><span class="w"> </span><span class="n">starts</span><span class="w"> </span><span class="o">==============================</span>
<span class="n">collected</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">item</span>

<span class="n">test_authenticated_client_broken</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_fetch_user_authenticated</span><span class="w"> </span><span class="n">ERROR</span><span class="w"> </span><span class="o">[</span><span class="n">100%</span><span class="o">]</span>

<span class="o">====================================</span><span class="w"> </span><span class="n">ERRORS</span><span class="w"> </span><span class="o">====================================</span>
<span class="n">_____________</span><span class="w"> </span><span class="n">ERROR</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">setup</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">test_fetch_user_authenticated</span><span class="w"> </span><span class="n">__________________</span>

<span class="w">    </span><span class="nv">@pytest</span><span class="p">.</span><span class="n">fixture</span>
<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">authenticated_client</span><span class="p">()</span><span class="err">:</span>
<span class="w">        </span><span class="ss">&quot;&quot;&quot;Broken: trying to do async work in sync fixture&quot;&quot;&quot;</span>
<span class="w">        </span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AuthenticatedAPIClient</span><span class="p">(</span><span class="ss">&quot;https://api.example.com&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">won</span><span class="s1">&#39;t work - can&#39;</span><span class="n">t</span><span class="w"> </span><span class="n">await</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">sync</span><span class="w"> </span><span class="k">function</span><span class="err">!</span>
<span class="o">&gt;</span><span class="w">       </span><span class="n">await</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">authenticate</span><span class="p">(</span><span class="ss">&quot;testuser&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;testpass&quot;</span><span class="p">)</span>
<span class="n">E</span><span class="w">       </span><span class="nl">SyntaxError</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;await&#39;</span><span class="w"> </span><span class="n">outside</span><span class="w"> </span><span class="n">async</span><span class="w"> </span><span class="k">function</span>

<span class="n">test_authenticated_client_broken</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="mi">7</span><span class="err">:</span><span class="w"> </span><span class="n">SyntaxError</span>
<span class="o">===========================</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mf">0.12</span><span class="n">s</span><span class="w"> </span><span class="o">==================================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-async-work-in-sync-fixture">Diagnostic Analysis: Async Work in Sync Fixture</h3>
<p><strong>The error</strong>: <code>SyntaxError: 'await' outside async function</code></p>
<p><strong>What this tells us</strong>: 
- We tried to use <code>await</code> in a regular (synchronous) fixture
- Python's syntax rules forbid <code>await</code> outside <code>async def</code> functions
- The fixture needs to be async to perform async operations</p>
<p><strong>Root cause identified</strong>: Regular fixtures are synchronous functions. They can't perform async operations like authentication or database setup.</p>
<p><strong>What we need</strong>: Async fixtures that can use <code>await</code> and run within an event loop.</p>
<h3 id="iteration-1-creating-async-fixtures">Iteration 1: Creating Async Fixtures</h3>
<p><strong>The solution</strong>: Use <code>async def</code> for fixtures that need to perform async operations:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_authenticated_client_v1.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client_with_auth</span><span class="w"> </span><span class="kn">import</span> <span class="n">AuthenticatedAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">authenticated_client</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Async fixture for authenticated client&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">AuthenticatedAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;testuser&quot;</span><span class="p">,</span> <span class="s2">&quot;testpass&quot;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">client</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_authenticated</span><span class="p">(</span><span class="n">authenticated_client</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test using async fixture&quot;&quot;&quot;</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">authenticated_client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p><strong>Key changes</strong>:
1. Changed <code>def</code> to <code>async def</code> for the fixture
2. Can now use <code>await</code> for authentication
3. Can use <code>await</code> for cleanup in teardown</p>
<p><strong>Expected vs. Actual improvement</strong>: The fixture now properly authenticates the client before the test runs and cleans up afterward. Both setup and teardown can perform async operations.</p>
<p><strong>Current limitation</strong>: This still makes real HTTP requests. We need to mock the authentication and API calls for reliable testing.</p>
<h3 id="async-fixture-scopes">Async Fixture Scopes</h3>
<p>Just like regular fixtures, async fixtures support different scopes:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_fixture_scopes.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;function&quot;</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">function_scoped_resource</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Created and destroyed for each test&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Setting up function-scoped resource&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># Simulate async setup</span>
    <span class="k">yield</span> <span class="s2">&quot;function-resource&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tearing down function-scoped resource&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># Simulate async cleanup</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">module_scoped_resource</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Created once per module, shared across tests&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Setting up module-scoped resource&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">yield</span> <span class="s2">&quot;module-resource&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tearing down module-scoped resource&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_one</span><span class="p">(</span><span class="n">function_scoped_resource</span><span class="p">,</span> <span class="n">module_scoped_resource</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Test one: </span><span class="si">{</span><span class="n">function_scoped_resource</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">module_scoped_resource</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="kc">True</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_two</span><span class="p">(</span><span class="n">function_scoped_resource</span><span class="p">,</span> <span class="n">module_scoped_resource</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Test two: </span><span class="si">{</span><span class="n">function_scoped_resource</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">module_scoped_resource</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="kc">True</span>
</code></pre></div>

<p>Run with verbose output to see the fixture lifecycle:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_fixture_scopes.py<span class="w"> </span>-v<span class="w"> </span>-s
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 2 items

test_fixture_scopes.py::test_one 
Setting up module-scoped resource

Setting up function-scoped resource

Test one: function-resource, module-resource
PASSED
Tearing down function-scoped resource

test_fixture_scopes.py::test_two 
Setting up function-scoped resource

Test two: function-resource, module-resource
PASSED
Tearing down function-scoped resource

Tearing down module-scoped resource

============================== 2 passed in 0.45s ===============================
</code></pre></div>

<p>Notice how:
- Module-scoped fixture sets up once before all tests
- Function-scoped fixture sets up/tears down for each test
- Module-scoped fixture tears down after all tests complete</p>
<h3 id="async-fixture-composition">Async Fixture Composition</h3>
<p>Async fixtures can depend on other fixtures (both sync and async):</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_fixture_composition.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client_with_auth</span><span class="w"> </span><span class="kn">import</span> <span class="n">AuthenticatedAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">api_base_url</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sync fixture providing configuration&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;https://api.example.com&quot;</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_credentials</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sync fixture providing test credentials&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;testuser&quot;</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="s2">&quot;testpass&quot;</span><span class="p">}</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">authenticated_client</span><span class="p">(</span><span class="n">api_base_url</span><span class="p">,</span> <span class="n">test_credentials</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Async fixture depending on sync fixtures&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">AuthenticatedAPIClient</span><span class="p">(</span><span class="n">api_base_url</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span>
        <span class="n">test_credentials</span><span class="p">[</span><span class="s2">&quot;username&quot;</span><span class="p">],</span>
        <span class="n">test_credentials</span><span class="p">[</span><span class="s2">&quot;password&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">yield</span> <span class="n">client</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">user_data</span><span class="p">(</span><span class="n">authenticated_client</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Async fixture depending on another async fixture&quot;&quot;&quot;</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">authenticated_client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">user</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_user_has_email</span><span class="p">(</span><span class="n">user_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test using composed async fixtures&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="s2">&quot;email&quot;</span> <span class="ow">in</span> <span class="n">user_data</span>
    <span class="k">assert</span> <span class="s2">&quot;@&quot;</span> <span class="ow">in</span> <span class="n">user_data</span><span class="p">[</span><span class="s2">&quot;email&quot;</span><span class="p">]</span>
</code></pre></div>

<p><strong>Fixture dependency chain</strong>:</p>
<div class="codehilite"><pre><span></span><code>api_base_url (sync) ‚îÄ‚îÄ‚îê
                      ‚îú‚îÄ‚îÄ&gt; authenticated_client (async) ‚îÄ‚îÄ&gt; user_data (async) ‚îÄ‚îÄ&gt; test
test_credentials (sync)‚îò
</code></pre></div>

<h3 id="iteration-2-async-fixtures-with-cleanup-guarantees">Iteration 2: Async Fixtures with Cleanup Guarantees</h3>
<p><strong>Current state recap</strong>: Our async fixtures work, but what happens if the test fails or raises an exception? We need to ensure cleanup always happens.</p>
<p><strong>The pattern</strong>: Use try/finally in async fixtures for guaranteed cleanup:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_fixture_cleanup.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client_with_auth</span><span class="w"> </span><span class="kn">import</span> <span class="n">AuthenticatedAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">authenticated_client_safe</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Async fixture with guaranteed cleanup&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">AuthenticatedAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;testuser&quot;</span><span class="p">,</span> <span class="s2">&quot;testpass&quot;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">client</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># This always runs, even if test fails</span>
        <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cleanup completed&quot;</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_that_fails</span><span class="p">(</span><span class="n">authenticated_client_safe</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that fails but still cleans up&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">authenticated_client_safe</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Intentional failure&quot;</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_fixture_cleanup.py<span class="w"> </span>-v<span class="w"> </span>-s
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="o">=============================</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">session</span><span class="w"> </span><span class="n">starts</span><span class="w"> </span><span class="o">==============================</span>
<span class="n">collected</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">item</span>

<span class="n">test_fixture_cleanup</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_that_fails</span><span class="w"> </span><span class="n">FAILED</span><span class="w">                          </span><span class="o">[</span><span class="n">100%</span><span class="o">]</span>

<span class="n">Cleanup</span><span class="w"> </span><span class="n">completed</span>

<span class="o">===================================</span><span class="w"> </span><span class="n">FAILURES</span><span class="w"> </span><span class="o">===================================</span>
<span class="n">______________________________</span><span class="w"> </span><span class="n">test_that_fails</span><span class="w"> </span><span class="n">_________________________________</span>

<span class="n">authenticated_client_safe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">api_client_with_auth</span><span class="p">.</span><span class="n">AuthenticatedAPIClient</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="mi">0</span><span class="n">x</span><span class="p">...</span><span class="o">&gt;</span>

<span class="w">    </span><span class="nv">@pytest</span><span class="p">.</span><span class="n">mark</span><span class="p">.</span><span class="n">asyncio</span>
<span class="w">    </span><span class="n">async</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">test_that_fails</span><span class="p">(</span><span class="n">authenticated_client_safe</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="ss">&quot;&quot;&quot;Test that fails but still cleans up&quot;&quot;&quot;</span>
<span class="w">        </span><span class="n">await</span><span class="w"> </span><span class="n">authenticated_client_safe</span><span class="p">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;</span><span class="w">       </span><span class="n">assert</span><span class="w"> </span><span class="k">False</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;Intentional failure&quot;</span>
<span class="n">E</span><span class="w">       </span><span class="nl">AssertionError</span><span class="p">:</span><span class="w"> </span><span class="n">Intentional</span><span class="w"> </span><span class="n">failure</span>

<span class="n">test_fixture_cleanup</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="mi">18</span><span class="err">:</span><span class="w"> </span><span class="n">AssertionError</span>
<span class="o">===========================</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mf">0.45</span><span class="n">s</span><span class="w"> </span><span class="o">==================================</span>
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: Even though the test failed, the cleanup code ran. The "Cleanup completed" message appears before the failure report, proving the <code>finally</code> block executed.</p>
<h3 id="async-fixtures-in-conftestpy">Async Fixtures in conftest.py</h3>
<p>Just like regular fixtures, async fixtures can be shared across test files using <code>conftest.py</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># conftest.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client_with_auth</span><span class="w"> </span><span class="kn">import</span> <span class="n">AuthenticatedAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;session&quot;</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">api_base_url</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Session-scoped configuration&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;https://api.example.com&quot;</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">authenticated_client</span><span class="p">(</span><span class="n">api_base_url</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Module-scoped authenticated client&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">AuthenticatedAPIClient</span><span class="p">(</span><span class="n">api_base_url</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;testuser&quot;</span><span class="p">,</span> <span class="s2">&quot;testpass&quot;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">client</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>

<p>Now any test file can use these fixtures:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_users.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user</span><span class="p">(</span><span class="n">authenticated_client</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">authenticated_client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>

<span class="c1"># test_search.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_search_users</span><span class="p">(</span><span class="n">authenticated_client</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">authenticated_client</span><span class="o">.</span><span class="n">search_users</span><span class="p">(</span><span class="s2">&quot;john&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
</code></pre></div>

<h3 id="common-failure-mode-mixing-sync-and-async-incorrectly">Common Failure Mode: Mixing Sync and Async Incorrectly</h3>
<p>What happens if we try to use an async fixture in a sync test?</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_mixed_incorrectly.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client_with_auth</span><span class="w"> </span><span class="kn">import</span> <span class="n">AuthenticatedAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">authenticated_client</span><span class="p">():</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">AuthenticatedAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">authenticate</span><span class="p">(</span><span class="s2">&quot;testuser&quot;</span><span class="p">,</span> <span class="s2">&quot;testpass&quot;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">client</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sync_using_async_fixture</span><span class="p">(</span><span class="n">authenticated_client</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sync test trying to use async fixture&quot;&quot;&quot;</span>
    <span class="c1"># This won&#39;t work!</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">authenticated_client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_mixed_incorrectly.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="o">=============================</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">session</span><span class="w"> </span><span class="n">starts</span><span class="w"> </span><span class="o">==============================</span>
<span class="n">collected</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">item</span>

<span class="n">test_mixed_incorrectly</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_sync_using_async_fixture</span><span class="w"> </span><span class="n">ERROR</span><span class="w">           </span><span class="o">[</span><span class="n">100%</span><span class="o">]</span>

<span class="o">====================================</span><span class="w"> </span><span class="n">ERRORS</span><span class="w"> </span><span class="o">====================================</span>
<span class="n">____________</span><span class="w"> </span><span class="n">ERROR</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">setup</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">test_sync_using_async_fixture</span><span class="w"> </span><span class="n">___________________</span>

<span class="k">file</span><span class="w"> </span><span class="n">test_mixed_incorrectly</span><span class="p">.</span><span class="n">py</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">10</span>
<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">test_sync_using_async_fixture</span><span class="p">(</span><span class="n">authenticated_client</span><span class="p">)</span><span class="err">:</span>
<span class="n">E</span><span class="w">       </span><span class="n">fixture</span><span class="w"> </span><span class="s1">&#39;authenticated_client&#39;</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="k">found</span>
<span class="o">&gt;</span><span class="w">       </span><span class="n">available</span><span class="w"> </span><span class="nl">fixtures</span><span class="p">:</span><span class="w"> </span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">capfd</span><span class="p">,</span><span class="w"> </span><span class="n">capfdbinary</span><span class="p">,</span><span class="w"> </span><span class="n">caplog</span><span class="p">,</span><span class="w"> </span><span class="n">capsys</span><span class="p">,</span><span class="w"> </span><span class="n">capsysbinary</span><span class="p">,</span><span class="w"> </span><span class="p">...</span>
<span class="o">&gt;</span><span class="w">       </span><span class="k">use</span><span class="w"> </span><span class="s1">&#39;pytest --fixtures [testpath]&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">help</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">them</span><span class="p">.</span>

<span class="n">test_mixed_incorrectly</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="mi">10</span>
<span class="o">===========================</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mf">0.12</span><span class="n">s</span><span class="w"> </span><span class="o">==================================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-async-fixture-in-sync-test">Diagnostic Analysis: Async Fixture in Sync Test</h3>
<p><strong>The error</strong>: <code>fixture 'authenticated_client' not found</code></p>
<p><strong>What this tells us</strong>:
- Pytest can't find the fixture, even though it's defined
- The fixture exists but isn't available to this test
- This is because async fixtures can only be used in async tests</p>
<p><strong>Root cause identified</strong>: Async fixtures require an event loop to execute. Synchronous tests don't have an event loop, so pytest can't inject async fixtures into them.</p>
<p><strong>Solution</strong>: Either make the test async, or make the fixture sync (if it doesn't need async operations).</p>
<h3 id="the-journey-async-fixtures">The Journey: Async Fixtures</h3>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Problem</th>
<th>Solution</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Async work in sync fixture</td>
<td>None</td>
<td>SyntaxError</td>
</tr>
<tr>
<td>1</td>
<td>Need async setup/teardown</td>
<td>async def fixture</td>
<td>Can await in fixtures</td>
</tr>
<tr>
<td>2</td>
<td>Cleanup not guaranteed on failure</td>
<td>try/finally in fixture</td>
<td>Cleanup always runs</td>
</tr>
<tr>
<td>3</td>
<td>Async fixture in sync test</td>
<td>Make test async or fixture sync</td>
<td>Proper fixture availability</td>
</tr>
</tbody>
</table>
<h3 id="decision-framework-when-to-use-async-fixtures">Decision Framework: When to Use Async Fixtures</h3>
<p><strong>Use async fixtures when</strong>:
- Setup/teardown requires async operations (API calls, database connections, file I/O)
- The fixture provides an async resource (client, connection, session)
- The fixture is used exclusively by async tests</p>
<p><strong>Use sync fixtures when</strong>:
- Setup/teardown is purely synchronous (configuration, simple object creation)
- The fixture needs to be available to both sync and async tests
- The fixture provides configuration or test data</p>
<p><strong>Code characteristics</strong>:
- <strong>Async fixture</strong>: Requires event loop, can only be used in async tests, supports async context managers
- <strong>Sync fixture</strong>: No event loop needed, works in any test, simpler but limited to sync operations</p>
<p>In the next section, we'll learn how to mock async functions, which will allow us to test our async code without making real network requests.</p>
<h2 id="mocking-async-functions">Mocking Async Functions</h2>
<h2 id="the-challenge-of-mocking-async-code">The Challenge of Mocking Async Code</h2>
<p>Our tests so far have been making real HTTP requests. This is problematic:
- <strong>Slow</strong>: Network requests take time
- <strong>Unreliable</strong>: Network failures, API downtime
- <strong>Not isolated</strong>: Tests depend on external services
- <strong>Not repeatable</strong>: API responses might change</p>
<p>Let's try to mock our async API client using standard mocking techniques:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_mock_broken.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mock</span><span class="p">,</span> <span class="n">patch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_mocked_broken</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Naive attempt to mock async function&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;aiohttp.ClientSession.get&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_get</span><span class="p">:</span>
        <span class="c1"># Set up mock response</span>
        <span class="n">mock_response</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">}</span>
        <span class="n">mock_get</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="fm">__aenter__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">mock_response</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_api_client_mock_broken.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="o">=============================</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">session</span><span class="w"> </span><span class="n">starts</span><span class="w"> </span><span class="o">==============================</span>
<span class="n">collected</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">item</span>

<span class="n">test_api_client_mock_broken</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_fetch_user_mocked_broken</span><span class="w"> </span><span class="n">FAILED</span><span class="w">     </span><span class="o">[</span><span class="n">100%</span><span class="o">]</span>

<span class="o">===================================</span><span class="w"> </span><span class="n">FAILURES</span><span class="w"> </span><span class="o">===================================</span>
<span class="n">____________________</span><span class="w"> </span><span class="n">test_fetch_user_mocked_broken</span><span class="w"> </span><span class="n">_____________________________</span>

<span class="w">    </span><span class="nv">@pytest</span><span class="p">.</span><span class="n">mark</span><span class="p">.</span><span class="n">asyncio</span>
<span class="w">    </span><span class="n">async</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">test_fetch_user_mocked_broken</span><span class="p">()</span><span class="err">:</span>
<span class="w">        </span><span class="ss">&quot;&quot;&quot;Naive attempt to mock async function&quot;&quot;&quot;</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">patch</span><span class="p">(</span><span class="s1">&#39;aiohttp.ClientSession.get&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nl">mock_get</span><span class="p">:</span>
<span class="w">            </span><span class="err">#</span><span class="w"> </span><span class="k">Set</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">mock</span><span class="w"> </span><span class="n">response</span>
<span class="w">            </span><span class="n">mock_response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mock</span><span class="p">()</span>
<span class="w">            </span><span class="n">mock_response</span><span class="p">.</span><span class="n">json</span><span class="p">.</span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="ss">&quot;id&quot;</span><span class="err">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;name&quot;</span><span class="err">:</span><span class="w"> </span><span class="ss">&quot;Alice&quot;</span><span class="err">}</span>
<span class="w">            </span><span class="n">mock_get</span><span class="p">.</span><span class="n">return_value</span><span class="p">.</span><span class="n">__aenter__</span><span class="p">.</span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mock_response</span>

<span class="w">            </span><span class="n">client</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UserAPIClient</span><span class="p">(</span><span class="ss">&quot;https://api.example.com&quot;</span><span class="p">)</span>
<span class="o">&gt;</span><span class="w">           </span><span class="k">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">await</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">test_api_client_mock_broken</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="mi">14</span><span class="err">:</span><span class="w"> </span>
<span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="n">_</span>
<span class="n">api_client</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="mi">12</span><span class="err">:</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">fetch_user</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">await</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="n">json</span><span class="p">()</span>
<span class="n">E</span><span class="w">   </span><span class="nl">TypeError</span><span class="p">:</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="n">dict</span><span class="w"> </span><span class="n">can</span><span class="s1">&#39;t be used in &#39;</span><span class="n">await</span><span class="err">&#39;</span><span class="w"> </span><span class="n">expression</span>

<span class="o">===========================</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mf">0.12</span><span class="n">s</span><span class="w"> </span><span class="o">==================================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-mocking-async-methods">Diagnostic Analysis: Mocking Async Methods</h3>
<p><strong>The error</strong>: <code>TypeError: object dict can't be used in 'await' expression</code></p>
<p><strong>What this tells us</strong>:
- The code tried to <code>await response.json()</code>
- But <code>response.json()</code> returned a dictionary directly, not a coroutine
- The mock's <code>json()</code> method is synchronous, but the real method is async</p>
<p><strong>Root cause identified</strong>: Regular <code>Mock</code> objects return synchronous values. When we mock an async method, we need the mock to return a coroutine that can be awaited.</p>
<p><strong>What we need</strong>: A way to make mock methods return coroutines instead of direct values.</p>
<h3 id="iteration-1-using-asyncmock">Iteration 1: Using AsyncMock</h3>
<p><strong>The solution</strong>: Python 3.8+ provides <code>AsyncMock</code> specifically for mocking async functions:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_mock_v1.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncMock</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_mocked</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Properly mocking async function&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;aiohttp.ClientSession.get&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_get</span><span class="p">:</span>
        <span class="c1"># Create async mock for response</span>
        <span class="n">mock_response</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">json</span> <span class="o">=</span> <span class="n">AsyncMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">})</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">raise_for_status</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>

        <span class="c1"># Set up context manager</span>
        <span class="n">mock_get</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="fm">__aenter__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">mock_response</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alice&quot;</span>
        <span class="n">mock_get</span><span class="o">.</span><span class="n">assert_called_once</span><span class="p">()</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_api_client_mock_v1.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_api_client_mock_v1.py::test_fetch_user_mocked PASSED                [100%]

============================== 1 passed in 0.12s ===============================
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: The test now passes without making real HTTP requests. The <code>AsyncMock</code> properly returns a coroutine that can be awaited.</p>
<p><strong>Key changes</strong>:
1. Used <code>AsyncMock</code> for the <code>json()</code> method
2. The mock now returns a coroutine when called
3. The <code>await response.json()</code> works correctly</p>
<h3 id="understanding-asyncmock">Understanding AsyncMock</h3>
<p><code>AsyncMock</code> is a special mock that returns a coroutine when called:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_async_mock_behavior.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncMock</span><span class="p">,</span> <span class="n">Mock</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_async_mock_vs_regular_mock</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate the difference between Mock and AsyncMock&quot;&quot;&quot;</span>

    <span class="c1"># Regular Mock returns the value directly</span>
    <span class="n">regular_mock</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">regular_mock</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">42</span>

    <span class="c1"># AsyncMock returns a coroutine</span>
    <span class="n">async_mock</span> <span class="o">=</span> <span class="n">AsyncMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">coroutine</span> <span class="o">=</span> <span class="n">async_mock</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">iscoroutine</span><span class="p">(</span><span class="n">coroutine</span><span class="p">)</span>

    <span class="c1"># You must await the coroutine to get the value</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">coroutine</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">42</span>
</code></pre></div>

<h3 id="iteration-2-mocking-async-context-managers">Iteration 2: Mocking Async Context Managers</h3>
<p><strong>Current state recap</strong>: We can mock async methods, but our API client uses <code>async with</code> for session management. We need to mock the entire context manager.</p>
<p><strong>The challenge</strong>: Context managers have <code>__aenter__</code> and <code>__aexit__</code> methods that must also be async.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_mock_v2.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncMock</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">MagicMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_full_mock</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mocking the complete async context manager&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;aiohttp.ClientSession&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_session_class</span><span class="p">:</span>
        <span class="c1"># Create mock session instance</span>
        <span class="n">mock_session</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
        <span class="n">mock_session_class</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">mock_session</span>

        <span class="c1"># Create mock response</span>
        <span class="n">mock_response</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">json</span> <span class="o">=</span> <span class="n">AsyncMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">})</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">raise_for_status</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>

        <span class="c1"># Mock the context manager for session.get()</span>
        <span class="n">mock_get</span> <span class="o">=</span> <span class="n">MagicMock</span><span class="p">()</span>
        <span class="n">mock_get</span><span class="o">.</span><span class="fm">__aenter__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">mock_response</span>
        <span class="n">mock_get</span><span class="o">.</span><span class="fm">__aexit__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">AsyncMock</span><span class="p">()</span>
        <span class="n">mock_session</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">mock_get</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alice&quot;</span>

        <span class="c1"># Verify the mock was called correctly</span>
        <span class="n">mock_session</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">abs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: The test now properly mocks the entire async context manager chain: <code>ClientSession</code> ‚Üí <code>session.get()</code> ‚Üí response context manager.</p>
<p><strong>Current limitation</strong>: This is verbose and error-prone. We need a cleaner approach for common mocking scenarios.</p>
<h3 id="iteration-3-using-pytest-aiohttp-for-http-mocking">Iteration 3: Using pytest-aiohttp for HTTP Mocking</h3>
<p><strong>The solution</strong>: The <code>pytest-aiohttp</code> plugin provides utilities specifically for testing aiohttp-based code:</p>
<div class="codehilite"><pre><span></span><code>pip<span class="w"> </span>install<span class="w"> </span>pytest-aiohttp<span class="w"> </span>aioresponses
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_mock_v3.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">aioresponses</span><span class="w"> </span><span class="kn">import</span> <span class="n">aioresponses</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_with_aioresponses</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Using aioresponses for cleaner HTTP mocking&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="c1"># Mock the HTTP endpoint</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">,</span> <span class="s2">&quot;email&quot;</span><span class="p">:</span> <span class="s2">&quot;alice@example.com&quot;</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alice&quot;</span>
        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;email&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;alice@example.com&quot;</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_multiple_users_with_aioresponses</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mocking multiple concurrent requests&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="c1"># Mock multiple endpoints</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/2&quot;</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/3&quot;</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Charlie&quot;</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="n">users</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_multiple_users</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">users</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alice&quot;</span>
        <span class="k">assert</span> <span class="n">users</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Bob&quot;</span>
        <span class="k">assert</span> <span class="n">users</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Charlie&quot;</span>
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: Much cleaner! <code>aioresponses</code> handles all the context manager mocking internally. We just specify the URL and response payload.</p>
<h3 id="mocking-async-functions-with-side-effects">Mocking Async Functions with Side Effects</h3>
<p>Sometimes you need to mock async functions that have side effects or raise exceptions:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_errors.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">aioresponses</span><span class="w"> </span><span class="kn">import</span> <span class="n">aioresponses</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">aiohttp</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClientError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_not_found</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test handling of 404 errors&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/999&quot;</span><span class="p">,</span>
            <span class="n">status</span><span class="o">=</span><span class="mi">404</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="s2">&quot;User not found&quot;</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="n">ClientError</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_timeout</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test handling of timeout errors&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">exception</span><span class="o">=</span><span class="ne">TimeoutError</span><span class="p">(</span><span class="s2">&quot;Request timed out&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">TimeoutError</span><span class="p">):</span>
            <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user_retry_logic</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test retry behavior on transient failures&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="c1"># First call fails</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">status</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;error&quot;</span><span class="p">:</span> <span class="s2">&quot;Internal server error&quot;</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># Second call succeeds</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="c1"># Assuming our client has retry logic</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<h3 id="mocking-async-fixtures">Mocking Async Fixtures</h3>
<p>You can also mock async functions within async fixtures:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_api_client_fixture_mock.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncMock</span><span class="p">,</span> <span class="n">patch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">mocked_api_client</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fixture that provides a mocked API client&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;aiohttp.ClientSession.get&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_get</span><span class="p">:</span>
        <span class="n">mock_response</span> <span class="o">=</span> <span class="n">AsyncMock</span><span class="p">()</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">json</span> <span class="o">=</span> <span class="n">AsyncMock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">})</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">raise_for_status</span> <span class="o">=</span> <span class="n">AsyncMock</span><span class="p">()</span>
        <span class="n">mock_get</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="fm">__aenter__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">mock_response</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">client</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_with_mocked_fixture</span><span class="p">(</span><span class="n">mocked_api_client</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test using a fixture that provides a mocked client&quot;&quot;&quot;</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">mocked_api_client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alice&quot;</span>
</code></pre></div>

<h3 id="using-aioresponses-as-a-fixture">Using aioresponses as a Fixture</h3>
<p>For even cleaner tests, create a fixture that provides <code>aioresponses</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># conftest.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">aioresponses</span><span class="w"> </span><span class="kn">import</span> <span class="n">aioresponses</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">mock_aiohttp</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fixture providing aioresponses for HTTP mocking&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">m</span>

<span class="c1"># test_api_client_with_fixture.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_user</span><span class="p">(</span><span class="n">mock_aiohttp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test using the mock_aiohttp fixture&quot;&quot;&quot;</span>
    <span class="n">mock_aiohttp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
        <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">}</span>
    <span class="p">)</span>

    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alice&quot;</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_search_users</span><span class="p">(</span><span class="n">mock_aiohttp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Another test using the same fixture&quot;&quot;&quot;</span>
    <span class="n">mock_aiohttp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="s2">&quot;https://api.example.com/users/search?q=alice&quot;</span><span class="p">,</span>
        <span class="n">payload</span><span class="o">=</span><span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice Smith&quot;</span><span class="p">}</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">search_users</span><span class="p">(</span><span class="s2">&quot;alice&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
</code></pre></div>

<h3 id="common-failure-mode-forgetting-to-mock-async-methods">Common Failure Mode: Forgetting to Mock Async Methods</h3>
<p>What happens if you mock an async method with a regular Mock instead of AsyncMock?</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_wrong_mock_type.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mock</span><span class="p">,</span> <span class="n">patch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_wrong_mock_type</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Using Mock instead of AsyncMock for async method&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s1">&#39;aiohttp.ClientSession.get&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_get</span><span class="p">:</span>
        <span class="n">mock_response</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
        <span class="c1"># Wrong: using Mock instead of AsyncMock</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">json</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span><span class="n">return_value</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">})</span>
        <span class="n">mock_response</span><span class="o">.</span><span class="n">raise_for_status</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">()</span>
        <span class="n">mock_get</span><span class="o">.</span><span class="n">return_value</span><span class="o">.</span><span class="fm">__aenter__</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">mock_response</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_wrong_mock_type.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="o">============================</span><span class="p">=</span><span class="w"> </span><span class="nx">test</span><span class="w"> </span><span class="nx">session</span><span class="w"> </span><span class="nx">starts</span><span class="w"> </span><span class="o">==============================</span>
<span class="nx">collected</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nx">item</span>

<span class="nx">test_wrong_mock_type</span><span class="p">.</span><span class="nx">py</span><span class="o">::</span><span class="nx">test_wrong_mock_type</span><span class="w"> </span><span class="nx">FAILED</span><span class="w">                     </span><span class="p">[</span><span class="mi">100</span><span class="o">%</span><span class="p">]</span>

<span class="o">==================================</span><span class="p">=</span><span class="w"> </span><span class="nx">FAILURES</span><span class="w"> </span><span class="o">==================================</span><span class="p">=</span>
<span class="nx">__________________________</span><span class="w"> </span><span class="nx">test_wrong_mock_type</span><span class="w"> </span><span class="nx">________________________________</span>

<span class="w">    </span><span class="err">@</span><span class="nx">pytest</span><span class="p">.</span><span class="nx">mark</span><span class="p">.</span><span class="nx">asyncio</span>
<span class="w">    </span><span class="nx">async</span><span class="w"> </span><span class="nx">def</span><span class="w"> </span><span class="nx">test_wrong_mock_type</span><span class="p">():</span>
<span class="w">        </span><span class="s">&quot;&quot;&quot;Using Mock instead of AsyncMock for async method&quot;&quot;&quot;</span>
<span class="w">        </span><span class="nx">with</span><span class="w"> </span><span class="nx">patch</span><span class="p">(</span><span class="err">&#39;</span><span class="nx">aiohttp</span><span class="p">.</span><span class="nx">ClientSession</span><span class="p">.</span><span class="nx">get</span><span class="err">&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nx">mock_get</span><span class="p">:</span>
<span class="w">            </span><span class="nx">mock_response</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Mock</span><span class="p">()</span>
<span class="w">            </span><span class="err">#</span><span class="w"> </span><span class="nx">Wrong</span><span class="p">:</span><span class="w"> </span><span class="nx">using</span><span class="w"> </span><span class="nx">Mock</span><span class="w"> </span><span class="nx">instead</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">AsyncMock</span>
<span class="w">            </span><span class="nx">mock_response</span><span class="p">.</span><span class="nx">json</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Mock</span><span class="p">(</span><span class="nx">return_value</span><span class="p">={</span><span class="s">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="p">})</span>
<span class="w">            </span><span class="nx">mock_response</span><span class="p">.</span><span class="nx">raise_for_status</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Mock</span><span class="p">()</span>
<span class="w">            </span><span class="nx">mock_get</span><span class="p">.</span><span class="nx">return_value</span><span class="p">.</span><span class="nx">__aenter__</span><span class="p">.</span><span class="nx">return_value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">mock_response</span>

<span class="w">            </span><span class="nx">client</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">UserAPIClient</span><span class="p">(</span><span class="s">&quot;https://api.example.com&quot;</span><span class="p">)</span>
<span class="p">&gt;</span><span class="w">           </span><span class="nx">user</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">await</span><span class="w"> </span><span class="nx">client</span><span class="p">.</span><span class="nx">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="nx">test_wrong_mock_type</span><span class="p">.</span><span class="nx">py</span><span class="p">:</span><span class="mi">14</span><span class="p">:</span><span class="w"> </span>
<span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="nx">_</span>
<span class="nx">api_client</span><span class="p">.</span><span class="nx">py</span><span class="p">:</span><span class="mi">12</span><span class="p">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">fetch_user</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">await</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
<span class="nx">E</span><span class="w">   </span><span class="nx">TypeError</span><span class="p">:</span><span class="w"> </span><span class="nx">object</span><span class="w"> </span><span class="nx">dict</span><span class="w"> </span><span class="nx">can</span><span class="err">&#39;</span><span class="nx">t</span><span class="w"> </span><span class="nx">be</span><span class="w"> </span><span class="nx">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">await</span><span class="err">&#39;</span><span class="w"> </span><span class="nx">expression</span>

<span class="o">==========================</span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nx">failed</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m m-Double">0.12</span><span class="nx">s</span><span class="w"> </span><span class="o">==================================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-wrong-mock-type">Diagnostic Analysis: Wrong Mock Type</h3>
<p><strong>The error</strong>: <code>TypeError: object dict can't be used in 'await' expression</code></p>
<p><strong>What this tells us</strong>:
- Same error as our first attempt
- The mock returned a dictionary directly instead of a coroutine
- We used <code>Mock</code> instead of <code>AsyncMock</code> for an async method</p>
<p><strong>Root cause identified</strong>: When mocking async methods, you must use <code>AsyncMock</code>. Regular <code>Mock</code> objects return values directly, not coroutines.</p>
<p><strong>Solution checklist</strong>:
- ‚úÖ Use <code>AsyncMock</code> for any method that's defined with <code>async def</code>
- ‚úÖ Use <code>AsyncMock</code> for methods that return coroutines
- ‚úÖ Regular <code>Mock</code> is fine for synchronous methods like <code>raise_for_status()</code></p>
<h3 id="the-journey-mocking-async-code">The Journey: Mocking Async Code</h3>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Problem</th>
<th>Solution</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Regular Mock for async method</td>
<td>None</td>
<td>TypeError: can't await dict</td>
</tr>
<tr>
<td>1</td>
<td>Need coroutine from mock</td>
<td>AsyncMock</td>
<td>Mock returns awaitable</td>
</tr>
<tr>
<td>2</td>
<td>Verbose context manager mocking</td>
<td>Manual <strong>aenter</strong>/<strong>aexit</strong></td>
<td>Works but complex</td>
</tr>
<tr>
<td>3</td>
<td>Cleaner HTTP mocking</td>
<td>aioresponses</td>
<td>Simple, readable tests</td>
</tr>
</tbody>
</table>
<h3 id="decision-framework-which-mocking-approach">Decision Framework: Which Mocking Approach?</h3>
<p><strong>Use <code>AsyncMock</code> directly when</strong>:
- Mocking simple async functions or methods
- You need fine-grained control over mock behavior
- The code doesn't use aiohttp</p>
<p><strong>Use <code>aioresponses</code> when</strong>:
- Testing aiohttp-based HTTP clients
- You want to mock HTTP endpoints by URL
- You need to test multiple concurrent requests</p>
<p><strong>Use custom async fixtures when</strong>:
- You need complex setup/teardown logic
- Multiple tests share the same mocking configuration
- You want to encapsulate mocking details</p>
<p><strong>Code characteristics</strong>:
- <strong>AsyncMock</strong>: Low-level, flexible, requires understanding of async internals
- <strong>aioresponses</strong>: High-level, HTTP-specific, cleaner for API testing
- <strong>Fixtures</strong>: Reusable, encapsulated, better for complex scenarios</p>
<p>In the next section, we'll explore common pitfalls in async testing and how to avoid them.</p>
<h2 id="common-pitfalls-in-async-testing">Common Pitfalls in Async Testing</h2>
<h2 id="pitfall-1-forgetting-to-await">Pitfall 1: Forgetting to Await</h2>
<p>The most common mistake in async testing is forgetting to <code>await</code> an async call. We've seen this before, but let's examine it systematically:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_pitfall_no_await.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserAPIClient</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_missing_await</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Forgetting to await an async call&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">UserAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>

    <span class="c1"># Wrong: missing await</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># This will fail because user is a coroutine, not a dict</span>
    <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>

<p><strong>Symptoms</strong>:
- <code>TypeError: 'coroutine' object is not subscriptable</code>
- <code>RuntimeWarning: coroutine was never awaited</code>
- Test fails with confusing error about coroutine objects</p>
<p><strong>How to catch this early</strong>:
1. Enable Python warnings: <code>pytest -W default</code>
2. Use type checkers like mypy
3. Use IDE async/await highlighting
4. Run pylint with async checks enabled</p>
<p><strong>The fix</strong>: Always <code>await</code> async function calls:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Correct version</span>
<span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<h2 id="pitfall-2-blocking-the-event-loop">Pitfall 2: Blocking the Event Loop</h2>
<p>Async code should never block the event loop with synchronous operations. Let's see what happens when we do:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># blocking_api_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">aiohttp</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BlockingAPIClient</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;API client with a blocking operation&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_url</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="n">base_url</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_user_with_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fetches user and does expensive processing&quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_url</span><span class="si">}</span><span class="s2">/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
                <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

        <span class="c1"># BAD: Blocking operation in async function</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Simulates expensive CPU work</span>

        <span class="c1"># Process user data</span>
        <span class="n">user</span><span class="p">[</span><span class="s2">&quot;processed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">user</span>
</code></pre></div>

<p>Now let's test concurrent fetching with this blocking client:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_blocking_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">blocking_api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">BlockingAPIClient</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">aioresponses</span><span class="w"> </span><span class="kn">import</span> <span class="n">aioresponses</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_concurrent_fetch_with_blocking</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrates how blocking operations kill concurrency&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="c1"># Mock three user endpoints</span>
        <span class="k">for</span> <span class="n">user_id</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;https://api.example.com/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">user_id</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;User </span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">BlockingAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">client</span><span class="o">.</span><span class="n">fetch_user_with_processing</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">client</span><span class="o">.</span><span class="n">fetch_user_with_processing</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">client</span><span class="o">.</span><span class="n">fetch_user_with_processing</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">users</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

        <span class="c1"># Each user takes 2 seconds to process</span>
        <span class="c1"># With proper async, this should take ~2 seconds total</span>
        <span class="c1"># But with blocking, it takes ~6 seconds (sequential)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Elapsed time: </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_blocking_client.py<span class="w"> </span>-v<span class="w"> </span>-s
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_blocking_client.py::test_concurrent_fetch_with_blocking 
Elapsed time: 6.02 seconds
PASSED                                                                   [100%]

============================== 1 passed in 6.03s ===============================
</code></pre></div>

<h3 id="diagnostic-analysis-blocking-the-event-loop">Diagnostic Analysis: Blocking the Event Loop</h3>
<p><strong>What happened</strong>: The test took 6 seconds instead of 2 seconds, even though we used <code>asyncio.gather()</code> for concurrent execution.</p>
<p><strong>Root cause</strong>: The <code>time.sleep(2)</code> call blocks the entire event loop. While one coroutine is sleeping, no other coroutines can run. The "concurrent" operations become sequential.</p>
<p><strong>Why this is bad</strong>:
- Defeats the purpose of async code
- Reduces performance to worse than synchronous code
- Can cause timeouts in production
- Makes tests slower than necessary</p>
<p><strong>The fix</strong>: Use async alternatives for blocking operations:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># non_blocking_api_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">aiohttp</span>

<span class="k">class</span><span class="w"> </span><span class="nc">NonBlockingAPIClient</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;API client with proper async operations&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_url</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="n">base_url</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_user_with_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fetches user and does processing without blocking&quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
            <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_url</span><span class="si">}</span><span class="s2">/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
                <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

        <span class="c1"># GOOD: Non-blocking async sleep</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Simulates async I/O operation</span>

        <span class="n">user</span><span class="p">[</span><span class="s2">&quot;processed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">user</span>
</code></pre></div>

<p>Test the non-blocking version:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_non_blocking_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">non_blocking_api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">NonBlockingAPIClient</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">aioresponses</span><span class="w"> </span><span class="kn">import</span> <span class="n">aioresponses</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_concurrent_fetch_non_blocking</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Proper async operations allow true concurrency&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">user_id</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;https://api.example.com/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">user_id</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;User </span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">NonBlockingAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">client</span><span class="o">.</span><span class="n">fetch_user_with_processing</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">client</span><span class="o">.</span><span class="n">fetch_user_with_processing</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">client</span><span class="o">.</span><span class="n">fetch_user_with_processing</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">users</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

        <span class="c1"># Now it takes ~2 seconds (concurrent)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Elapsed time: </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">elapsed</span> <span class="o">&lt;</span> <span class="mf">3.0</span>  <span class="c1"># Should be around 2 seconds</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_non_blocking_client.py::test_concurrent_fetch_non_blocking 
Elapsed time: 2.01 seconds
PASSED                                                                   [100%]

============================== 1 passed in 2.02s ===============================
</code></pre></div>

<p><strong>Common blocking operations and their async alternatives</strong>:</p>
<table>
<thead>
<tr>
<th>Blocking Operation</th>
<th>Async Alternative</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>time.sleep()</code></td>
<td><code>asyncio.sleep()</code></td>
</tr>
<tr>
<td><code>requests.get()</code></td>
<td><code>aiohttp.ClientSession.get()</code></td>
</tr>
<tr>
<td><code>open()</code> / <code>file.read()</code></td>
<td><code>aiofiles.open()</code> / <code>await file.read()</code></td>
</tr>
<tr>
<td><code>subprocess.run()</code></td>
<td><code>asyncio.create_subprocess_exec()</code></td>
</tr>
<tr>
<td>CPU-intensive work</td>
<td><code>asyncio.to_thread()</code> or <code>loop.run_in_executor()</code></td>
</tr>
</tbody>
</table>
<h2 id="pitfall-3-not-cleaning-up-resources">Pitfall 3: Not Cleaning Up Resources</h2>
<p>Async code often manages resources like HTTP sessions, database connections, or file handles. Failing to clean them up causes resource leaks:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># leaky_api_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">aiohttp</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LeakyAPIClient</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;API client that leaks resources&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_url</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="n">base_url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create session&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fetch user (assumes session exists)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Client not connected&quot;</span><span class="p">)</span>

        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_url</span><span class="si">}</span><span class="s2">/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

    <span class="c1"># Missing: async def close() method!</span>
</code></pre></div>

<p>Test this leaky client:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_leaky_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">leaky_api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">LeakyAPIClient</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">aioresponses</span><span class="w"> </span><span class="kn">import</span> <span class="n">aioresponses</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_leaky_client</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This test leaks an HTTP session&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">LeakyAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
        <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># Missing: await client.close()</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_leaky_client.py<span class="w"> </span>-v<span class="w"> </span>-W<span class="w"> </span>default
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_leaky_client.py::test_leaky_client PASSED                           [100%]

----------------------------- Captured warnings --------------------------------
test_leaky_client.py::test_leaky_client
  ResourceWarning: unclosed &lt;aiohttp.client.ClientSession object at 0x...&gt;
    await client.connect()

============================== 1 passed, 1 warning in 0.45s ===================
</code></pre></div>

<h3 id="diagnostic-analysis-resource-leak">Diagnostic Analysis: Resource Leak</h3>
<p><strong>The warning</strong>: <code>ResourceWarning: unclosed &lt;aiohttp.client.ClientSession object&gt;</code></p>
<p><strong>What this tells us</strong>:
- An HTTP session was created but never closed
- Python's garbage collector detected the leak
- This warning only appears with <code>-W default</code> flag</p>
<p><strong>Why this is bad</strong>:
- Leaks file descriptors and memory
- Can exhaust system resources in long-running tests
- May cause "too many open files" errors
- Indicates improper resource management</p>
<p><strong>The fix</strong>: Always clean up async resources:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># proper_api_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">aiohttp</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ProperAPIClient</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;API client with proper resource management&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_url</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="n">base_url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create session&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fetch user&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Client not connected&quot;</span><span class="p">)</span>

        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_url</span><span class="si">}</span><span class="s2">/users/</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean up session&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Support async context manager&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure cleanup on context exit&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>

<p>Test with proper cleanup:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_proper_client.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">proper_api_client</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProperAPIClient</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">aioresponses</span><span class="w"> </span><span class="kn">import</span> <span class="n">aioresponses</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_proper_client_manual_cleanup</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Manual cleanup approach&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="n">client</span> <span class="o">=</span> <span class="n">ProperAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_proper_client_context_manager</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context manager approach (preferred)&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">aioresponses</span><span class="p">()</span> <span class="k">as</span> <span class="n">mocked</span><span class="p">:</span>
        <span class="n">mocked</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;https://api.example.com/users/1&quot;</span><span class="p">,</span>
            <span class="n">payload</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="k">async</span> <span class="k">with</span> <span class="n">ProperAPIClient</span><span class="p">(</span><span class="s2">&quot;https://api.example.com&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
            <span class="n">user</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">fetch_user</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">user</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c1"># Cleanup happens automatically</span>
</code></pre></div>

<p><strong>Best practice</strong>: Use async context managers (<code>async with</code>) for automatic resource cleanup.</p>
<h2 id="pitfall-4-race-conditions-in-tests">Pitfall 4: Race Conditions in Tests</h2>
<p>Async code can have subtle race conditions that only appear intermittently:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># racy_counter.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="k">class</span><span class="w"> </span><span class="nc">RacyCounter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Counter with a race condition&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Increment counter (not atomic!)&quot;&quot;&quot;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>  <span class="c1"># Simulates async operation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div>

<p>Test this racy counter:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_racy_counter.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">racy_counter</span><span class="w"> </span><span class="kn">import</span> <span class="n">RacyCounter</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_concurrent_increments</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This test might pass or fail randomly&quot;&quot;&quot;</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">RacyCounter</span><span class="p">()</span>

    <span class="c1"># Increment 100 times concurrently</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

    <span class="c1"># Expected: 100, but might be less due to race condition</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Final count: </span><span class="si">{</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">counter</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">100</span>
</code></pre></div>

<p>Run this test multiple times:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_racy_counter.py<span class="w"> </span>-v<span class="w"> </span>-s<span class="w"> </span>--count<span class="o">=</span><span class="m">10</span>
</code></pre></div>

<p><strong>Output</strong> (may vary):</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 10 items

test_racy_counter.py::test_concurrent_increments[1] 
Final count: 87
FAILED
test_racy_counter.py::test_concurrent_increments[2] 
Final count: 92
FAILED
test_racy_counter.py::test_concurrent_increments[3] 
Final count: 100
PASSED
...
</code></pre></div>

<h3 id="diagnostic-analysis-race-condition">Diagnostic Analysis: Race Condition</h3>
<p><strong>The symptom</strong>: Test passes sometimes, fails other times with different count values.</p>
<p><strong>Root cause</strong>: Multiple coroutines read <code>self.count</code>, then all write back incremented values. The last write wins, losing some increments.</p>
<p><strong>Why this is dangerous</strong>:
- Flaky tests erode confidence
- Hard to debug (non-deterministic)
- May only appear under load
- Can hide real bugs</p>
<p><strong>The fix</strong>: Use proper synchronization:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># safe_counter.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SafeCounter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Counter with proper synchronization&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Atomically increment counter&quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div>

<p>Test the safe counter:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_safe_counter.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">safe_counter</span><span class="w"> </span><span class="kn">import</span> <span class="n">SafeCounter</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_concurrent_increments_safe</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This test always passes&quot;&quot;&quot;</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">SafeCounter</span><span class="p">()</span>

    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Final count: </span><span class="si">{</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">counter</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">100</span>
</code></pre></div>

<p><strong>Output</strong> (consistent):</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_safe_counter.py::test_concurrent_increments_safe 
Final count: 100
PASSED                                                                   [100%]

============================== 1 passed in 0.15s ===============================
</code></pre></div>

<h2 id="pitfall-5-testing-with-the-wrong-event-loop">Pitfall 5: Testing with the Wrong Event Loop</h2>
<p>Each test should use a fresh event loop. Reusing loops between tests can cause state leakage:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_loop_reuse.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="c1"># Global state (bad practice)</span>
<span class="n">_cached_data</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_and_cache</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Caches data in global dict&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">_cached_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_first</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;First test populates cache&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_and_cache</span><span class="p">(</span><span class="s2">&quot;user_1&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">})</span>
    <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alice&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cache after test_first: </span><span class="si">{</span><span class="n">_cached_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_second</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Second test sees cached data from first test&quot;&quot;&quot;</span>
    <span class="c1"># This test might fail if cache isn&#39;t cleared</span>
    <span class="k">assert</span> <span class="s2">&quot;user_1&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_cached_data</span><span class="p">,</span> <span class="s2">&quot;Cache leaked from previous test!&quot;</span>
</code></pre></div>

<p>Run these tests:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_loop_reuse.py<span class="w"> </span>-v<span class="w"> </span>-s
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="o">=============================</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">session</span><span class="w"> </span><span class="n">starts</span><span class="w"> </span><span class="o">==============================</span>
<span class="n">collected</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">items</span>

<span class="n">test_loop_reuse</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_first</span><span class="w"> </span>
<span class="n">Cache</span><span class="w"> </span><span class="k">after</span><span class="w"> </span><span class="nl">test_first</span><span class="p">:</span><span class="w"> </span><span class="err">{</span><span class="s1">&#39;user_1&#39;</span><span class="err">:</span><span class="w"> </span><span class="err">{</span><span class="s1">&#39;name&#39;</span><span class="err">:</span><span class="w"> </span><span class="s1">&#39;Alice&#39;</span><span class="err">}}</span>
<span class="n">PASSED</span>
<span class="n">test_loop_reuse</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_second</span><span class="w"> </span><span class="n">FAILED</span><span class="w">                                   </span><span class="o">[</span><span class="n">100%</span><span class="o">]</span>

<span class="o">===================================</span><span class="w"> </span><span class="n">FAILURES</span><span class="w"> </span><span class="o">===================================</span>
<span class="n">______________________________</span><span class="w"> </span><span class="n">test_second</span><span class="w"> </span><span class="n">_____________________________________</span>

<span class="w">    </span><span class="nv">@pytest</span><span class="p">.</span><span class="n">mark</span><span class="p">.</span><span class="n">asyncio</span>
<span class="w">    </span><span class="n">async</span><span class="w"> </span><span class="n">def</span><span class="w"> </span><span class="n">test_second</span><span class="p">()</span><span class="err">:</span>
<span class="w">        </span><span class="ss">&quot;&quot;&quot;Second test sees cached data from first test&quot;&quot;&quot;</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="n">might</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="n">isn</span><span class="err">&#39;</span><span class="n">t</span><span class="w"> </span><span class="n">cleared</span>
<span class="o">&gt;</span><span class="w">       </span><span class="n">assert</span><span class="w"> </span><span class="ss">&quot;user_1&quot;</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">_cached_data</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;Cache leaked from previous test!&quot;</span>
<span class="n">E</span><span class="w">       </span><span class="nl">AssertionError</span><span class="p">:</span><span class="w"> </span><span class="n">Cache</span><span class="w"> </span><span class="n">leaked</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">test</span><span class="err">!</span>

<span class="n">test_loop_reuse</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="mi">20</span><span class="err">:</span><span class="w"> </span><span class="n">AssertionError</span>
<span class="o">===========================</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">failed</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="mf">0.12</span><span class="n">s</span><span class="w"> </span><span class="o">=======================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-state-leakage">Diagnostic Analysis: State Leakage</h3>
<p><strong>The problem</strong>: Global state persists between tests, causing test interdependency.</p>
<p><strong>Why this happens</strong>:
- Python module-level variables persist across tests
- Event loop state can leak if not properly isolated
- Fixtures with incorrect scope can share state</p>
<p><strong>The fix</strong>: Clear state between tests or use proper fixture scoping:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_isolated.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">clear_cache</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Automatically clear cache before each test&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_cached_data</span>
    <span class="n">_cached_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">yield</span>
    <span class="n">_cached_data</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_and_cache</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Caches data in global dict&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">_cached_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_first</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;First test populates cache&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_and_cache</span><span class="p">(</span><span class="s2">&quot;user_1&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">})</span>
    <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Alice&quot;</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_second</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Second test has clean cache&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="s2">&quot;user_1&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_cached_data</span>  <span class="c1"># Now passes!</span>
</code></pre></div>

<h2 id="common-failure-modes-and-their-signatures">Common Failure Modes and Their Signatures</h2>
<h3 id="symptom-typeerror-coroutine-object-is-not-subscriptable">Symptom: TypeError: 'coroutine' object is not subscriptable</h3>
<p><strong>Pytest output pattern</strong>:</p>
<div class="codehilite"><pre><span></span><code>E   TypeError: &#39;coroutine&#39; object is not subscriptable
RuntimeWarning: coroutine &#39;function_name&#39; was never awaited
</code></pre></div>

<p><strong>Diagnostic clues</strong>:
- Missing <code>await</code> keyword
- Trying to access attributes/items on a coroutine object
- RuntimeWarning about unawaited coroutine</p>
<p><strong>Root cause</strong>: Forgot to <code>await</code> an async function call</p>
<p><strong>Solution</strong>: Add <code>await</code> before the async call</p>
<h3 id="symptom-test-takes-much-longer-than-expected">Symptom: Test takes much longer than expected</h3>
<p><strong>Pytest output pattern</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================== 1 passed in 6.03s ===============================
</code></pre></div>

<p>(When it should take ~2 seconds)</p>
<p><strong>Diagnostic clues</strong>:
- Concurrent operations running sequentially
- Total time equals sum of individual operation times
- No actual concurrency happening</p>
<p><strong>Root cause</strong>: Blocking operation in async code (e.g., <code>time.sleep()</code>)</p>
<p><strong>Solution</strong>: Replace blocking calls with async alternatives</p>
<h3 id="symptom-resourcewarning-about-unclosed-resources">Symptom: ResourceWarning about unclosed resources</h3>
<p><strong>Pytest output pattern</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">ResourceWarning</span><span class="o">:</span><span class="w"> </span><span class="n">unclosed</span><span class="w"> </span><span class="o">&lt;</span><span class="n">aiohttp</span><span class="o">.</span><span class="na">client</span><span class="o">.</span><span class="na">ClientSession</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mi">0</span><span class="n">x</span><span class="o">...&gt;</span>
<span class="n">ResourceWarning</span><span class="o">:</span><span class="w"> </span><span class="n">unclosed</span><span class="w"> </span><span class="n">transport</span><span class="w"> </span><span class="o">&lt;</span><span class="n">_ProactorSocketTransport</span><span class="w"> </span><span class="o">...&gt;</span>
</code></pre></div>

<p><strong>Diagnostic clues</strong>:
- Warnings about unclosed sessions, transports, or files
- Only visible with <code>-W default</code> flag
- Appears in test cleanup phase</p>
<p><strong>Root cause</strong>: Missing cleanup code for async resources</p>
<p><strong>Solution</strong>: Use <code>async with</code> or add explicit <code>await resource.close()</code></p>
<h3 id="symptom-flaky-test-that-passesfails-randomly">Symptom: Flaky test that passes/fails randomly</h3>
<p><strong>Pytest output pattern</strong>:</p>
<div class="codehilite"><pre><span></span><code>test_function PASSED  # Run 1
test_function FAILED  # Run 2
test_function PASSED  # Run 3
</code></pre></div>

<p><strong>Diagnostic clues</strong>:
- Different results on identical code
- Failures show different values each time
- More likely to fail with higher concurrency</p>
<p><strong>Root cause</strong>: Race condition in async code</p>
<p><strong>Solution</strong>: Add proper synchronization (locks, semaphores)</p>
<h3 id="symptom-test-fails-with-event-loop-is-closed">Symptom: Test fails with "Event loop is closed"</h3>
<p><strong>Pytest output pattern</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">E</span><span class="w">   </span><span class="nv">RuntimeError</span>:<span class="w"> </span><span class="nv">Event</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">closed</span>
<span class="nv">E</span><span class="w">   </span><span class="nv">RuntimeError</span>:<span class="w"> </span><span class="nv">no</span><span class="w"> </span><span class="nv">running</span><span class="w"> </span><span class="nv">event</span><span class="w"> </span><span class="k">loop</span>
</code></pre></div>

<p><strong>Diagnostic clues</strong>:
- Happens when trying to run async code
- Often in cleanup or teardown
- May indicate fixture scope issues</p>
<p><strong>Root cause</strong>: Trying to use an event loop that's been closed</p>
<p><strong>Solution</strong>: Check fixture scopes, ensure proper async context</p>
<h2 id="summary-avoiding-async-testing-pitfalls">Summary: Avoiding Async Testing Pitfalls</h2>
<table>
<thead>
<tr>
<th>Pitfall</th>
<th>Symptom</th>
<th>Prevention</th>
</tr>
</thead>
<tbody>
<tr>
<td>Missing await</td>
<td>TypeError: coroutine not subscriptable</td>
<td>Use type checkers, enable warnings</td>
</tr>
<tr>
<td>Blocking operations</td>
<td>Tests slower than expected</td>
<td>Use async alternatives only</td>
</tr>
<tr>
<td>Resource leaks</td>
<td>ResourceWarning</td>
<td>Always use async context managers</td>
</tr>
<tr>
<td>Race conditions</td>
<td>Flaky tests</td>
<td>Use asyncio.Lock for shared state</td>
</tr>
<tr>
<td>Loop reuse</td>
<td>State leakage between tests</td>
<td>Use autouse fixtures to clear state</td>
</tr>
</tbody>
</table>
<p>In the next section, we'll learn how to test concurrent code with multiple tasks running simultaneously.</p>
<h2 id="testing-concurrent-code">Testing Concurrent Code</h2>
<h2 id="understanding-concurrency-vs-parallelism">Understanding Concurrency vs. Parallelism</h2>
<p>Before testing concurrent code, let's clarify terminology:</p>
<ul>
<li><strong>Concurrency</strong>: Multiple tasks making progress by switching between them (single CPU core)</li>
<li><strong>Parallelism</strong>: Multiple tasks running simultaneously (multiple CPU cores)</li>
<li><strong>Async/await</strong>: Provides concurrency, not parallelism (unless combined with multiprocessing)</li>
</ul>
<p>Our focus is on testing concurrent async code‚Äîmultiple coroutines running in the same event loop.</p>
<h3 id="our-reference-example-a-task-queue">Our Reference Example: A Task Queue</h3>
<p>We'll build and test an async task queue that processes multiple tasks concurrently:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># task_queue.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TaskResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Result of a task execution&quot;&quot;&quot;</span>
    <span class="n">task_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">started_at</span><span class="p">:</span> <span class="n">datetime</span>
    <span class="n">completed_at</span><span class="p">:</span> <span class="n">datetime</span>
    <span class="n">duration</span><span class="p">:</span> <span class="nb">float</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AsyncTaskQueue</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Queue that processes tasks concurrently&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_concurrent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_concurrent</span> <span class="o">=</span> <span class="n">max_concurrent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TaskResult</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">process_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">task_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process a single task&quot;&quot;&quot;</span>
        <span class="n">started_at</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">completed_at</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">completed_at</span> <span class="o">-</span> <span class="n">started_at</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>

        <span class="n">task_result</span> <span class="o">=</span> <span class="n">TaskResult</span><span class="p">(</span>
            <span class="n">task_id</span><span class="o">=</span><span class="n">task_id</span><span class="p">,</span>
            <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">,</span>
            <span class="n">started_at</span><span class="o">=</span><span class="n">started_at</span><span class="p">,</span>
            <span class="n">completed_at</span><span class="o">=</span><span class="n">completed_at</span><span class="p">,</span>
            <span class="n">duration</span><span class="o">=</span><span class="n">duration</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task_result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">task_result</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tasks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process multiple tasks with concurrency limit&quot;&quot;&quot;</span>
        <span class="n">semaphore</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_concurrent</span><span class="p">)</span>

        <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">bounded_task</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">async</span> <span class="k">with</span> <span class="n">semaphore</span><span class="p">:</span>
                <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_task</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">coroutines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">bounded_task</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">task_func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">tasks</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">coroutines</span><span class="p">)</span>
</code></pre></div>

<h3 id="iteration-1-testing-basic-concurrent-execution">Iteration 1: Testing Basic Concurrent Execution</h3>
<p><strong>First, let's verify that tasks actually run concurrently</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_task_queue_v1.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">task_queue</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncTaskQueue</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">slow_task</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulates a slow async operation&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_tasks_run_concurrently</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that tasks run concurrently, not sequentially&quot;&quot;&quot;</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">AsyncTaskQueue</span><span class="p">(</span><span class="n">max_concurrent</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Create 3 tasks that each take 1 second</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;task1&quot;</span><span class="p">,</span> <span class="n">slow_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;result1&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task2&quot;</span><span class="p">,</span> <span class="n">slow_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;result2&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task3&quot;</span><span class="p">,</span> <span class="n">slow_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;result3&quot;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="p">]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="c1"># If concurrent: ~1 second total</span>
    <span class="c1"># If sequential: ~3 seconds total</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Elapsed time: </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">elapsed</span> <span class="o">&lt;</span> <span class="mf">1.5</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Tasks ran sequentially! Took </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">result</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;result1&quot;</span><span class="p">,</span> <span class="s2">&quot;result2&quot;</span><span class="p">,</span> <span class="s2">&quot;result3&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">)</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_task_queue_v1.py<span class="w"> </span>-v<span class="w"> </span>-s
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_task_queue_v1.py::test_tasks_run_concurrently 
Elapsed time: 1.01 seconds
PASSED                                                                   [100%]

============================== 1 passed in 1.02s ===============================
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: The test confirms that three 1-second tasks complete in ~1 second total, proving they run concurrently.</p>
<p><strong>Current limitation</strong>: We haven't tested the concurrency limit. What happens with more tasks than the limit allows?</p>
<h3 id="iteration-2-testing-concurrency-limits">Iteration 2: Testing Concurrency Limits</h3>
<p><strong>Current state recap</strong>: We know tasks run concurrently, but we need to verify the <code>max_concurrent</code> limit works.</p>
<p><strong>The challenge</strong>: How do we prove that only N tasks run simultaneously?</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_task_queue_v2.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">task_queue</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncTaskQueue</span>

<span class="c1"># Track how many tasks are running simultaneously</span>
<span class="n">active_tasks</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">max_active_tasks</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">tracked_task</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task that tracks concurrent execution&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">active_tasks</span><span class="p">,</span> <span class="n">max_active_tasks</span>

    <span class="n">active_tasks</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">max_active_tasks</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_active_tasks</span><span class="p">,</span> <span class="n">active_tasks</span><span class="p">)</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>

    <span class="n">active_tasks</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_concurrency_limit_enforced</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that max_concurrent limit is enforced&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">active_tasks</span><span class="p">,</span> <span class="n">max_active_tasks</span>
    <span class="n">active_tasks</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_active_tasks</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">AsyncTaskQueue</span><span class="p">(</span><span class="n">max_concurrent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Create 5 tasks, but only 2 should run at once</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;task</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tracked_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;result</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span> <span class="p">{})</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Max concurrent tasks: </span><span class="si">{</span><span class="n">max_active_tasks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">max_active_tasks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Expected max 2 concurrent, got </span><span class="si">{</span><span class="n">max_active_tasks</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_task_queue_v2.py<span class="w"> </span>-v<span class="w"> </span>-s
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_task_queue_v2.py::test_concurrency_limit_enforced 
Max concurrent tasks: 2
PASSED                                                                   [100%]

============================== 1 passed in 0.25s ===============================
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: The test proves that even with 5 tasks, only 2 run simultaneously. The semaphore correctly limits concurrency.</p>
<p><strong>Current limitation</strong>: We're using global variables to track state, which is fragile. Also, what happens if a task fails?</p>
<h3 id="iteration-3-testing-error-handling-in-concurrent-tasks">Iteration 3: Testing Error Handling in Concurrent Tasks</h3>
<p><strong>Current state recap</strong>: We can test successful concurrent execution, but real-world tasks can fail.</p>
<p><strong>The scenario</strong>: What happens when some tasks succeed and others fail?</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_task_queue_v3.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">task_queue</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncTaskQueue</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">failing_task</span><span class="p">(</span><span class="n">should_fail</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task that might fail&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">should_fail</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Task failed: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_one_task_fails</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;What happens when one task fails?&quot;&quot;&quot;</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">AsyncTaskQueue</span><span class="p">(</span><span class="n">max_concurrent</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;task1&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;success1&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task2&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;failure&quot;</span><span class="p">),</span> <span class="p">{}),</span>  <span class="c1"># This will fail</span>
        <span class="p">(</span><span class="s2">&quot;task3&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;success2&quot;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="p">]</span>

    <span class="c1"># asyncio.gather() will raise the first exception by default</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="s2">&quot;Task failed: failure&quot;</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_task_queue_v3.py<span class="w"> </span>-v
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_task_queue_v3.py::test_one_task_fails PASSED                       [100%]

============================== 1 passed in 0.15s ===============================
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: The test confirms that when one task fails, the exception propagates and stops all tasks.</p>
<p><strong>Current limitation</strong>: This might not be the behavior we want. In a real task queue, we might want to collect all results and errors, not stop on the first failure.</p>
<h3 id="iteration-4-testing-graceful-error-collection">Iteration 4: Testing Graceful Error Collection</h3>
<p><strong>The solution</strong>: Modify our queue to collect errors instead of propagating them immediately:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># task_queue_v2.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TaskResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Result of a task execution&quot;&quot;&quot;</span>
    <span class="n">task_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
    <span class="n">error</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]</span>
    <span class="n">started_at</span><span class="p">:</span> <span class="n">datetime</span>
    <span class="n">completed_at</span><span class="p">:</span> <span class="n">datetime</span>
    <span class="n">duration</span><span class="p">:</span> <span class="nb">float</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">succeeded</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AsyncTaskQueue</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Queue that processes tasks concurrently with error handling&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_concurrent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_concurrent</span> <span class="o">=</span> <span class="n">max_concurrent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TaskResult</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">process_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">task_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process a single task, capturing errors&quot;&quot;&quot;</span>
        <span class="n">started_at</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">task_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">e</span>

        <span class="n">completed_at</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">completed_at</span> <span class="o">-</span> <span class="n">started_at</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>

        <span class="n">task_result</span> <span class="o">=</span> <span class="n">TaskResult</span><span class="p">(</span>
            <span class="n">task_id</span><span class="o">=</span><span class="n">task_id</span><span class="p">,</span>
            <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">,</span>
            <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span>
            <span class="n">started_at</span><span class="o">=</span><span class="n">started_at</span><span class="p">,</span>
            <span class="n">completed_at</span><span class="o">=</span><span class="n">completed_at</span><span class="p">,</span>
            <span class="n">duration</span><span class="o">=</span><span class="n">duration</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task_result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">task_result</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tasks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process multiple tasks, collecting all results and errors&quot;&quot;&quot;</span>
        <span class="n">semaphore</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_concurrent</span><span class="p">)</span>

        <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">bounded_task</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">async</span> <span class="k">with</span> <span class="n">semaphore</span><span class="p">:</span>
                <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_task</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">coroutines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">bounded_task</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">task_func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">tasks</span>
        <span class="p">]</span>

        <span class="c1"># Use return_exceptions=True to collect all results</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">coroutines</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

<p>Now test the improved error handling:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_task_queue_v4.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">task_queue_v2</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncTaskQueue</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">failing_task</span><span class="p">(</span><span class="n">should_fail</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task that might fail&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">should_fail</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Task failed: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_mixed_success_and_failure</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that successful tasks complete even when others fail&quot;&quot;&quot;</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">AsyncTaskQueue</span><span class="p">(</span><span class="n">max_concurrent</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;task1&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;success1&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task2&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;failure1&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task3&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;success2&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task4&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;failure2&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task5&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;success3&quot;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="p">]</span>

    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

    <span class="c1"># Check that we got all results</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>

    <span class="c1"># Check successful tasks</span>
    <span class="n">successful</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">succeeded</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">successful</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="p">{</span><span class="n">r</span><span class="o">.</span><span class="n">result</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">successful</span><span class="p">}</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;success1&quot;</span><span class="p">,</span> <span class="s2">&quot;success2&quot;</span><span class="p">,</span> <span class="s2">&quot;success3&quot;</span><span class="p">}</span>

    <span class="c1"># Check failed tasks</span>
    <span class="n">failed</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">succeeded</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">failed</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="s2">&quot;Task failed&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">failed</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Successful: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">successful</span><span class="p">)</span><span class="si">}</span><span class="s2">, Failed: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Run this test:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>test_task_queue_v4.py<span class="w"> </span>-v<span class="w"> </span>-s
</code></pre></div>

<p><strong>Output</strong>:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
collected 1 item

test_task_queue_v4.py::test_mixed_success_and_failure 
Successful: 3, Failed: 2
PASSED                                                                   [100%]

============================== 1 passed in 0.25s ===============================
</code></pre></div>

<p><strong>Expected vs. Actual improvement</strong>: All tasks complete, and we can inspect both successes and failures. This is much more useful for a real task queue.</p>
<h3 id="testing-task-ordering-and-timing">Testing Task Ordering and Timing</h3>
<p>Sometimes you need to verify the order or timing of concurrent operations:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_task_ordering.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">task_queue_v2</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncTaskQueue</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">timed_task</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task with specific duration&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_task_completion_order</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Verify that faster tasks complete first&quot;&quot;&quot;</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">AsyncTaskQueue</span><span class="p">(</span><span class="n">max_concurrent</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Tasks with different durations</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;slow&quot;</span><span class="p">,</span> <span class="n">timed_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="s2">&quot;slow_result&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;fast&quot;</span><span class="p">,</span> <span class="n">timed_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;fast_result&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;medium&quot;</span><span class="p">,</span> <span class="n">timed_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="s2">&quot;medium_result&quot;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="p">]</span>

    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

    <span class="c1"># Sort by completion time</span>
    <span class="n">sorted_results</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">completed_at</span><span class="p">)</span>

    <span class="c1"># Verify completion order matches duration</span>
    <span class="k">assert</span> <span class="n">sorted_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">task_id</span> <span class="o">==</span> <span class="s2">&quot;fast&quot;</span>
    <span class="k">assert</span> <span class="n">sorted_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">task_id</span> <span class="o">==</span> <span class="s2">&quot;medium&quot;</span>
    <span class="k">assert</span> <span class="n">sorted_results</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">task_id</span> <span class="o">==</span> <span class="s2">&quot;slow&quot;</span>

    <span class="c1"># Verify durations are approximately correct</span>
    <span class="k">assert</span> <span class="mf">0.09</span> <span class="o">&lt;</span> <span class="n">sorted_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;</span> <span class="mf">0.15</span>
    <span class="k">assert</span> <span class="mf">0.19</span> <span class="o">&lt;</span> <span class="n">sorted_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;</span> <span class="mf">0.25</span>
    <span class="k">assert</span> <span class="mf">0.29</span> <span class="o">&lt;</span> <span class="n">sorted_results</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;</span> <span class="mf">0.35</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Completion order:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">sorted_results</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">task_id</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">duration</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="testing-cancellation-and-timeouts">Testing Cancellation and Timeouts</h3>
<p>Real concurrent systems need to handle cancellation and timeouts:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_task_cancellation.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">task_queue_v2</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncTaskQueue</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">long_running_task</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task that takes a long time&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_task_timeout</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that tasks can be cancelled on timeout&quot;&quot;&quot;</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">AsyncTaskQueue</span><span class="p">(</span><span class="n">max_concurrent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;quick&quot;</span><span class="p">,</span> <span class="n">long_running_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;quick_result&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;slow&quot;</span><span class="p">,</span> <span class="n">long_running_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="s2">&quot;slow_result&quot;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="p">]</span>

    <span class="c1"># Set a timeout for the entire operation</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">),</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Operation timed out as expected&quot;</span><span class="p">)</span>
        <span class="c1"># Check that at least the quick task completed</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="n">quick_result</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">queue</span><span class="o">.</span><span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">task_id</span> <span class="o">==</span> <span class="s2">&quot;quick&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">quick_result</span><span class="o">.</span><span class="n">succeeded</span>
        <span class="k">assert</span> <span class="n">quick_result</span><span class="o">.</span><span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;quick_result&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pytest</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">&quot;Expected TimeoutError&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="testing-with-asynciocreate_task">Testing with asyncio.create_task()</h3>
<p>Sometimes you need to test code that creates tasks explicitly:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># background_processor.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BackgroundProcessor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Processes items in the background&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">process_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process a single item&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;processed_</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">start_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Start processing items in background tasks&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">wait_for_completion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wait for all background tasks to complete&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">)</span>
</code></pre></div>

<p>Test the background processor:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_background_processor.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">background_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">BackgroundProcessor</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_background_processing</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that background tasks complete correctly&quot;&quot;&quot;</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">BackgroundProcessor</span><span class="p">()</span>

    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;item1&quot;</span><span class="p">,</span> <span class="s2">&quot;item2&quot;</span><span class="p">,</span> <span class="s2">&quot;item3&quot;</span><span class="p">]</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">start_processing</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="c1"># Tasks are running in the background</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">tasks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">task</span><span class="o">.</span><span class="n">done</span><span class="p">()</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">processor</span><span class="o">.</span><span class="n">tasks</span><span class="p">)</span>

    <span class="c1"># Wait for completion</span>
    <span class="k">await</span> <span class="n">processor</span><span class="o">.</span><span class="n">wait_for_completion</span><span class="p">()</span>

    <span class="c1"># All tasks should be done</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">done</span><span class="p">()</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">processor</span><span class="o">.</span><span class="n">tasks</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s2">&quot;processed_item1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;processed_item2&quot;</span><span class="p">,</span>
        <span class="s2">&quot;processed_item3&quot;</span>
    <span class="p">}</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_background_processing_with_delay</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that we can check progress before completion&quot;&quot;&quot;</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">BackgroundProcessor</span><span class="p">()</span>

    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;item1&quot;</span><span class="p">,</span> <span class="s2">&quot;item2&quot;</span><span class="p">,</span> <span class="s2">&quot;item3&quot;</span><span class="p">]</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">start_processing</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="c1"># Check immediately - nothing done yet</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># Wait a bit</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.15</span><span class="p">)</span>

    <span class="c1"># Some tasks should be done</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># Wait for all</span>
    <span class="k">await</span> <span class="n">processor</span><span class="o">.</span><span class="n">wait_for_completion</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
</code></pre></div>

<h3 id="testing-asyncioqueue">Testing asyncio.Queue</h3>
<p>Testing code that uses <code>asyncio.Queue</code> for producer-consumer patterns:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># queue_processor.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>

<span class="k">class</span><span class="w"> </span><span class="nc">QueueProcessor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Processes items from an async queue&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">producer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add items to the queue&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># Signal completion</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">consumer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process items from the queue&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">running</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Process item</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;processed_</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run producer and consumer concurrently&quot;&quot;&quot;</span>
        <span class="n">producer_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">producer</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
        <span class="n">consumer_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">consumer</span><span class="p">())</span>

        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">producer_task</span><span class="p">,</span> <span class="n">consumer_task</span><span class="p">)</span>
</code></pre></div>

<p>Test the queue processor:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_queue_processor.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">queue_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">QueueProcessor</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_queue_processing</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test producer-consumer pattern&quot;&quot;&quot;</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">QueueProcessor</span><span class="p">()</span>

    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;item1&quot;</span><span class="p">,</span> <span class="s2">&quot;item2&quot;</span><span class="p">,</span> <span class="s2">&quot;item3&quot;</span><span class="p">,</span> <span class="s2">&quot;item4&quot;</span><span class="p">,</span> <span class="s2">&quot;item5&quot;</span><span class="p">]</span>
    <span class="k">await</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span>
        <span class="sa">f</span><span class="s2">&quot;processed_item</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="p">}</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_queue_with_multiple_consumers</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test with multiple consumers processing concurrently&quot;&quot;&quot;</span>
    <span class="n">processor</span> <span class="o">=</span> <span class="n">QueueProcessor</span><span class="p">()</span>

    <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>

    <span class="c1"># Start multiple consumers</span>
    <span class="n">producer_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">producer</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
    <span class="n">consumer_tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">consumer</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Wait for producer</span>
    <span class="k">await</span> <span class="n">producer_task</span>

    <span class="c1"># Signal all consumers to stop</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">processor</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Wait for consumers</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">consumer_tasks</span><span class="p">)</span>

    <span class="c1"># All items should be processed</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">processor</span><span class="o">.</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">20</span>
</code></pre></div>

<h3 id="the-journey-testing-concurrent-code">The Journey: Testing Concurrent Code</h3>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Challenge</th>
<th>Solution</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Verify concurrency</td>
<td>Time-based assertions</td>
<td>Proved concurrent execution</td>
</tr>
<tr>
<td>2</td>
<td>Test concurrency limits</td>
<td>Track active task count</td>
<td>Verified semaphore works</td>
</tr>
<tr>
<td>3</td>
<td>Handle task failures</td>
<td>Test exception propagation</td>
<td>Understood default behavior</td>
</tr>
<tr>
<td>4</td>
<td>Collect all results and errors</td>
<td>Modified queue to capture errors</td>
<td>Graceful error handling</td>
</tr>
<tr>
<td>5</td>
<td>Test ordering and timing</td>
<td>Sort by completion time</td>
<td>Verified task scheduling</td>
</tr>
<tr>
<td>6</td>
<td>Test cancellation</td>
<td>Use asyncio.wait_for()</td>
<td>Proper timeout handling</td>
</tr>
</tbody>
</table>
<h3 id="decision-framework-testing-concurrent-code">Decision Framework: Testing Concurrent Code</h3>
<p><strong>Use time-based assertions when</strong>:
- Verifying that operations run concurrently
- Testing performance characteristics
- Ensuring operations don't block</p>
<p><strong>Use task tracking when</strong>:
- Verifying concurrency limits
- Testing semaphore/lock behavior
- Debugging race conditions</p>
<p><strong>Use asyncio.gather() when</strong>:
- Running multiple coroutines concurrently
- You want to collect all results
- You need to handle multiple exceptions</p>
<p><strong>Use asyncio.create_task() when</strong>:
- Starting background tasks
- You need to track individual task status
- Tasks should continue after function returns</p>
<p><strong>Use asyncio.Queue when</strong>:
- Implementing producer-consumer patterns
- You need backpressure control
- Multiple producers/consumers</p>
<h3 id="best-practices-for-testing-concurrent-code">Best Practices for Testing Concurrent Code</h3>
<ol>
<li><strong>Make timing assertions generous</strong>: Network and system delays can vary</li>
<li><strong>Use fixtures to clean up tasks</strong>: Prevent task leakage between tests</li>
<li><strong>Test both success and failure paths</strong>: Concurrent code has more failure modes</li>
<li><strong>Verify resource cleanup</strong>: Check that all tasks complete or are cancelled</li>
<li><strong>Test with different concurrency levels</strong>: Edge cases appear at boundaries</li>
<li><strong>Use mocking to control timing</strong>: Make tests deterministic and fast</li>
</ol>
<h3 id="final-implementation-complete-test-suite">Final Implementation: Complete Test Suite</h3>
<p>Here's a complete test suite for our task queue:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_task_queue_complete.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">task_queue_v2</span><span class="w"> </span><span class="kn">import</span> <span class="n">AsyncTaskQueue</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">queue</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Provide a fresh queue for each test&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">AsyncTaskQueue</span><span class="p">(</span><span class="n">max_concurrent</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">simple_task</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple task for testing&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">failing_task</span><span class="p">(</span><span class="n">should_fail</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Task that might fail&quot;&quot;&quot;</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">should_fail</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_empty_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test processing empty task list&quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">([])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_single_task</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test processing a single task&quot;&quot;&quot;</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;task1&quot;</span><span class="p">,</span> <span class="n">simple_task</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;result1&quot;</span><span class="p">,),</span> <span class="p">{})]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">succeeded</span>
    <span class="k">assert</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;result1&quot;</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_concurrent_execution</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that tasks run concurrently&quot;&quot;&quot;</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">timed_task</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;task1&quot;</span><span class="p">,</span> <span class="n">timed_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;result1&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task2&quot;</span><span class="p">,</span> <span class="n">timed_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;result2&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;task3&quot;</span><span class="p">,</span> <span class="n">timed_task</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;result3&quot;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="p">]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>
    <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="k">assert</span> <span class="n">elapsed</span> <span class="o">&lt;</span> <span class="mf">0.2</span>  <span class="c1"># Should be ~0.1s, not 0.3s</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_concurrency_limit</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that concurrency limit is enforced&quot;&quot;&quot;</span>
    <span class="c1"># This test would need task tracking as shown in v2</span>
    <span class="k">pass</span>  <span class="c1"># Implementation left as exercise</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_mixed_success_failure</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test handling of mixed success and failure&quot;&quot;&quot;</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;success1&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;ok1&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;failure1&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;bad1&quot;</span><span class="p">),</span> <span class="p">{}),</span>
        <span class="p">(</span><span class="s2">&quot;success2&quot;</span><span class="p">,</span> <span class="n">failing_task</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;ok2&quot;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="p">]</span>

    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

    <span class="n">successful</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">succeeded</span><span class="p">]</span>
    <span class="n">failed</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">succeeded</span><span class="p">]</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">successful</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">failed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_task_results_contain_timing</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that results include timing information&quot;&quot;&quot;</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;task1&quot;</span><span class="p">,</span> <span class="n">simple_task</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;result1&quot;</span><span class="p">,),</span> <span class="p">{})]</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">process_all</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">started_at</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">completed_at</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">duration</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">completed_at</span> <span class="o">&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">started_at</span>
</code></pre></div>

<p>This comprehensive test suite covers:
- Edge cases (empty queue, single task)
- Concurrent execution verification
- Concurrency limit enforcement
- Error handling
- Timing and metadata</p>
<p>You now have the tools to test any concurrent async code confidently.</p>
        </div>
        <div class="footer">
            Generated on 2025-12-03 10:37:05 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>