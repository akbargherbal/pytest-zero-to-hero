<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11 Testing Asynchronous Code</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">04 Testing Patterns and Advanced Scenarios</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-11-testing-asynchronous-code">Chapter 11: Testing Asynchronous Code</h1>
<h2 id="the-basics-of-asyncawait">The Basics of Async/Await</h2>
<h2 id="the-basics-of-asyncawait_1">The Basics of Async/Await</h2>
<p>Before we can test asynchronous code, we need a solid mental model of what it is and why it exists. Modern applications spend a lot of time waiting: waiting for a database query to return, for a web API to respond, or for a file to be read from a disk. This is called <strong>I/O-bound</strong> work.</p>
<p>Imagine a chef in a kitchen. A synchronous chef would:
1.  Put a pot of water on the stove to boil.
2.  Stare at the pot until it boils.
3.  Chop vegetables.</p>
<p>This is incredibly inefficient. The chef is blocked, doing nothing, while waiting for the water.</p>
<p>An asynchronous chef works differently:
1.  Put a pot of water on the stove to boil.
2.  While the water is heating up, start chopping vegetables.
3.  When the water boils, pause chopping and pour the pasta in.
4.  While the pasta cooks, finish chopping the vegetables.</p>
<p>The asynchronous chef can manage multiple tasks by switching between them whenever one is "waiting." This is the core idea behind Python's <code>asyncio</code>. The keywords <code>async</code> and <code>await</code> are the tools that let us write code like the asynchronous chef.</p>
<ul>
<li><code>async def</code>: This defines a function as a <strong>coroutine</strong>. It's a special kind of function that can be paused and resumed. Putting water on the stove is like starting a coroutine.</li>
<li><code>await</code>: This keyword says, "This is a waiting point. Pause this coroutine here, and let the event loop run other tasks until this one is ready to continue." This is the chef turning to chop vegetables while the water heats up.</li>
</ul>
<p>Let's see this in a simple Python example. We'll create a function that simulates fetching data from a slow network API.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/data_fetcher.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_data</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulates fetching data from a slow source.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Start fetching from </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
    <span class="c1"># asyncio.sleep is the asynchronous version of time.sleep.</span>
    <span class="c1"># It pauses the coroutine without blocking the entire program.</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done fetching from </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">source</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A main function to run our coroutine.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;API Server&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Received: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># asyncio.run() starts the event loop and runs the coroutine until it&#39;s complete.</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>

<p>If you run this file, you'll see the output with a 1-second delay, just as you'd expect.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>python<span class="w"> </span>src/data_fetcher.py
Start<span class="w"> </span>fetching<span class="w"> </span>from<span class="w"> </span>API<span class="w"> </span>Server...
Done<span class="w"> </span>fetching<span class="w"> </span>from<span class="w"> </span>API<span class="w"> </span>Server.
Received:<span class="w"> </span><span class="o">{</span><span class="s1">&#39;source&#39;</span>:<span class="w"> </span><span class="s1">&#39;API Server&#39;</span>,<span class="w"> </span><span class="s1">&#39;data&#39;</span>:<span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">]}</span>
</code></pre></div>

<p>The key takeaway is that an <code>async def</code> function doesn't run like a normal function. Calling it just creates a coroutine object. You need an event loop runner (like <code>asyncio.run()</code>) to actually execute it. This has a major implication for testing: vanilla pytest doesn't know how to run these coroutine objects.</p>
<h2 id="testing-coroutines-with-pytest-asyncio">Testing Coroutines with pytest-asyncio</h2>
<h2 id="testing-coroutines-with-pytest-asyncio_1">Testing Coroutines with pytest-asyncio</h2>
<p>Let's try to write a test for our <code>fetch_data</code> function using what we know so far.</p>
<h3 id="the-problem-pytest-doesnt-speak-async-natively">The Problem: Pytest Doesn't Speak Async Natively</h3>
<p>If you write a test like a regular function call, you'll get a warning, and the test won't actually run the asynchronous code.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_data_fetcher_problem.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.data_fetcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_data_incorrectly</span><span class="p">():</span>
    <span class="c1"># This just creates a coroutine object, it doesn&#39;t run it!</span>
    <span class="n">coro</span> <span class="o">=</span> <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;API Server&quot;</span><span class="p">)</span>
    <span class="c1"># This test will pass, but it doesn&#39;t actually test the coroutine&#39;s logic.</span>
    <span class="c1"># You&#39;ll get a RuntimeWarning from pytest.</span>
    <span class="k">assert</span> <span class="n">coro</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
</code></pre></div>

<p>Running this gives you a warning because the coroutine was never <code>await</code>ed.</p>
<div class="codehilite"><pre><span></span><code><span class="o">=============================</span><span class="w"> </span>warnings<span class="w"> </span><span class="nv">summary</span><span class="w"> </span><span class="o">=============================</span>
tests/test_data_fetcher_problem.py::test_fetch_data_incorrectly
<span class="w">  </span>/path/to/tests/test_data_fetcher_problem.py:6:<span class="w"> </span>RuntimeWarning:<span class="w"> </span>coroutine<span class="w"> </span><span class="s1">&#39;fetch_data&#39;</span><span class="w"> </span>was<span class="w"> </span>never<span class="w"> </span>awaited
<span class="w">    </span><span class="nv">coro</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>fetch_data<span class="o">(</span><span class="s2">&quot;API Server&quot;</span><span class="o">)</span>

--<span class="w"> </span>Docs:<span class="w"> </span>https://docs.pytest.org/en/stable/how-to/capture-warnings.html
<span class="o">========================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed,<span class="w"> </span><span class="m">1</span><span class="w"> </span>warning<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.01s<span class="w"> </span><span class="o">========================</span>
</code></pre></div>

<p>The test passed, but it didn't do what we wanted. It only tested that the function call created an object, not that the object, when run, produces the correct result.</p>
<h3 id="the-solution-pytest-asyncio">The Solution: <code>pytest-asyncio</code></h3>
<p>To bridge this gap, we use a powerful plugin called <code>pytest-asyncio</code>. It automatically handles the asyncio event loop for your tests.</p>
<p>First, install it:</p>
<div class="codehilite"><pre><span></span><code>pip<span class="w"> </span>install<span class="w"> </span>pytest-asyncio
</code></pre></div>

<p>Now, we can write our test correctly. We need to do two things:
1.  Define the test function with <code>async def</code>.
2.  Mark it with <code>@pytest.mark.asyncio</code>.</p>
<p>This marker tells <code>pytest-asyncio</code> that this is an asynchronous test that needs an event loop to run. Inside the test, we can now use the <code>await</code> keyword.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_data_fetcher.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.data_fetcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_data</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_data_successfully</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tests that our async function runs and returns the expected dict.&quot;&quot;&quot;</span>
    <span class="c1"># Now we can use &#39;await&#39; inside our test function</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;Test Source&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Test Source&quot;</span>
    <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>

<p>Let's run this test.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>tests/test_data_fetcher.py
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_data_fetcher.py::test_fetch_data_successfully
Start<span class="w"> </span>fetching<span class="w"> </span>from<span class="w"> </span>Test<span class="w"> </span>Source...
Done<span class="w"> </span>fetching<span class="w"> </span>from<span class="w"> </span>Test<span class="w"> </span>Source.
PASSED<span class="w">                               </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">1</span>.02s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<p>Success! The <code>pytest-asyncio</code> plugin detected the marker, set up an event loop, ran our <code>await fetch_data(...)</code> call, and then tore down the loop. We have successfully tested our first coroutine. The "magic" is simply the plugin providing the <code>asyncio.run()</code> equivalent for each test function marked appropriately.</p>
<h2 id="fixtures-for-async-tests">Fixtures for Async Tests</h2>
<h2 id="fixtures-for-async-tests_1">Fixtures for Async Tests</h2>
<p>Just like regular tests, async tests need setup and teardown logic. Pytest fixtures work seamlessly with <code>pytest-asyncio</code>, and they can even be asynchronous themselves. This is incredibly useful for setting up resources that require async operations, like a database connection pool or an API client session.</p>
<h3 id="asynchronous-fixtures">Asynchronous Fixtures</h3>
<p>To create an asynchronous fixture, you simply define it with <code>async def</code>. You can then <code>await</code> other coroutines inside it. Tests that use this fixture must also be <code>async def</code> functions.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/conftest.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AsyncDatabaseClient</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A mock async database client for demonstration.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_db_name</span> <span class="o">=</span> <span class="n">db_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_connected</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate an async connection.&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_connected</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Connected to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_db_name</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate an async disconnection.&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_connected</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Disconnected from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_db_name</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sql</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_connected</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ConnectionError</span><span class="p">(</span><span class="s2">&quot;Database is not connected&quot;</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;test_user&quot;</span><span class="p">}]</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">db_client</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An async fixture to set up and tear down a database client.&quot;&quot;&quot;</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">AsyncDatabaseClient</span><span class="p">(</span><span class="s2">&quot;test_db&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
    <span class="k">yield</span> <span class="n">client</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
</code></pre></div>

<p>Here, our <code>db_client</code> fixture is a coroutine. It creates a client, <code>await</code>s its connection, <code>yield</code>s the client to the test, and then <code>await</code>s its disconnection after the test is complete.</p>
<p>Now, let's use this fixture in a test.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_async_db.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_database_query</span><span class="p">(</span><span class="n">db_client</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests a query using the async db_client fixture.</span>
<span class="sd">    The test function must be async to use an async fixture.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">db_client</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM users;&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;test_user&quot;</span><span class="p">}]</span>
</code></pre></div>

<p>When you run this test, you'll see the connect and disconnect messages from the fixture, proving the setup and teardown logic ran correctly around the test.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v<span class="w"> </span>-s<span class="w"> </span>tests/test_async_db.py
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

tests/test_async_db.py::test_database_query
Connected<span class="w"> </span>to<span class="w"> </span>test_db!
PASSED
Disconnected<span class="w"> </span>from<span class="w"> </span>test_db!

<span class="o">==============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.43s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<h3 id="using-synchronous-fixtures-in-async-tests">Using Synchronous Fixtures in Async Tests</h3>
<p>You are not required to make all your fixtures async. Regular, synchronous fixtures work perfectly fine when passed to an async test.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/conftest.py (add this fixture)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">user_payload</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A regular, synchronous fixture.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="s2">&quot;test_user&quot;</span><span class="p">,</span> <span class="s2">&quot;email&quot;</span><span class="p">:</span> <span class="s2">&quot;test@example.com&quot;</span><span class="p">}</span>

<span class="c1"># tests/test_async_db.py (add this test)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_with_sync_and_async_fixtures</span><span class="p">(</span><span class="n">db_client</span><span class="p">,</span> <span class="n">user_payload</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This async test uses both an async fixture (db_client)</span>
<span class="sd">    and a sync fixture (user_payload).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Testing with payload: </span><span class="si">{</span><span class="n">user_payload</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">db_client</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM users;&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
</code></pre></div>

<p>This works exactly as you'd expect. Pytest resolves all fixtures first‚Äîawaiting the async ones‚Äîbefore running the async test body. The rule is simple: if your fixture needs to <code>await</code> something, make it <code>async def</code>. Otherwise, a regular <code>def</code> is fine.</p>
<h2 id="mocking-async-functions">Mocking Async Functions</h2>
<h2 id="mocking-async-functions_1">Mocking Async Functions</h2>
<p>Mocking is essential for isolating the code you're testing from its dependencies, especially slow or unreliable ones like network calls. However, mocking asynchronous functions presents a new challenge: the mock object itself must be "awaitable."</p>
<h3 id="the-problem-a-regular-mock-isnt-awaitable">The Problem: A Regular Mock Isn't Awaitable</h3>
<p>Let's go back to our <code>fetch_data</code> example. Imagine we have another function that uses it.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/data_processor.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.data_fetcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_data</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">process_data_from_source</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fetches and processes data.&quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_data</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="c1"># In a real app, more complex processing would happen here.</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Processed data for </span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> items.&quot;</span>
</code></pre></div>

<p>To test <code>process_data_from_source</code> in isolation, we must mock <code>fetch_data</code>. Let's see what happens if we try to use a standard <code>unittest.mock.Mock</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_data_processor_problem.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">patch</span><span class="p">,</span> <span class="n">Mock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.data_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">process_data_from_source</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_process_data_with_regular_mock</span><span class="p">():</span>
    <span class="n">mock_fetch</span> <span class="o">=</span> <span class="n">Mock</span><span class="p">(</span>
        <span class="n">return_value</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;mock&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>
    <span class="p">)</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s2">&quot;src.data_processor.fetch_data&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">mock_fetch</span><span class="p">):</span>
        <span class="c1"># This will fail!</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">process_data_from_source</span><span class="p">(</span><span class="s2">&quot;any_source&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;Processed data for mock with 2 items.&quot;</span>
</code></pre></div>

<p>Running this test results in a <code>TypeError</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="k">&gt; </span><span class="ge">      result = await process_data_from_source(&quot;any_source&quot;)</span>
...
<span class="k">&gt; </span><span class="ge">      data = await fetch_data(source)</span>
E       TypeError: object Mock can&#39;t be used in &#39;await&#39; expression
</code></pre></div>

<p>The error message is crystal clear. The <code>await</code> keyword expects an awaitable object (like a coroutine), but we gave it a regular <code>Mock</code> instance.</p>
<h3 id="the-solution-asyncmock">The Solution: <code>AsyncMock</code></h3>
<p>Since Python 3.8, the standard <code>unittest.mock</code> library includes <code>AsyncMock</code>, which is designed specifically for this purpose. An <code>AsyncMock</code> instance is awaitable, and it provides special assertion methods like <code>assert_awaited_once</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_data_processor.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">patch</span><span class="p">,</span> <span class="n">AsyncMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.data_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">process_data_from_source</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_process_data_with_async_mock</span><span class="p">():</span>
    <span class="c1"># Create an AsyncMock. It&#39;s awaitable!</span>
    <span class="c1"># We set the return value of the *awaited* mock.</span>
    <span class="n">mock_fetch</span> <span class="o">=</span> <span class="n">AsyncMock</span><span class="p">(</span>
        <span class="n">return_value</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;mock&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>
    <span class="p">)</span>

    <span class="c1"># Patch the function in the module where it is *used*.</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s2">&quot;src.data_processor.fetch_data&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">mock_fetch</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">process_data_from_source</span><span class="p">(</span><span class="s2">&quot;any_source&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;Processed data for mock with 2 items.&quot;</span>

    <span class="c1"># You can assert that the async mock was awaited.</span>
    <span class="n">mock_fetch</span><span class="o">.</span><span class="n">assert_awaited_once</span><span class="p">()</span>
    <span class="n">mock_fetch</span><span class="o">.</span><span class="n">assert_awaited_once_with</span><span class="p">(</span><span class="s2">&quot;any_source&quot;</span><span class="p">)</span>
</code></pre></div>

<p>This test now passes. By replacing <code>Mock</code> with <code>AsyncMock</code>, we provide an object that satisfies the <code>await</code> expression, allowing our test to run correctly while still isolating our function from the real <code>fetch_data</code> dependency.</p>
<h3 id="autospeccing-with-create_autospec">Autospeccing with <code>create_autospec</code></h3>
<p>A best practice when patching is to use <code>autospeccing</code> to ensure your mock has the same signature as the original object. This works perfectly with async functions too. <code>patch</code> will automatically use an <code>AsyncMock</code> if the target it's replacing is an <code>async</code> function.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_data_processor.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">patch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.data_processor</span><span class="w"> </span><span class="kn">import</span> <span class="n">process_data_from_source</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.data_fetcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_data</span> <span class="c1"># Import for autospeccing</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_process_data_with_autospec</span><span class="p">():</span>
    <span class="c1"># Using autospec=True is often the best approach.</span>
    <span class="c1"># It automatically creates an awaitable mock because fetch_data is an async def.</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s2">&quot;src.data_processor.fetch_data&quot;</span><span class="p">,</span> <span class="n">autospec</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">mock_fetch</span><span class="p">:</span>
        <span class="c1"># The return value must be configured on the mock</span>
        <span class="n">mock_fetch</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;mock_spec&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>

        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">process_data_from_source</span><span class="p">(</span><span class="s2">&quot;spec_source&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;Processed data for mock_spec with 3 items.&quot;</span>

    <span class="n">mock_fetch</span><span class="o">.</span><span class="n">assert_awaited_once_with</span><span class="p">(</span><span class="s2">&quot;spec_source&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Using <code>autospec=True</code> is highly recommended. It prevents you from mocking a function with the wrong arguments, which can hide bugs. If the signature of <code>fetch_data</code> changes, this test will fail, alerting you to the necessary update.</p>
<h2 id="common-pitfalls-in-async-testing">Common Pitfalls in Async Testing</h2>
<h2 id="common-pitfalls-in-async-testing_1">Common Pitfalls in Async Testing</h2>
<p>Asynchronous programming introduces new kinds of errors. Being able to recognize them in your test failures will save you a lot of debugging time.</p>
<h3 id="pitfall-1-forgetting-await">Pitfall 1: Forgetting <code>await</code></h3>
<p>This is by far the most common mistake. You call a coroutine function but forget to <code>await</code> the result.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pitfalls.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.data_fetcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_data</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_forgot_await</span><span class="p">():</span>
    <span class="c1"># PITFALL: We called fetch_data but didn&#39;t await it.</span>
    <span class="n">result_coro</span> <span class="o">=</span> <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;some_source&quot;</span><span class="p">)</span>

    <span class="c1"># This assertion is on the coroutine object, not its result!</span>
    <span class="c1"># This test will fail, but for a confusing reason.</span>
    <span class="k">assert</span> <span class="k">await</span> <span class="n">result_coro</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;some_source&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
    <span class="c1"># If the assertion was `assert result_coro is not None`, the test would</span>
    <span class="c1"># pass silently with a RuntimeWarning, which is even worse!</span>
</code></pre></div>

<p>When you forget to <code>await</code> a call, you get a coroutine object back instead of the function's result. Your test might fail on a later assertion, or it might even pass if you're not careful, while printing a <code>RuntimeWarning: coroutine '...' was never awaited</code>.</p>
<p><strong>The Fix:</strong> Always be vigilant about <code>await</code>ing any call to an <code>async def</code> function. If you see that warning, it's a red flag that your test isn't actually executing the code you think it is.</p>
<h3 id="pitfall-2-using-blocking-io-in-async-tests">Pitfall 2: Using Blocking I/O in Async Tests</h3>
<p>The purpose of <code>asyncio</code> is to prevent the program from blocking on I/O. If you use a blocking call like <code>time.sleep()</code> instead of <code>asyncio.sleep()</code>, you defeat the purpose and can cause problems for the event loop.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pitfalls.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_blocking_sleep</span><span class="p">():</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>

    <span class="c1"># PITFALL: Using time.sleep() blocks the entire event loop.</span>
    <span class="c1"># No other async tasks could run during this second.</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># This is the correct, non-blocking way.</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="n">duration</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
    <span class="k">assert</span> <span class="n">duration</span> <span class="o">&gt;</span> <span class="mf">1.1</span>
</code></pre></div>

<p>While this test will pass, using <code>time.sleep()</code> is an anti-pattern in async code. In a simple test, it's less harmful, but in a complex application, it can grind everything to a halt. Always use the <code>async</code> versions of libraries when working in an async context (e.g., <code>httpx</code> instead of <code>requests</code>, <code>asyncpg</code> instead of <code>psycopg2</code>).</p>
<h3 id="pitfall-3-manually-managing-the-event-loop">Pitfall 3: Manually Managing the Event Loop</h3>
<p><code>pytest-asyncio</code> provides an event loop for you. In almost all cases, you should not try to manage it yourself. Code like <code>loop = asyncio.get_event_loop()</code> or <code>asyncio.run()</code> inside a test is usually a sign that something is wrong.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pitfalls.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.data_fetcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_data</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_manual_loop_management_is_unnecessary</span><span class="p">():</span>
    <span class="c1"># PITFALL: You don&#39;t need to do this.</span>
    <span class="c1"># pytest-asyncio provides the loop.</span>
    <span class="c1"># In some complex cases this can even cause errors.</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1"># The test body already runs inside the loop context.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;source&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
</code></pre></div>

<p><strong>The Fix:</strong> Trust the plugin. Write your test code with <code>async def</code> and <code>await</code>, and let <code>pytest-asyncio</code> handle the loop setup and teardown. The only time you might need to interact with the loop is for advanced scheduling tasks, which is rare for most application testing.</p>
<h2 id="testing-concurrent-code">Testing Concurrent Code</h2>
<h2 id="testing-concurrent-code_1">Testing Concurrent Code</h2>
<p>The real power of <code>asyncio</code> shines when you run multiple I/O-bound tasks concurrently. A common pattern is to use <code>asyncio.gather()</code> to start several tasks and wait for them all to complete. Testing this is a great way to combine our knowledge of async tests and mocking.</p>
<p>Let's define a function that fetches data from multiple sources concurrently.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/concurrent_fetcher.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.data_fetcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_data</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_all_data</span><span class="p">(</span><span class="n">sources</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fetches data from multiple sources concurrently.&quot;&quot;&quot;</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
        <span class="c1"># Create a task for each coroutine. This schedules them on the event loop.</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">fetch_data</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
        <span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="c1"># asyncio.gather() waits for all tasks in the sequence to complete.</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>
</code></pre></div>

<p>This function takes a list of sources, creates a "task" for each <code>fetch_data</code> call, and then uses <code>asyncio.gather</code> to run them all at the same time. If each <code>fetch_data</code> call takes 1 second, fetching three sources will still take only about 1 second, not 3.</p>
<p>How do we test this? We need to mock <code>fetch_data</code> in a way that allows us to provide different return values for different calls. The <code>side_effect</code> attribute of a mock is perfect for this.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_concurrent_fetcher.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">patch</span><span class="p">,</span> <span class="n">AsyncMock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.concurrent_fetcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_all_data</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">asyncio</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_fetch_all_data</span><span class="p">():</span>
    <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;API_1&quot;</span><span class="p">,</span> <span class="s2">&quot;API_2&quot;</span><span class="p">,</span> <span class="s2">&quot;DB_1&quot;</span><span class="p">]</span>

    <span class="c1"># We can use side_effect to return different values on each await.</span>
    <span class="n">mock_results</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;API_1&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]},</span>
        <span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;API_2&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span>
        <span class="p">{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="s2">&quot;DB_1&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]},</span>
    <span class="p">]</span>

    <span class="c1"># Patch the function where it is used.</span>
    <span class="k">with</span> <span class="n">patch</span><span class="p">(</span><span class="s2">&quot;src.concurrent_fetcher.fetch_data&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">AsyncMock</span><span class="p">())</span> <span class="k">as</span> <span class="n">mock_fetch</span><span class="p">:</span>
        <span class="n">mock_fetch</span><span class="o">.</span><span class="n">side_effect</span> <span class="o">=</span> <span class="n">mock_results</span>

        <span class="c1"># Run the function under test</span>
        <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_all_data</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>

    <span class="c1"># Assert that the mock was awaited for each source</span>
    <span class="k">assert</span> <span class="n">mock_fetch</span><span class="o">.</span><span class="n">await_count</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">mock_fetch</span><span class="o">.</span><span class="n">assert_any_await</span><span class="p">(</span><span class="s2">&quot;API_1&quot;</span><span class="p">)</span>
    <span class="n">mock_fetch</span><span class="o">.</span><span class="n">assert_any_await</span><span class="p">(</span><span class="s2">&quot;API_2&quot;</span><span class="p">)</span>
    <span class="n">mock_fetch</span><span class="o">.</span><span class="n">assert_any_await</span><span class="p">(</span><span class="s2">&quot;DB_1&quot;</span><span class="p">)</span>

    <span class="c1"># Assert that the results from gather are correct</span>
    <span class="k">assert</span> <span class="n">results</span> <span class="o">==</span> <span class="n">mock_results</span>
</code></pre></div>

<p>This test effectively validates the logic of <code>fetch_all_data</code>:
1.  We patch the dependency, <code>fetch_data</code>, with an <code>AsyncMock</code>.
2.  We use <code>side_effect</code> to provide an iterable of return values. The mock will return the next item from the iterable each time it is awaited.
3.  We call our concurrent function.
4.  We assert that the mock was awaited three times, once for each source. <code>assert_any_await</code> is useful here because <code>gather</code> does not guarantee the execution order.
5.  Finally, we check that the aggregated result is what we expect.</p>
<p>This pattern gives you a powerful way to test the orchestration logic of your concurrent code without performing any actual I/O.</p>
        </div>
        <div class="footer">
            Generated on 2025-11-22 16:29:18 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>