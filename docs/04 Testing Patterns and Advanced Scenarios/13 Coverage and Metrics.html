<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>13 Coverage and Metrics</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">04 Testing Patterns and Advanced Scenarios</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-13-coverage-and-metrics">Chapter 13: Coverage and Metrics</h1>
<h2 id="introduction-to-code-coverage">Introduction to Code Coverage</h2>
<h2 id="what-is-code-coverage">What is Code Coverage?</h2>
<p>Imagine you've written a detailed set of instructions for a robot to navigate a maze. You send the robot in, and it successfully finds the exit. Your instructions work! But a question remains: did the robot follow every single path you laid out, or did it only use the main corridors, leaving entire sections of the maze unexplored?</p>
<p><strong>Code coverage</strong> is the tool that answers this question for your software. It measures which lines of your application code are executed by your test suite. It doesn't tell you if your tests are <em>good</em>, but it tells you what parts of your code your tests <em>didn't even touch</em>.</p>
<h3 id="why-does-it-matter">Why Does It Matter?</h3>
<p>Coverage is a powerful diagnostic tool for three main reasons:</p>
<ol>
<li><strong>It reveals untested code:</strong> The most immediate benefit is seeing exactly which functions, branches, or statements are not exercised by any of your tests. These are blind spots in your quality assurance.</li>
<li><strong>It provides a safety net against dead code:</strong> If a block of code has 0% coverage and has been that way for a long time, it might be "dead code"‚Äîlegacy logic that is no longer used and can potentially be removed, simplifying your codebase.</li>
<li><strong>It guides your testing efforts:</strong> A coverage report acts like a map, highlighting areas that need more attention. Instead of guessing where to write the next test, you can focus on the parts of your application with the lowest coverage.</li>
</ol>
<h3 id="the-critical-limitation-coverage-is-not-a-goal">The Critical Limitation: Coverage is Not a Goal</h3>
<p>It's tempting to see a metric like "95% coverage" and treat it as a grade. This is a dangerous trap. A test can execute a line of code without actually verifying its behavior.</p>
<p>Consider this function:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/calculator.py</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># A subtle bug: this should be a + b</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
</code></pre></div>

<p>And this test:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_calculator.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.calculator</span><span class="w"> </span><span class="kn">import</span> <span class="n">add</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_add_runs</span><span class="p">():</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># We call the function, but don&#39;t check the result!</span>
</code></pre></div>

<p>This test will give you <strong>100% coverage</strong> for the <code>add</code> function because every line was executed. However, the test is useless‚Äîit would pass even though the function is completely broken.</p>
<p>Remember the core principle: <strong>Coverage tells you what you <em>haven't</em> tested; it doesn't tell you how <em>well</em> you've tested it.</strong></p>
<p>Throughout this chapter, we'll learn how to use coverage as a tool to guide our testing, not as a target to be blindly pursued.</p>
<h2 id="installing-and-using-pytest-cov">Installing and Using pytest-cov</h2>
<h2 id="installing-and-using-pytest-cov_1">Installing and Using pytest-cov</h2>
<p>The most popular tool for measuring code coverage with pytest is a plugin called <code>pytest-cov</code>. It integrates seamlessly with pytest and the underlying <code>coverage.py</code> library.</p>
<h3 id="installation">Installation</h3>
<p>Installation is a single command using pip. Make sure your virtual environment is activated first.</p>
<div class="codehilite"><pre><span></span><code>pip<span class="w"> </span>install<span class="w"> </span>pytest-cov
</code></pre></div>

<p>That's it. The plugin is now available to pytest.</p>
<h3 id="a-simple-project-to-test">A Simple Project to Test</h3>
<p>Let's create a small project to see <code>pytest-cov</code> in action. Our project will validate user account information.</p>
<p><strong>Project Structure:</strong></p>
<div class="codehilite"><pre><span></span><code>pytest_project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ user_validator.py
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ test_user_validator.py
</code></pre></div>

<p>Here is the application code:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/user_validator.py</span>

<span class="k">def</span><span class="w"> </span><span class="nf">is_valid_username</span><span class="p">(</span><span class="n">username</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if a username is valid.</span>
<span class="sd">    - Must be between 3 and 20 characters.</span>
<span class="sd">    - Must contain only alphanumeric characters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">username</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">username</span><span class="o">.</span><span class="n">isalnum</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">is_strong_password</span><span class="p">(</span><span class="n">password</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if a password is strong.</span>
<span class="sd">    - Must be at least 8 characters long.</span>
<span class="sd">    - Must contain at least one digit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">password</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">password</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>

<p>And here is our initial test file, which only tests the username validation:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_user_validator.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.user_validator</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_valid_username</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_is_valid_username_happy_path</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_valid_username</span><span class="p">(</span><span class="s2">&quot;testuser123&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_is_valid_username_too_short</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_valid_username</span><span class="p">(</span><span class="s2">&quot;hi&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_is_valid_username_contains_symbols</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_valid_username</span><span class="p">(</span><span class="s2">&quot;user-name!&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span>
</code></pre></div>

<h3 id="running-your-first-coverage-report">Running Your First Coverage Report</h3>
<p>To run pytest with coverage, you use the <code>--cov</code> flag. You should specify the package or directory containing your source code. In our case, that's <code>src</code>.</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>--cov<span class="o">=</span>src
</code></pre></div>

<p>When you run this, you'll see the standard pytest output, followed by a new coverage summary table:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
...
tests/test_user_validator.py ...                                         [100%]

----------- coverage: platform linux, python 3.10.4-final-0 -----------
Name                      Stmts   Miss  Cover
---------------------------------------------
src/user_validator.py        12      4    67%
---------------------------------------------
TOTAL                        12      4    67%

============================== 3 passed in 0.01s ===============================
</code></pre></div>

<p>Instantly, we have valuable data. Our test suite executed 12 statements in <code>user_validator.py</code>, but missed 4 of them, resulting in 67% coverage. We can see at a glance that our <code>is_strong_password</code> function is completely untested.</p>
<h2 id="understanding-coverage-reports">Understanding Coverage Reports</h2>
<h2 id="understanding-coverage-reports_1">Understanding Coverage Reports</h2>
<p>The default terminal report is great for a quick summary, but to really dig into the details, <code>pytest-cov</code> can generate much richer reports.</p>
<h3 id="the-terminal-report-explained">The Terminal Report Explained</h3>
<p>Let's look at that table again:</p>
<div class="codehilite"><pre><span></span><code><span class="gh">Name                      Stmts   Miss  Cover</span>
<span class="gh">---------------------------------------------</span>
src/user_validator.py        12      4    67%
</code></pre></div>

<ul>
<li><strong>Name:</strong> The file being analyzed.</li>
<li><strong>Stmts:</strong> The total number of executable statements in the file. Comments and blank lines are not counted.</li>
<li><strong>Miss:</strong> The number of statements that were <em>not</em> executed by any test.</li>
<li><strong>Cover:</strong> The coverage percentage, calculated as <code>(Stmts - Miss) / Stmts</code>.</li>
</ul>
<p>You can add a <code>--cov-report term-missing</code> flag to also see which line numbers were missed, right in your terminal.</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>--cov<span class="o">=</span>src<span class="w"> </span>--cov-report<span class="w"> </span>term-missing
</code></pre></div>

<p>The output will now include a <code>Missing</code> column:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">-----------</span><span class="c"> coverage: platform linux</span><span class="nt">,</span><span class="c"> python 3</span><span class="nt">.</span><span class="c">10</span><span class="nt">.</span><span class="c">4</span><span class="nb">-</span><span class="c">final</span><span class="nb">-</span><span class="c">0 </span><span class="nb">-----------</span>
<span class="c">Name                      Stmts   Miss  Cover   Missing</span>
<span class="nb">-------------------------------------------------------</span>
<span class="c">src/user_validator</span><span class="nt">.</span><span class="c">py        12      4    67%   16</span><span class="nb">-</span><span class="c">22</span>
<span class="nb">-------------------------------------------------------</span>
<span class="c">TOTAL                        12      4    67%</span>

<span class="c">============================== 3 passed in 0</span><span class="nt">.</span><span class="c">01s ===============================</span>
</code></pre></div>

<p>The <code>Missing</code> column tells us that lines 16 through 22 were not executed. This corresponds exactly to our <code>is_strong_password</code> function.</p>
<h3 id="the-interactive-html-report">The Interactive HTML Report</h3>
<p>The most powerful tool for analyzing coverage is the HTML report. It generates an interactive website that visualizes exactly which lines were covered and which were missed in your source code.</p>
<p>Generate it with the <code>--cov-report=html</code> flag.</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>--cov<span class="o">=</span>src<span class="w"> </span>--cov-report<span class="o">=</span>html
</code></pre></div>

<p>This command creates a new directory named <code>htmlcov/</code> in your project root. Open the <code>index.html</code> file inside it with your web browser.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># On macOS</span>
open<span class="w"> </span>htmlcov/index.html

<span class="c1"># On Linux</span>
xdg-open<span class="w"> </span>htmlcov/index.html

<span class="c1"># On Windows</span>
start<span class="w"> </span>htmlcov/index.html
</code></pre></div>

<p>You will see a summary page. Clicking on <code>src/user_validator.py</code> takes you to a detailed view of the source file.</p>
<ul>
<li><strong>Green lines</strong> were executed by your tests.</li>
<li><strong>Red lines</strong> were missed.</li>
<li><strong>Gray lines</strong> (like comments or docstrings) are not executable and are ignored.</li>
</ul>
<p>This visual feedback is incredibly intuitive. You can immediately see the entire <code>is_strong_password</code> function is red, confirming it's completely untested. This report is the primary tool you'll use to identify and analyze coverage gaps.</p>
<h2 id="coverage-as-a-quality-gate">Coverage as a Quality Gate</h2>
<h2 id="coverage-as-a-quality-gate_1">Coverage as a Quality Gate</h2>
<p>One of the most powerful applications of coverage metrics is to enforce a minimum testing standard in your project, especially in an automated environment like a CI/CD pipeline (see Chapter 16). You can configure pytest to fail the entire test suite if coverage drops below a certain threshold. This is called a "quality gate."</p>
<h3 id="failing-the-build-on-low-coverage">Failing the Build on Low Coverage</h3>
<p>The <code>--cov-fail-under</code> flag tells <code>pytest-cov</code> to exit with a non-zero status code (which signals failure to automation tools) if the total coverage is less than the specified minimum.</p>
<p>Let's try to enforce 80% coverage on our project. We know our current coverage is 67%, so this command should fail.</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>--cov<span class="o">=</span>src<span class="w"> </span>--cov-fail-under<span class="o">=</span><span class="m">80</span>
</code></pre></div>

<p>The test run will proceed as usual, but at the end, you'll see a new error message:</p>
<div class="codehilite"><pre><span></span><code><span class="nt">...</span>
<span class="nb">-----------</span><span class="c"> coverage: platform linux</span><span class="nt">,</span><span class="c"> python 3</span><span class="nt">.</span><span class="c">10</span><span class="nt">.</span><span class="c">4</span><span class="nb">-</span><span class="c">final</span><span class="nb">-</span><span class="c">0 </span><span class="nb">-----------</span>
<span class="c">Name                      Stmts   Miss  Cover</span>
<span class="nb">---------------------------------------------</span>
<span class="c">src/user_validator</span><span class="nt">.</span><span class="c">py        12      4    67%</span>
<span class="nb">---------------------------------------------</span>
<span class="c">TOTAL                        12      4    67%</span>
<span class="c">FAIL: Coverage less than configured fail</span><span class="nb">-</span><span class="c">under=80% (is 67%)</span>
<span class="c">=========================== 1 failed</span><span class="nt">,</span><span class="c"> 3 passed in 0</span><span class="nt">.</span><span class="c">02s ============================</span>
</code></pre></div>

<p>Pytest reports a failure, even though all our tests passed! This is the quality gate in action. It prevents you from merging code that reduces the overall test coverage of the project.</p>
<h3 id="meeting-the-threshold">Meeting the Threshold</h3>
<p>Let's add tests for <code>is_strong_password</code> to meet our 80% goal.</p>
<p>Add these tests to <code>tests/test_user_validator.py</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_user_validator.py</span>
<span class="c1"># ... (existing tests) ...</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.user_validator</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_strong_password</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_is_strong_password_happy_path</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_strong_password</span><span class="p">(</span><span class="s2">&quot;Str0ngP@ss!&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_is_strong_password_too_short</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_strong_password</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_is_strong_password_no_digit</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_strong_password</span><span class="p">(</span><span class="s2">&quot;StrongPassword&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span>
</code></pre></div>

<p>Now, run the command again:</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>--cov<span class="o">=</span>src<span class="w"> </span>--cov-fail-under<span class="o">=</span><span class="m">80</span>
</code></pre></div>

<p>The result is a resounding success:</p>
<div class="codehilite"><pre><span></span><code>============================= test session starts ==============================
...
tests/test_user_validator.py ......                                      [100%]

----------- coverage: platform linux, python 3.10.4-final-0 -----------
Name                      Stmts   Miss  Cover
---------------------------------------------
src/user_validator.py        12      0   100%
---------------------------------------------
TOTAL                        12      0   100%
--cov-fail-under is set to 80%, measured 100% - PASSED
============================== 6 passed in 0.01s ===============================
</code></pre></div>

<p>Our coverage is now 100%, easily clearing the 80% bar. The build passes. By setting this gate, you ensure that as the codebase grows, the test suite grows with it.</p>
<h3 id="choosing-a-threshold">Choosing a Threshold</h3>
<p>Don't immediately set <code>--cov-fail-under=100</code>. Start with a realistic number based on your project's current state (e.g., 70% or 80%). The goal is to prevent coverage from <em>decreasing</em>. You can gradually increase the threshold over time as you improve your test suite.</p>
<h2 id="coverage-gaps-and-dead-code">Coverage Gaps and Dead Code</h2>
<h2 id="coverage-gaps-and-dead-code_1">Coverage Gaps and Dead Code</h2>
<p>Coverage reports are most useful for finding two things: code paths you forgot to test, and code that might not be used at all.</p>
<h3 id="analyzing-branch-coverage-gaps">Analyzing Branch Coverage Gaps</h3>
<p>Let's modify our <code>is_valid_username</code> function to include a special case: admin users can have symbols.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># src/user_validator.py</span>

<span class="k">def</span><span class="w"> </span><span class="nf">is_valid_username</span><span class="p">(</span><span class="n">username</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if a username is valid.</span>
<span class="sd">    - Must be between 3 and 20 characters.</span>
<span class="sd">    - Must contain only alphanumeric characters, unless it&#39;s an admin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">username</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;admin_&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">username</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">20</span>  <span class="c1"># Admins can have symbols</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">username</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">username</span><span class="o">.</span><span class="n">isalnum</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="c1"># ... is_strong_password remains the same ...</span>
</code></pre></div>

<p>Our existing tests don't know about this new "admin" logic. Let's run the coverage report again.</p>
<div class="codehilite"><pre><span></span><code>pytest<span class="w"> </span>--cov<span class="o">=</span>src<span class="w"> </span>--cov-report<span class="o">=</span>html
</code></pre></div>

<p>Now, when you view the HTML report for <code>user_validator.py</code>, you'll see something new. The line <code>if username.startswith("admin_"):</code> will be green, but the line <code>return 3 &lt;= len(username) &lt;= 20</code> will be red.</p>
<p>This is a <strong>branch coverage gap</strong>. Our tests executed the <code>if</code> condition, but it always evaluated to <code>False</code>, so the code inside the <code>if</code> block was never run. The report makes this gap obvious.</p>
<p>To fix it, we add a test for the admin case:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_user_validator.py</span>
<span class="c1"># ...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_is_valid_username_admin_can_have_symbols</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_valid_username</span><span class="p">(</span><span class="s2">&quot;admin_user-1&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span>
</code></pre></div>

<p>Running the coverage report again will show this line turning green, closing the gap.</p>
<h3 id="identifying-dead-code">Identifying Dead Code</h3>
<p>Sometimes, a coverage report reveals code that isn't just untested, but is actually unreachable. This might be a sign of "dead code" that can be safely removed. If you find a function with 0% coverage that no part of your application seems to call, it's a strong candidate for deletion. This helps keep your codebase clean and maintainable.</p>
<h3 id="excluding-code-from-coverage">Excluding Code from Coverage</h3>
<p>Not all code needs to be tested. You might have debugging helpers, compatibility fallbacks for old Python versions, or abstract methods that are meant to be implemented by subclasses. Forcing 100% coverage in these cases is counterproductive.</p>
<p>You can tell <code>coverage.py</code> to ignore a line by adding a <code># pragma: no cover</code> comment.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">complex_debug_helper</span><span class="p">():</span>
    <span class="c1"># This function is only for interactive debugging sessions,</span>
    <span class="c1"># it&#39;s hard to test and not part of the core logic.</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pdb</span><span class="p">;</span> <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span> <span class="c1"># pragma: no cover</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_os_specific_path</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;C:</span><span class="se">\\</span><span class="s2">Users</span><span class="se">\\</span><span class="s2">Default&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We only run tests on Linux, so this branch is never hit.</span>
        <span class="k">return</span> <span class="s2">&quot;/home/default&quot;</span> <span class="c1"># pragma: no cover</span>
</code></pre></div>

<p>Use <code>pragma: no cover</code> judiciously. It's a declaration that you are <em>intentionally</em> not testing a piece of code. It should be used for code that is genuinely untestable or not part of the production logic, not as a shortcut to silence a failing coverage report.</p>
<h2 id="achieving-meaningful-coverage-not-just-high-percentages">Achieving Meaningful Coverage (Not Just High Percentages)</h2>
<h2 id="achieving-meaningful-coverage-not-just-high-percentages_1">Achieving Meaningful Coverage (Not Just High Percentages)</h2>
<p>We end this chapter with the most important lesson: chasing a 100% coverage score is a fool's errand. This leads to a phenomenon called <strong>"Coverage Theater"</strong>‚Äîwriting low-value tests just to make the numbers look good, without actually improving software quality.</p>
<h3 id="the-pitfall-a-useless-test-with-100-coverage">The Pitfall: A Useless Test with 100% Coverage</h3>
<p>Let's revisit our <code>user_validator</code> module. Imagine a developer is told they <em>must</em> achieve 100% coverage. They could write this single, terrible test:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/a_bad_test.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src</span><span class="w"> </span><span class="kn">import</span> <span class="n">user_validator</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_to_get_100_percent_coverage</span><span class="p">():</span>
    <span class="c1"># Call functions with various inputs to hit all lines</span>
    <span class="n">user_validator</span><span class="o">.</span><span class="n">is_valid_username</span><span class="p">(</span><span class="s2">&quot;testuser&quot;</span><span class="p">)</span>
    <span class="n">user_validator</span><span class="o">.</span><span class="n">is_valid_username</span><span class="p">(</span><span class="s2">&quot;ad&quot;</span><span class="p">)</span>
    <span class="n">user_validator</span><span class="o">.</span><span class="n">is_valid_username</span><span class="p">(</span><span class="s2">&quot;admin_user&quot;</span><span class="p">)</span>
    <span class="n">user_validator</span><span class="o">.</span><span class="n">is_valid_username</span><span class="p">(</span><span class="s2">&quot;bad-user&quot;</span><span class="p">)</span>

    <span class="n">user_validator</span><span class="o">.</span><span class="n">is_strong_password</span><span class="p">(</span><span class="s2">&quot;GoodPass123&quot;</span><span class="p">)</span>
    <span class="n">user_validator</span><span class="o">.</span><span class="n">is_strong_password</span><span class="p">(</span><span class="s2">&quot;short&quot;</span><span class="p">)</span>
    <span class="n">user_validator</span><span class="o">.</span><span class="n">is_strong_password</span><span class="p">(</span><span class="s2">&quot;nodigits&quot;</span><span class="p">)</span>

    <span class="c1"># No assertions!</span>
    <span class="k">assert</span> <span class="kc">True</span>
</code></pre></div>

<p>If you run a coverage report on this test, it will proudly announce <strong>100% coverage</strong>. Every line in <code>user_validator.py</code> was executed. Yet, this test provides <strong>zero value</strong>. If we introduced a bug into any of the validation functions, this test would still pass. It ensures the code runs without crashing, but it doesn't verify that the code is <em>correct</em>.</p>
<p>This is the danger of treating coverage as a goal.</p>
<h3 id="the-philosophy-coverage-as-a-guide">The Philosophy: Coverage as a Guide</h3>
<p>The healthy way to use code coverage is as a diagnostic tool, not a success metric. Your goal is not "100% coverage"; your goal is a "well-tested, reliable application." Coverage helps you get there.</p>
<p>Follow this workflow:</p>
<ol>
<li><strong>Write tests that verify behavior.</strong> Focus on the requirements. What should the function do with valid input? What should it do with invalid input? What about edge cases (empty strings, zero, <code>None</code>)? Write clear, focused tests with strong assertions for each behavior.</li>
<li><strong>Run the coverage report.</strong> After writing your behavior-driven tests, run the coverage report.</li>
<li><strong>Analyze the gaps.</strong> Look at the red lines in the HTML report. For each missed line or branch, ask yourself: <strong>"What user behavior or system state corresponds to this piece of code?"</strong></li>
<li><strong>Write a new test for that behavior.</strong> The answer to the question above tells you what your next test should be. You're not writing a test "to make a line green." You're writing a test "to verify the admin username logic," which has the <em>side effect</em> of making the line green.</li>
</ol>
<p>Coverage doesn't tell you if your assertions are good. It doesn't tell you if you've tested enough edge cases. It only tells you which parts of your code have <em>zero</em> tests. It's the starting point for investigation, not the final grade. A high coverage score is often a <em>byproduct</em> of a good test suite, not the purpose of it.</p>
        </div>
        <div class="footer">
            Generated on 2025-11-22 16:29:18 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>