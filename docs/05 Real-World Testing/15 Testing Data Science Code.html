<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15 Testing Data Science Code</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">05 Real-World Testing</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-15-testing-data-science-code">Chapter 15: Testing Data Science Code</h1>
<h2 id="challenges-in-data-science-testing">Challenges in Data Science Testing</h2>
<h2 id="challenges-in-data-science-testing_1">Challenges in Data Science Testing</h2>
<p>Testing standard software is often about deterministic logic: if you provide input A, you must always get output B. A user's password hash must be exact. A sorted list must be perfectly ordered.</p>
<p>Data science code operates in a world of statistics, probabilities, and approximations. This introduces a unique set of challenges that require a shift in our testing mindset. Before we write any code, let's understand the landscape we're navigating.</p>
<h3 id="1-floating-point-precision">1. Floating-Point Precision</h3>
<p>Computers cannot represent all decimal numbers perfectly. This tiny imprecision means that calculations involving floating-point numbers (like <code>3.14159</code>) can lead to unexpected results. The classic example is <code>0.1 + 0.2</code>, which does not exactly equal <code>0.3</code> in most programming languages. For data science, where almost every calculation involves floats, direct equality checks (<code>==</code>) are a recipe for failing tests.</p>
<h3 id="2-large-and-complex-data">2. Large and Complex Data</h3>
<p>Machine learning models are trained on datasets that can be gigabytes or even terabytes in size. You cannot and should not load your entire production dataset into a unit test. Our tests must be fast and self-contained, which means we need strategies for working with small, representative samples of data that capture the essential characteristics (and edge cases) of the real thing.</p>
<h3 id="3-stochasticity-randomness">3. Stochasticity (Randomness)</h3>
<p>Many algorithms in data science are stochastic, meaning they involve a random element. Examples include:
-   Randomly splitting data into training and testing sets.
-   Initializing model weights randomly.
-   Algorithms like Stochastic Gradient Descent.</p>
<p>If you train the same model on the same data twice, you might get two slightly different models. A test that asserts a specific prediction value will be "flaky"‚Äîsometimes passing, sometimes failing. We need to test the <em>behavior</em> of the model, not a specific random outcome.</p>
<h3 id="4-long-running-processes">4. Long-Running Processes</h3>
<p>Training a deep learning model can take hours, days, or even weeks. A core principle of a good test suite is that it runs quickly, providing feedback in seconds or minutes. We cannot include model training in our standard test suite. Instead, we often test with pre-trained models or models trained on trivial datasets that finish in milliseconds.</p>
<h3 id="5-correctness-is-statistical-not-absolute">5. "Correctness" is Statistical, Not Absolute</h3>
<p>How do you know if a prediction model is "correct"? Its performance is measured with statistical metrics like accuracy, precision, or Mean Squared Error. A model with 95% accuracy is considered "good," but it's still "wrong" 5% of the time. We cannot write a simple <code>assert model.predict(input) == expected_output</code> for every case. Our tests must focus on properties and contracts, not on getting every single prediction right.</p>
<h3 id="6-the-environment-and-dependencies">6. The Environment and Dependencies</h3>
<p>Data science projects often have a fragile web of dependencies: specific versions of NumPy, Pandas, Scikit-learn, PyTorch, or TensorFlow. A minor version change in one library can subtly change numerical results, causing tests to fail. Managing this environment is a critical part of ensuring tests are reliable and reproducible.</p>
<p>These challenges might seem daunting, but they are all solvable. The key is to adapt our testing strategies from asserting exact outcomes to verifying stable behaviors, contracts, and properties. In the following sections, we'll tackle each of these challenges with practical patterns and tools.</p>
<h2 id="testing-data-processing-functions">Testing Data Processing Functions</h2>
<h2 id="testing-data-processing-functions_1">Testing Data Processing Functions</h2>
<p>The foundation of any data science pipeline is data processing: cleaning, transforming, and feature engineering. These functions are often pure and deterministic, making them perfect candidates for traditional unit testing. If you can ensure your data processing code is robust, you can have much higher confidence in the models that consume that data.</p>
<p>Let's imagine we have a simple function to process a dataset of house listings. It should convert a price column from a string to a number and create a new feature for the age of the house.</p>
<p>Here's our data processing module.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># data_processing.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="k">def</span><span class="w"> </span><span class="nf">preprocess_housing_data</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cleans and prepares housing data for modeling.</span>

<span class="sd">    - Converts &#39;price&#39; from string (e.g., &quot;$500,000&quot;) to float.</span>
<span class="sd">    - Calculates &#39;house_age&#39; from &#39;year_built&#39;.</span>
<span class="sd">    - Drops rows with missing values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># 1. Convert price to numeric</span>
    <span class="k">if</span> <span class="s1">&#39;price&#39;</span> <span class="ow">in</span> <span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s1">&#39;\$&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">},</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># 2. Calculate house age</span>
    <span class="k">if</span> <span class="s1">&#39;year_built&#39;</span> <span class="ow">in</span> <span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">current_year</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">year</span>
        <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;house_age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_year</span> <span class="o">-</span> <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;year_built&#39;</span><span class="p">]</span>

    <span class="c1"># 3. Drop rows with any missing values</span>
    <span class="n">processed_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">processed_df</span>
</code></pre></div>

<p>A common but flawed approach is to simply "test" this in a Jupyter notebook by running it on some data and visually inspecting the output. This is not a real test‚Äîit's not automated, not repeatable, and easily forgotten.</p>
<p>Let's write a proper pytest test. The best way to compare pandas DataFrames is with the <code>pandas.testing.assert_frame_equal</code> function. It gives detailed output on exactly how two DataFrames differ.</p>
<p>Our test file will look like this:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_data_processing.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">data_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_housing_data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_preprocess_housing_data</span><span class="p">():</span>
    <span class="c1"># 1. Setup: Create the input data</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;$750,000&#39;</span><span class="p">,</span> <span class="s1">&#39;$1,200,000&#39;</span><span class="p">,</span> <span class="s1">&#39;$450,000&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">2018</span><span class="p">,</span> <span class="mi">1990</span><span class="p">,</span> <span class="mi">2010</span><span class="p">],</span>
        <span class="s1">&#39;sq_ft&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2200</span><span class="p">,</span> <span class="mi">3100</span><span class="p">,</span> <span class="mi">1500</span><span class="p">,</span> <span class="mi">1800</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>

    <span class="c1"># 2. Setup: Define the expected output data</span>
    <span class="n">current_year</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">year</span>
    <span class="n">expected_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">750000.0</span><span class="p">,</span> <span class="mf">1200000.0</span><span class="p">,</span> <span class="mf">450000.0</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">2018</span><span class="p">,</span> <span class="mi">1990</span><span class="p">],</span>
        <span class="s1">&#39;sq_ft&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2200</span><span class="p">,</span> <span class="mi">3100</span><span class="p">,</span> <span class="mi">1500</span><span class="p">],</span>
        <span class="s1">&#39;house_age&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">current_year</span> <span class="o">-</span> <span class="mi">2005</span><span class="p">,</span> <span class="n">current_year</span> <span class="o">-</span> <span class="mi">2018</span><span class="p">,</span> <span class="n">current_year</span> <span class="o">-</span> <span class="mi">1990</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="c1"># Note: The row with the missing price is expected to be dropped.</span>
    <span class="c1"># We also need to match the index after dropping.</span>
    <span class="n">expected_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">expected_data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="c1"># 3. Execution: Run the function we are testing</span>
    <span class="n">actual_df</span> <span class="o">=</span> <span class="n">preprocess_housing_data</span><span class="p">(</span><span class="n">input_df</span><span class="p">)</span>

    <span class="c1"># 4. Assertion: Check if the actual output matches the expected output</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_frame_equal</span><span class="p">(</span><span class="n">actual_df</span><span class="p">,</span> <span class="n">expected_df</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_preprocess_empty_dataframe</span><span class="p">():</span>
    <span class="c1"># Edge case: what happens with an empty DataFrame?</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[]})</span>
    <span class="n">expected_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;house_age&#39;</span><span class="p">:</span> <span class="p">[]})</span>

    <span class="n">actual_df</span> <span class="o">=</span> <span class="n">preprocess_housing_data</span><span class="p">(</span><span class="n">input_df</span><span class="p">)</span>

    <span class="c1"># The dtypes might differ (object vs float), so check them explicitly</span>
    <span class="n">pd</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_frame_equal</span><span class="p">(</span><span class="n">actual_df</span><span class="p">,</span> <span class="n">expected_df</span><span class="p">,</span> <span class="n">check_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

<p>This approach is powerful because:
1.  <strong>It's explicit:</strong> The <code>expected_df</code> clearly documents the function's contract.
2.  <strong>It's automated:</strong> We can run this test anytime we change the <code>preprocess_housing_data</code> function to ensure we haven't broken anything.
3.  <strong>It's precise:</strong> <code>assert_frame_equal</code> will tell us if a single value, a column name, a data type, or an index is incorrect, which is far more reliable than visual inspection.</p>
<p>Testing your data processing functions is the single most effective way to build a reliable data science pipeline. Get this right, and you've eliminated a massive source of potential bugs.</p>
<h2 id="approximate-assertions-with-pytest-approx">Approximate Assertions with pytest-approx</h2>
<h2 id="approximate-assertions-with-pytest-approx_1">Approximate Assertions with pytest-approx</h2>
<p>As we discussed, floating-point arithmetic is a major challenge in testing numerical code. Let's see this problem in action.</p>
<p>Imagine a simple function that calculates the average rating from a list of scores.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># calculations.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate_average_rating</span><span class="p">(</span><span class="n">ratings</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ratings</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratings</span><span class="p">)</span>
</code></pre></div>

<p>Now, let's write a test for it. A common scenario might be calculating the average of <code>[1, 2, 3]</code>, which is <code>2.0</code>. That works fine. But what about a more complex case?</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_calculations.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">calculations</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_average_rating</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_average_rating_simple</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">calculate_average_rating</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="mf">2.0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_average_rating_float_problem</span><span class="p">():</span>
    <span class="c1"># This test will FAIL!</span>
    <span class="n">ratings</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span>
    <span class="c1"># The expected result of np.mean([0.1, 0.2, 0.3]) is 0.2</span>
    <span class="c1"># But what if we naively expect the average of 0.1 and 0.2 to be 0.15?</span>
    <span class="c1"># Let&#39;s try a different example where the sum is the issue.</span>
    <span class="c1"># The sum of 0.1 + 0.2 is not exactly 0.3</span>
    <span class="k">assert</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">==</span> <span class="mf">0.3</span>
</code></pre></div>

<p>Let's run this test.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>tests/test_calculations.py

<span class="o">===========================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">===========================</span>
_________<span class="w"> </span>test_average_rating_float_problem<span class="w"> </span>__________

<span class="w">    </span>def<span class="w"> </span>test_average_rating_float_problem<span class="o">()</span>:
<span class="w">        </span><span class="c1"># This test will FAIL!</span>
<span class="w">        </span><span class="c1"># The sum of 0.1 + 0.2 is not exactly 0.3</span>
&gt;<span class="w">       </span>assert<span class="w"> </span><span class="m">0</span>.1<span class="w"> </span>+<span class="w"> </span><span class="m">0</span>.2<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span>.3
E<span class="w">       </span>assert<span class="w"> </span><span class="o">(</span><span class="m">0</span>.1<span class="w"> </span>+<span class="w"> </span><span class="m">0</span>.2<span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span>.3
E<span class="w">        </span>+<span class="w">  </span>where<span class="w"> </span><span class="o">(</span><span class="m">0</span>.1<span class="w"> </span>+<span class="w"> </span><span class="m">0</span>.2<span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.30000000000000004
<span class="o">=====================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.12s<span class="w"> </span><span class="o">=====================</span>
</code></pre></div>

<p>Pytest's excellent assertion introspection shows us the problem clearly. The result of <code>0.1 + 0.2</code> is <code>0.30000000000000004</code>. This tiny difference causes the test to fail. This is the pitfall we need to avoid.</p>
<h3 id="the-solution-pytestapprox">The Solution: <code>pytest.approx</code></h3>
<p>Pytest provides a brilliant and simple solution for this: the <code>pytest.approx</code> helper. It allows you to assert that a number is "close enough" to an expected value, within a certain tolerance.</p>
<p>Let's fix our test and write a more realistic one for our function.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_calculations.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">calculations</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_average_rating</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_average_rating_simple</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">calculate_average_rating</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_average_rating_with_floats</span><span class="p">():</span>
    <span class="c1"># This test now PASSES</span>
    <span class="n">ratings</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span> <span class="c1"># np.mean is 0.2</span>
    <span class="k">assert</span> <span class="n">calculate_average_rating</span><span class="p">(</span><span class="n">ratings</span><span class="p">)</span> <span class="o">==</span> <span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_another_float_example</span><span class="p">():</span>
    <span class="c1"># The average of 1/3 and 2/3 is 0.5</span>
    <span class="n">ratings</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">calculate_average_rating</span><span class="p">(</span><span class="n">ratings</span><span class="p">)</span> <span class="o">==</span> <span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</code></pre></div>

<p>By wrapping the expected value in <code>pytest.approx()</code>, you're changing the assertion from "is exactly equal to" to "is approximately equal to". Pytest handles the tolerance logic for you.</p>
<h3 id="using-pytestapprox-with-numpy-and-pandas">Using <code>pytest.approx</code> with NumPy and Pandas</h3>
<p>The real power of <code>pytest.approx</code> is that it works seamlessly with collections like lists, NumPy arrays, and even Pandas Series/DataFrames. This makes it indispensable for data science testing.</p>
<p>Let's imagine a function that normalizes data (scales it between 0 and 1).</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># calculations.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">calculate_average_rating</span><span class="p">(</span><span class="n">ratings</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ratings</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratings</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">normalize_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Scales data to a [0, 1] range.&quot;&quot;&quot;</span>
    <span class="n">min_val</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">max_val</span> <span class="o">==</span> <span class="n">min_val</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span>
</code></pre></div>

<p>Now, we can test it directly on a NumPy array.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_calculations.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">calculations</span><span class="w"> </span><span class="kn">import</span> <span class="n">calculate_average_rating</span><span class="p">,</span> <span class="n">normalize_data</span>

<span class="c1"># ... (previous tests) ...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_normalize_data</span><span class="p">():</span>
    <span class="n">input_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">])</span>
    <span class="n">expected_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

    <span class="n">actual_data</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>

    <span class="c1"># Use pytest.approx with a NumPy array</span>
    <span class="k">assert</span> <span class="n">actual_data</span> <span class="o">==</span> <span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="n">expected_data</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_normalize_data_with_floats</span><span class="p">():</span>
    <span class="n">input_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
    <span class="c1"># The normalization involves division, which will introduce float inaccuracies</span>
    <span class="n">expected_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

    <span class="n">actual_data</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">actual_data</span> <span class="o">==</span> <span class="n">pytest</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="n">expected_data</span><span class="p">)</span>
</code></pre></div>

<p>Whenever your tests involve floating-point numbers, your default should be to use <code>pytest.approx</code>. It makes your tests robust against tiny, irrelevant numerical differences and focuses them on what matters: whether the calculation is fundamentally correct.</p>
<h2 id="testing-machine-learning-models">Testing Machine Learning Models</h2>
<h2 id="testing-machine-learning-models_1">Testing Machine Learning Models</h2>
<p>This is where we truly depart from traditional software testing. We cannot assert that a model's prediction is "correct" in an absolute sense. Instead, we test the model's contract, its behavior, and its properties. Think of it like testing a car: you don't test that it can win a specific race, but you do test that the brakes work, the steering turns the wheels, and the engine doesn't explode.</p>
<p>Let's assume we have a simple classification model trained to identify spam emails. For testing, we don't want to re-train it every time. We'll assume we have a pre-trained model object that we can load.</p>
<p>Our tests should answer questions like:
-   Does the <code>predict</code> method run without errors? (A smoke test)
-   Does it return predictions in the format I expect?
-   Are the predictions reasonable? (e.g., probabilities are between 0 and 1)
-   Is the model deterministic if randomness is controlled?</p>
<p>Here's a simple example using a dummy model for demonstration.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># model.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SpamClassifier</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A dummy model for demonstration purposes.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predicts the probability of each input being spam.</span>
<span class="sd">        A real model would use embeddings and a neural network.</span>
<span class="sd">        We&#39;ll just use a simple heuristic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A simple heuristic: if &#39;buy now&#39; is in the text, high spam probability</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;buy now&quot;</span> <span class="ow">in</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.95</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;hello&quot;</span> <span class="ow">in</span> <span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Predicts a class label (0 for not-spam, 1 for spam).&quot;&quot;&quot;</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">probabilities</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="c1"># In a real scenario, you would load a saved model, e.g., with joblib or pickle</span>
<span class="c1"># For this example, we&#39;ll just instantiate it.</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">SpamClassifier</span><span class="p">()</span>
</code></pre></div>

<p>Now, let's write tests for this model's behavior, not its accuracy on a large dataset.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_model.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">model</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpamClassifier</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">spam_model</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Provides a trained SpamClassifier model instance.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">SpamClassifier</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_model_smoke_test</span><span class="p">(</span><span class="n">spam_model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple smoke test to ensure predict() runs without crashing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">test_input</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hello, this is a friendly email.&quot;</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spam_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">pytest</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model prediction failed with an exception: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_prediction_output_shape</span><span class="p">(</span><span class="n">spam_model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of predictions should match the number of inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">test_input</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;Hello friend&quot;</span><span class="p">,</span>
        <span class="s2">&quot;URGENT: buy now for a big discount!&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Meeting at 3 PM&quot;</span>
    <span class="p">]</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">spam_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_prediction_output_type_and_values</span><span class="p">(</span><span class="n">spam_model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predictions should be integers (0 or 1) for classification.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">test_input</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Sample email 1&quot;</span><span class="p">,</span> <span class="s2">&quot;Another one with buy now&quot;</span><span class="p">]</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">spam_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>

    <span class="c1"># Check data type</span>
    <span class="k">assert</span> <span class="n">predictions</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>

    <span class="c1"># Check that all values are either 0 or 1</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_predict_proba_output_range</span><span class="p">(</span><span class="n">spam_model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predicted probabilities must be between 0 and 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">test_input</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">]</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">spam_model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">probabilities</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">probabilities</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_model_known_cases</span><span class="p">(</span><span class="n">spam_model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test the model on a few examples where the outcome is obvious.</span>
<span class="sd">    This checks the basic logic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spam_email</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;URGENT call now to claim your prize, buy now!&quot;</span><span class="p">]</span>
    <span class="n">not_spam_email</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hi Bob, just confirming our meeting. Hello!&quot;</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">spam_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">spam_email</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">spam_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">not_spam_email</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div>

<p>These tests establish a contract for our model. They don't care if the model is 99% accurate or 60% accurate. They care that it behaves as expected: it doesn't crash, it returns data in the correct shape and format, and its outputs are within a valid range. These are the kinds of tests that prevent bugs in your production machine learning systems.</p>
<h2 id="fixtures-for-data-pipelines">Fixtures for Data Pipelines</h2>
<h2 id="fixtures-for-data-pipelines_1">Fixtures for Data Pipelines</h2>
<p>As we've seen, data science tests require... well, data. You might be tempted to create this data inside every single test function.</p>
<p>Let's look at the "wrong way" first.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pipeline_bad.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">data_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_housing_data</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">model</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpamClassifier</span> <span class="c1"># Pretend this is a housing model</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_preprocessing_again</span><span class="p">():</span>
    <span class="c1"># Repetitive setup</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;$750,000&#39;</span><span class="p">],</span> <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2005</span><span class="p">]}</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
    <span class="c1"># ... assertions ...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_model_prediction_on_processed_data</span><span class="p">():</span>
    <span class="c1"># Repetitive setup again!</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;$750,000&#39;</span><span class="p">],</span> <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2005</span><span class="p">]}</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
    <span class="n">processed_df</span> <span class="o">=</span> <span class="n">preprocess_housing_data</span><span class="p">(</span><span class="n">input_df</span><span class="p">)</span>
    <span class="c1"># model = HousingPriceModel()</span>
    <span class="c1"># ... assertions ...</span>
</code></pre></div>

<p>This is repetitive and hard to maintain. If you need to add a new column to your test data, you have to change it in multiple places. This is exactly the problem fixtures were designed to solve (as we learned in Chapter 4).</p>
<p>By using fixtures, we can define our data and processing steps once and reuse them across many tests. This is especially useful for creating a mini-pipeline within our test suite.</p>
<p>Let's create a <code>conftest.py</code> file in our <code>tests/</code> directory to hold our shared fixtures.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/conftest.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">data_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_housing_data</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">model</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpamClassifier</span> <span class="c1"># Using this as a placeholder for a housing model</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">raw_housing_data</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fixture for raw housing data, loaded once per module.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Creating raw_housing_data fixture)&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;$750,000&#39;</span><span class="p">,</span> <span class="s1">&#39;$1,200,000&#39;</span><span class="p">,</span> <span class="s1">&#39;$450,000&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">2018</span><span class="p">,</span> <span class="mi">1990</span><span class="p">,</span> <span class="mi">2010</span><span class="p">],</span>
        <span class="s1">&#39;sq_ft&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2200</span><span class="p">,</span> <span class="mi">3100</span><span class="p">,</span> <span class="mi">1500</span><span class="p">,</span> <span class="mi">1800</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">processed_housing_data</span><span class="p">(</span><span class="n">raw_housing_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fixture that depends on raw_housing_data and provides cleaned data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Creating processed_housing_data fixture)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">preprocess_housing_data</span><span class="p">(</span><span class="n">raw_housing_data</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">trained_model</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fixture to provide a &#39;trained&#39; model. In a real scenario, this might</span>
<span class="sd">    load a model from a file. Here, we just instantiate it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">(Creating trained_model fixture)&quot;</span><span class="p">)</span>
    <span class="c1"># In a real test suite, this would be your actual model,</span>
    <span class="c1"># e.g., a trained RandomForestRegressor.</span>
    <span class="k">return</span> <span class="n">SpamClassifier</span><span class="p">()</span> <span class="c1"># Placeholder</span>
</code></pre></div>

<p>We've created a chain of dependencies: <code>processed_housing_data</code> depends on <code>raw_housing_data</code>. By setting <code>scope="module"</code>, we ensure this potentially expensive data loading and processing happens only <em>once</em> when we run the tests in a file, not before every single test. The <code>print</code> statements will help us see this in action.</p>
<p>Now, our test file becomes incredibly clean and readable. Each test just asks for the specific data it needs.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_pipeline_good.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_data_processing_output</span><span class="p">(</span><span class="n">processed_housing_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test the output of the processing step using a fixture.&quot;&quot;&quot;</span>
    <span class="c1"># The setup is now completely handled by the fixture.</span>
    <span class="c1"># We can focus purely on the assertions.</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">processed_housing_data</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">assert</span> <span class="s1">&#39;house_age&#39;</span> <span class="ow">in</span> <span class="n">processed_housing_data</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">assert</span> <span class="n">processed_housing_data</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_model_on_processed_data</span><span class="p">(</span><span class="n">trained_model</span><span class="p">,</span> <span class="n">processed_housing_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test the model&#39;s behavior on clean data.&quot;&quot;&quot;</span>
    <span class="c1"># This test needs both the model and the data.</span>
    <span class="c1"># Pytest provides both fixtures automatically.</span>

    <span class="c1"># For this placeholder, we need to convert the DataFrame to a list of strings</span>
    <span class="c1"># A real housing model would take the DataFrame directly.</span>
    <span class="n">test_input</span> <span class="o">=</span> <span class="n">processed_housing_data</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">predictions</span> <span class="o">=</span> <span class="n">trained_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed_housing_data</span><span class="p">)</span>
</code></pre></div>

<p>Let's run these tests with the <code>-s</code> (to show print statements) and <code>-v</code> (verbose) flags to see how the fixtures are executed.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-sv<span class="w"> </span>tests/test_pipeline_good.py

<span class="o">===========================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">===========================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

tests/test_pipeline_good.py::test_data_processing_output
<span class="o">(</span>Creating<span class="w"> </span>raw_housing_data<span class="w"> </span>fixture<span class="o">)</span>
<span class="o">(</span>Creating<span class="w"> </span>processed_housing_data<span class="w"> </span>fixture<span class="o">)</span>
PASSED
tests/test_pipeline_good.py::test_model_on_processed_data
<span class="o">(</span>Creating<span class="w"> </span>trained_model<span class="w"> </span>fixture<span class="o">)</span>
<span class="nv">PASSED</span>

<span class="o">============================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="m">0</span>.15s<span class="w"> </span><span class="o">============================</span>
</code></pre></div>

<p>Notice the output. The data fixtures are created only once at the beginning, and the model fixture is created when it's first needed. Both are then reused for subsequent tests in the module. This pattern is the key to writing efficient, scalable, and maintainable tests for complex data pipelines.</p>
<h2 id="testing-visualization-code">Testing Visualization Code</h2>
<h2 id="testing-visualization-code_1">Testing Visualization Code</h2>
<p>Testing visual output is notoriously difficult. Do you save a "golden" image of the plot and compare it pixel-by-pixel to the new output? This is brittle; a tiny change in a dependency like Matplotlib could alter rendering slightly and break all your tests.</p>
<p>A much more robust strategy is to <strong>test the data, not the pixels</strong>. We should verify that our visualization function is called with the correct data and settings. We can trust that if we give Matplotlib the right numbers, it will draw the right chart.</p>
<p>This is a perfect use case for mocking, which we covered in Chapter 8. We can use <code>unittest.mock.patch</code> to intercept the call to the plotting function (e.g., <code>matplotlib.pyplot.bar</code>) and inspect the arguments it received.</p>
<p>Let's create a simple visualization function.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># visualization.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="k">def</span><span class="w"> </span><span class="nf">plot_average_price_by_year</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a bar plot of the average house price for each year built.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span> <span class="c1"># Do nothing if no data</span>

    <span class="n">avg_price_by_year</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;year_built&#39;</span><span class="p">)[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">avg_price_by_year</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="n">avg_price_by_year</span><span class="o">.</span><span class="n">values</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Year Built&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Average Price ($)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Average Housing Price by Year Built&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="c1"># In a real app, you might call plt.savefig() or plt.show()</span>
    <span class="c1"># For testing, we&#39;ll just let the function end here.</span>
    <span class="k">return</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span> <span class="c1"># Return the current axes object for inspection</span>
</code></pre></div>

<p>Now, let's write a test. We will "patch" <code>matplotlib.pyplot.bar</code>. This replaces the real <code>bar</code> function with a "MagicMock" object that records how it was called.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># tests/test_visualization.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unittest.mock</span><span class="w"> </span><span class="kn">import</span> <span class="n">patch</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">visualization</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_average_price_by_year</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span><span class="w"> </span><span class="nf">viz_data</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample data for visualization tests.&quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">500000</span><span class="p">,</span> <span class="mi">600000</span><span class="p">,</span> <span class="mi">700000</span><span class="p">,</span> <span class="mi">800000</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">2010</span><span class="p">,</span> <span class="mi">2012</span><span class="p">,</span> <span class="mi">2012</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># The patch decorator intercepts the call to &#39;visualization.plt.bar&#39;</span>
<span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;visualization.plt.bar&#39;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_plot_average_price_by_year_data</span><span class="p">(</span><span class="n">mock_bar</span><span class="p">,</span> <span class="n">viz_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test that plt.bar is called with the correctly aggregated data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Call the function that we are testing</span>
    <span class="n">plot_average_price_by_year</span><span class="p">(</span><span class="n">viz_data</span><span class="p">)</span>

    <span class="c1"># Assert that our mock was called exactly once</span>
    <span class="n">mock_bar</span><span class="o">.</span><span class="n">assert_called_once</span><span class="p">()</span>

    <span class="c1"># The arguments are available in mock_bar.call_args</span>
    <span class="c1"># It&#39;s a tuple of (args, kwargs)</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">mock_bar</span><span class="o">.</span><span class="n">call_args</span>

    <span class="c1"># The data is passed as keyword arguments &#39;x&#39; and &#39;height&#39;</span>
    <span class="n">x_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">height_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>

    <span class="c1"># Expected data after groupby and mean aggregation</span>
    <span class="c1"># Year 2010: mean(500000, 600000) = 550000</span>
    <span class="c1"># Year 2012: mean(700000, 800000) = 750000</span>
    <span class="n">expected_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">2012</span><span class="p">])</span>
    <span class="n">expected_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">550000.0</span><span class="p">,</span> <span class="mf">750000.0</span><span class="p">])</span>

    <span class="c1"># Use numpy&#39;s testing utilities for array comparison</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">expected_x</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">height_values</span><span class="p">,</span> <span class="n">expected_height</span><span class="p">)</span>

<span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;visualization.plt.title&#39;</span><span class="p">)</span>
<span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;visualization.plt.xlabel&#39;</span><span class="p">)</span>
<span class="nd">@patch</span><span class="p">(</span><span class="s1">&#39;visualization.plt.ylabel&#39;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_plot_labels_and_title</span><span class="p">(</span><span class="n">mock_ylabel</span><span class="p">,</span> <span class="n">mock_xlabel</span><span class="p">,</span> <span class="n">mock_title</span><span class="p">,</span> <span class="n">viz_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test that the plot labels and title are set correctly.&quot;&quot;&quot;</span>
    <span class="n">plot_average_price_by_year</span><span class="p">(</span><span class="n">viz_data</span><span class="p">)</span>

    <span class="n">mock_title</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s2">&quot;Average Housing Price by Year Built&quot;</span><span class="p">)</span>
    <span class="n">mock_xlabel</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s2">&quot;Year Built&quot;</span><span class="p">)</span>
    <span class="n">mock_ylabel</span><span class="o">.</span><span class="n">assert_called_once_with</span><span class="p">(</span><span class="s2">&quot;Average Price ($)&quot;</span><span class="p">)</span>
</code></pre></div>

<p>This approach is far superior to image comparison:
-   <strong>It's fast:</strong> It doesn't require any actual image rendering.
-   <strong>It's robust:</strong> It's immune to changes in library versions that affect rendering.
-   <strong>It's precise:</strong> It tests the core logic of the function‚Äîthe data aggregation‚Äîwhich is what you, the developer, are responsible for.</p>
<p>By testing the inputs to the plotting library, you verify that your code is doing its job correctly without getting bogged down in the fragile and complex world of visual testing.</p>
        </div>
        <div class="footer">
            Generated on 2025-11-22 16:29:18 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>