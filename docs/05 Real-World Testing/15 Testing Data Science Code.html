<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15 Testing Data Science Code</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --bg-main: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0f172a;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #06b6d4;
            --success: #10b981;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.7; 
            color: var(--text-primary); 
            background: var(--bg-main);
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        .home-btn { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            background: var(--accent);
            color: white; 
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-decoration: none; 
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .home-btn:hover { 
            background: #0891b2;
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5);
        }
        
        .breadcrumb { 
            background: var(--bg-card);
            padding: 12px 0; 
            margin-bottom: 24px; 
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .breadcrumb a { 
            color: var(--accent);
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb a:hover { 
            color: var(--primary);
            text-decoration: underline;
        }
        
        .content { 
            background: var(--bg-card);
            padding: 3rem; 
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }
        
        .file-list { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 1.5rem; 
            margin: 2rem 0; 
        }
        
        .file-item { 
            padding: 1.5rem; 
            border: 1px solid var(--border);
            border-radius: 12px; 
            background: var(--bg-main);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .file-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .file-item:hover { 
            transform: translateY(-4px); 
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.3);
            border-color: var(--primary);
        }
        
        .file-item:hover::before {
            opacity: 1;
        }
        
        .file-item a { 
            color: var(--text-primary);
            text-decoration: none; 
            font-weight: 600; 
            display: block;
            font-size: 1.1rem;
        }
        
        .file-item a:hover { 
            color: var(--primary);
        }
        
        .file-type { 
            font-size: 13px; 
            color: var(--text-secondary);
            margin-top: 8px; 
            font-weight: 500;
        }
        
        /* Code Blocks */
        pre { 
            background: var(--bg-code);
            padding: 1.5rem; 
            border-radius: 12px; 
            overflow-x: auto;
            border: 1px solid var(--border);
            margin: 1.5rem 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        pre code { 
            background: none;
            padding: 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        /* Copy Button */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            opacity: 0.7;
            z-index: 10;
        }
        
        .copy-btn:hover {
            opacity: 1;
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: var(--success);
        }
        
        pre:hover .copy-btn {
            opacity: 1;
        }
        
        /* Inline Code */
        code { 
            background: var(--bg-code);
            color: #8b5cf6;
            padding: 3px 8px; 
            border-radius: 6px; 
            font-size: 1.1em;
            font-family: 'Fira Code', 'Consolas', monospace;
            border: 1px solid var(--border);
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 { 
            color: var(--text-primary);
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h1 { 
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            border-bottom: 3px solid var(--primary);
            padding-bottom: 12px;
            margin-bottom: 1.5rem;
        }
        
        h2 { 
            font-size: 2rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 8px;
        }
        
        h3 { 
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        /* Links */
        a { 
            color: var(--accent);
            transition: color 0.2s;
        }
        
        a:hover { 
            color: var(--primary);
        }
        
        /* Paragraphs */
        p {
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        /* Lists */
        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
            color: var(--text-secondary);
        }
        
        li {
            margin: 0.5rem 0;
        }
        
        /* Tables */
        table { 
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        th, td { 
            border: 1px solid var(--border);
            padding: 12px 16px;
            text-align: left;
        }
        
        th { 
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: var(--bg-card);
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--primary);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            background: var(--bg-main);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Horizontal Rule */
        hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }
        
        .footer { 
            text-align: center; 
            padding: 2rem; 
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
            margin-top: 3rem; 
            font-size: 14px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-main);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .file-list { grid-template-columns: 1fr; }
            .content { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <a href="../index.html" class="home-btn">üè†</a>
    <div class="container">
        <div class="breadcrumb">
            <div style="padding: 0 20px;">
                <a href="../index.html">üè† Home</a> <span style="color: #64748b;">/</span> <a href="index.html">05 Real-World Testing</a>
            </div>
        </div>
        <div class="content">
            <h1 id="chapter-15-testing-data-science-code">Chapter 15: Testing Data Science Code</h1>
<h2 id="challenges-in-data-science-testing">Challenges in Data Science Testing</h2>
<h2 id="challenges-in-data-science-testing_1">Challenges in Data Science Testing</h2>
<p>Testing data science and machine learning code presents a unique set of challenges that differ significantly from traditional software engineering. While the core principles of testing remain the same‚Äîverifying correctness and preventing regressions‚Äîthe nature of the code and its outputs requires specialized tools and techniques.</p>
<p>Understanding these challenges is the first step toward writing effective tests for your data-driven applications.</p>
<h3 id="key-challenges">Key Challenges</h3>
<ol>
<li>
<p><strong>Floating-Point Precision:</strong>
    Machine learning algorithms are built on linear algebra and calculus, which means they operate heavily on floating-point numbers. Comparing two floats for exact equality (<code>a == b</code>) is notoriously unreliable due to the way computers represent these numbers. A tiny, insignificant difference in the 15th decimal place can cause a test to fail, even if the result is functionally correct.</p>
</li>
<li>
<p><strong>Non-Determinism and Stochasticity:</strong>
    Many algorithms, from random forests to neural network weight initialization, have a random component. Running the same training code twice might produce two slightly different models with slightly different predictions. Tests that expect exact output values will be flaky and unreliable.</p>
</li>
<li>
<p><strong>Large and Complex Data:</strong>
    Data science code operates on data, often large datasets. Unit tests should be fast and isolated, which means you can't run them on your entire 10 GB dataset. Creating small, representative, and manageable sample datasets for testing is a significant challenge in itself.</p>
</li>
<li>
<p><strong>"Correctness" is Fuzzy:</strong>
    What does it mean for a machine learning model to be "correct"? Unlike a function that sorts a list, a model's output isn't binary right or wrong. Its performance is statistical. We can't assert that <code>model.predict(input) == 42.5</code>. Instead, we need to test for properties: Are the predictions within a plausible range? Is the model's performance on a known subset of data above a certain threshold?</p>
</li>
<li>
<p><strong>Long-Running Processes:</strong>
    Training a model can take hours or even days. You cannot include a full training run in your CI/CD pipeline's test suite. Testing strategies must be adapted to verify the training <em>logic</em> without executing the entire expensive process.</p>
</li>
<li>
<p><strong>Coupling of Code and Data:</strong>
    The behavior of your code is inextricably linked to the data it processes. A data cleaning function might work perfectly until it encounters a new, unexpected category or data format. Your tests need to be robust to variations in data, and you need a way to manage the test data itself.</p>
</li>
</ol>
<p>In this chapter, we will tackle these challenges head-on. We will build a small data processing and modeling pipeline and, step-by-step, introduce pytest techniques to test it robustly and effectively.</p>
<h2 id="testing-data-processing-functions">Testing Data Processing Functions</h2>
<h2 id="testing-data-processing-functions_1">Testing Data Processing Functions</h2>
<p>The foundation of any data science project is data preparation. Functions that clean, transform, and engineer features are the most testable part of the pipeline because their behavior is often deterministic. If you provide the same input, you should get the same output.</p>
<p>This makes them the perfect place to start building our testing skills.</p>
<h3 id="phase-1-establish-the-reference-implementation">Phase 1: Establish the Reference Implementation</h3>
<p>Let's establish our <strong>anchor example</strong>: a function that preprocesses a dataset of house listings. The function will take a pandas DataFrame, fill missing values in the <code>year_built</code> column with the median year, and one-hot encode the <code>style</code> column (e.g., 'Ranch', 'Colonial').</p>
<p>Here is the initial implementation.</p>
<p><strong>The code to be tested:</strong> <code>data_processing.py</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># data_processing.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="k">def</span><span class="w"> </span><span class="nf">preprocess_data</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocesses the housing data.</span>

<span class="sd">    - Fills missing &#39;year_built&#39; with the median.</span>
<span class="sd">    - One-hot encodes the &#39;style&#39; column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Fill missing year_built with the median</span>
    <span class="k">if</span> <span class="s1">&#39;year_built&#39;</span> <span class="ow">in</span> <span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">median_year</span> <span class="o">=</span> <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;year_built&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
        <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;year_built&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">median_year</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># One-hot encode style</span>
    <span class="k">if</span> <span class="s1">&#39;style&#39;</span> <span class="ow">in</span> <span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">style_dummies</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">processed_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">processed_df</span><span class="p">,</span> <span class="n">style_dummies</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">processed_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">processed_df</span>
</code></pre></div>

<h3 id="iteration-0-the-first-test">Iteration 0: The First Test</h3>
<p>Our first test will verify the basic functionality. We'll create a small, representative DataFrame in the test itself, define the exact expected output, and use pandas' built-in <code>testing.assert_frame_equal</code> to compare them.</p>
<p><strong>The test file:</strong> <code>test_data_processing.py</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_data_processing.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas.testing</span><span class="w"> </span><span class="kn">import</span> <span class="n">assert_frame_equal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">data_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_preprocess_data_basic</span><span class="p">():</span>
    <span class="c1"># 1. Setup: Create the input data</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">200000</span><span class="p">,</span> <span class="mi">350000</span><span class="p">,</span> <span class="mi">275000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">],</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">],</span>
        <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Colonial&#39;</span><span class="p">,</span> <span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Modern&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>

    <span class="c1"># 2. Action: Call the function under test</span>
    <span class="n">actual_df</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="p">(</span><span class="n">input_df</span><span class="p">)</span>

    <span class="c1"># 3. Assertion: Define the expected outcome and compare</span>
    <span class="c1"># The median of [1985, 1999, 2010] is 1999.0</span>
    <span class="n">expected_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">200000</span><span class="p">,</span> <span class="mi">350000</span><span class="p">,</span> <span class="mi">275000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">],</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Colonial&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Modern&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Ranch&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="n">expected_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">expected_data</span><span class="p">)</span>

    <span class="c1"># Pandas provides a testing utility to compare DataFrames</span>
    <span class="n">assert_frame_equal</span><span class="p">(</span><span class="n">actual_df</span><span class="p">,</span> <span class="n">expected_df</span><span class="p">)</span>
</code></pre></div>

<p>Let's run this test.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

test_data_processing.py<span class="w"> </span>.<span class="w">                                                </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<p>It passes. This test correctly verifies our initial requirements. It's clear, self-contained, and deterministic.</p>
<p>However, data processing pipelines rarely stop here. They evolve. What happens when we add a step that introduces floating-point numbers, like feature scaling? This is where our simple, exact-match approach will break down.</p>
<h2 id="approximate-assertions-with-pytest-approx">Approximate Assertions with pytest-approx</h2>
<h2 id="approximate-assertions-with-pytest-approx_1">Approximate Assertions with pytest-approx</h2>
<p>Our current test works because all our outputs are integers or clean floats. The real world of data science is messy and filled with imprecise floating-point numbers. Let's see what happens when our preprocessing function evolves to handle this reality.</p>
<h3 id="iteration-1-introducing-floating-point-scaling">Iteration 1: Introducing Floating-Point Scaling</h3>
<p><strong>Current state recap:</strong> Our test verifies filling missing values and one-hot encoding.</p>
<p><strong>Current limitation:</strong> The test relies on exact equality, which is fragile for numerical computations.</p>
<p><strong>New scenario introduction:</strong> Let's add a feature scaling step to our <code>preprocess_data</code> function. We'll scale the <code>price</code> column to be between 0 and 1 (a common technique called Min-Max Scaling).</p>
<p>Here's the updated <code>data_processing.py</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># data_processing.py (UPDATED)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="k">def</span><span class="w"> </span><span class="nf">preprocess_data</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocesses the housing data.</span>

<span class="sd">    - Fills missing &#39;year_built&#39; with the median.</span>
<span class="sd">    - One-hot encodes the &#39;style&#39; column.</span>
<span class="sd">    - Min-Max scales the &#39;price&#39; column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Fill missing year_built with the median</span>
    <span class="k">if</span> <span class="s1">&#39;year_built&#39;</span> <span class="ow">in</span> <span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">median_year</span> <span class="o">=</span> <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;year_built&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
        <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;year_built&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">median_year</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># One-hot encode style</span>
    <span class="k">if</span> <span class="s1">&#39;style&#39;</span> <span class="ow">in</span> <span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">style_dummies</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">processed_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">processed_df</span><span class="p">,</span> <span class="n">style_dummies</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">processed_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;style&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># --- NEW ---</span>
    <span class="c1"># Min-Max scale the price</span>
    <span class="k">if</span> <span class="s1">&#39;price&#39;</span> <span class="ow">in</span> <span class="n">processed_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">min_price</span> <span class="o">=</span> <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">max_price</span> <span class="o">=</span> <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">processed_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_price</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_price</span> <span class="o">-</span> <span class="n">min_price</span><span class="p">)</span>
    <span class="c1"># --- END NEW ---</span>

    <span class="k">return</span> <span class="n">processed_df</span>
</code></pre></div>

<p>Now, we must update our test to reflect this new expected output. The prices are no longer <code>200000</code>, <code>350000</code>, etc., but scaled values between 0 and 1.</p>
<p><strong>Updated test file:</strong> <code>test_data_processing.py</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_data_processing.py (UPDATED)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas.testing</span><span class="w"> </span><span class="kn">import</span> <span class="n">assert_frame_equal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">data_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_preprocess_data_with_scaling</span><span class="p">():</span>
    <span class="c1"># 1. Setup</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">200000</span><span class="p">,</span> <span class="mi">350000</span><span class="p">,</span> <span class="mi">275000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">],</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">],</span>
        <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Colonial&#39;</span><span class="p">,</span> <span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Modern&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>

    <span class="c1"># 2. Action</span>
    <span class="n">actual_df</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="p">(</span><span class="n">input_df</span><span class="p">)</span>

    <span class="c1"># 3. Assertion</span>
    <span class="c1"># min=200k, max=500k.</span>
    <span class="c1"># 200k -&gt; (200-200)/(500-200) = 0.0</span>
    <span class="c1"># 350k -&gt; (350-200)/(500-200) = 150/300 = 0.5</span>
    <span class="c1"># 275k -&gt; (275-200)/(500-200) = 75/300 = 0.25</span>
    <span class="c1"># 500k -&gt; (500-200)/(500-200) = 1.0</span>
    <span class="n">expected_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="c1"># &lt;-- Updated values</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Colonial&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Modern&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Ranch&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="n">expected_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">expected_data</span><span class="p">)</span>

    <span class="c1"># This will fail due to floating point issues!</span>
    <span class="n">assert_frame_equal</span><span class="p">(</span><span class="n">actual_df</span><span class="p">,</span> <span class="n">expected_df</span><span class="p">)</span>
</code></pre></div>

<h3 id="failure-demonstration">Failure Demonstration</h3>
<p>Let's run this updated test. Even though our manual calculation seems correct, we get a failure.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

test_data_processing.py<span class="w"> </span>F<span class="w">                                                </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">===================================</span><span class="w"> </span><span class="nv">FAILURES</span><span class="w"> </span><span class="o">===================================</span>
______________________<span class="w"> </span>test_preprocess_data_with_scaling<span class="w"> </span>_______________________

<span class="w">    </span>def<span class="w"> </span>test_preprocess_data_with_scaling<span class="o">()</span>:
...
<span class="w">        </span><span class="c1"># This will fail due to floating point issues!</span>
&gt;<span class="w">       </span>assert_frame_equal<span class="o">(</span>actual_df,<span class="w"> </span>expected_df<span class="o">)</span>
E<span class="w">       </span>AssertionError:<span class="w"> </span>DataFrame.iloc<span class="o">[</span>:,<span class="w"> </span><span class="m">0</span><span class="o">]</span><span class="w"> </span><span class="o">(</span>column<span class="w"> </span><span class="nv">name</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="o">)</span><span class="w"> </span>are<span class="w"> </span>different
E
E<span class="w">       </span>DataFrame.iloc<span class="o">[</span>:,<span class="w"> </span><span class="m">0</span><span class="o">]</span><span class="w"> </span><span class="o">(</span>column<span class="w"> </span><span class="nv">name</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="o">)</span><span class="w"> </span>values<span class="w"> </span>are<span class="w"> </span>different<span class="w"> </span><span class="o">(</span><span class="m">25</span>.0<span class="w"> </span>%<span class="o">)</span>
E<span class="w">       </span><span class="o">[</span>index<span class="o">]</span>:<span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">]</span>
E<span class="w">       </span><span class="o">[</span>left<span class="o">]</span>:<span class="w">  </span><span class="o">[</span><span class="m">0</span>.0,<span class="w"> </span><span class="m">0</span>.5,<span class="w"> </span><span class="m">0</span>.25,<span class="w"> </span><span class="m">1</span>.0<span class="o">]</span>
E<span class="w">       </span><span class="o">[</span>right<span class="o">]</span>:<span class="w"> </span><span class="o">[</span><span class="m">0</span>.0,<span class="w"> </span><span class="m">0</span>.5,<span class="w"> </span><span class="m">0</span>.25,<span class="w"> </span><span class="m">1</span>.0<span class="o">]</span>

test_data_processing.py:35:<span class="w"> </span><span class="nv">AssertionError</span>
<span class="o">===========================</span><span class="w"> </span>short<span class="w"> </span><span class="nb">test</span><span class="w"> </span>summary<span class="w"> </span><span class="nv">info</span><span class="w"> </span><span class="o">============================</span>
FAILED<span class="w"> </span>test_data_processing.py::test_preprocess_data_with_scaling<span class="w"> </span>-<span class="w"> </span>AssertionError...
<span class="o">==============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>failed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">================================</span>
</code></pre></div>

<h3 id="diagnostic-analysis-reading-the-failure">Diagnostic Analysis: Reading the Failure</h3>
<p>This failure is subtle and classic in data science testing.</p>
<p><strong>The complete output</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="n">FAILED</span><span class="w"> </span><span class="n">test_data_processing</span><span class="p">.</span><span class="nl">py</span><span class="p">:</span><span class="err">:</span><span class="n">test_preprocess_data_with_scaling</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nl">AssertionError</span><span class="p">:</span><span class="w"> </span><span class="n">DataFrame</span><span class="p">.</span><span class="n">iloc</span><span class="o">[</span><span class="n">:, 0</span><span class="o">]</span><span class="w"> </span><span class="p">(</span><span class="k">column</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="ss">&quot;price&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">are</span><span class="w"> </span><span class="n">different</span>

<span class="n">DataFrame</span><span class="p">.</span><span class="n">iloc</span><span class="o">[</span><span class="n">:, 0</span><span class="o">]</span><span class="w"> </span><span class="p">(</span><span class="k">column</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="ss">&quot;price&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="k">are</span><span class="w"> </span><span class="n">different</span><span class="w"> </span><span class="p">(</span><span class="mf">25.0</span><span class="w"> </span><span class="o">%</span><span class="p">)</span>
<span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="err">:</span><span class="w"> </span><span class="o">[</span><span class="n">0, 1, 2, 3</span><span class="o">]</span>
<span class="o">[</span><span class="n">left</span><span class="o">]</span><span class="err">:</span><span class="w">  </span><span class="o">[</span><span class="n">0.0, 0.5, 0.25, 1.0</span><span class="o">]</span>
<span class="o">[</span><span class="n">right</span><span class="o">]</span><span class="err">:</span><span class="w"> </span><span class="o">[</span><span class="n">0.0, 0.5, 0.25, 1.0</span><span class="o">]</span>
</code></pre></div>

<p><strong>Let's parse this section by section</strong>:</p>
<ol>
<li>
<p><strong>The summary line</strong>: <code>AssertionError: DataFrame.iloc[:, 0] (column name="price") are different</code></p>
<ul>
<li>What this tells us: The pandas <code>assert_frame_equal</code> function found a discrepancy. It's helpfully telling us the problem is in the first column, named "price".</li>
</ul>
</li>
<li>
<p><strong>The assertion introspection</strong>:
    <code>[left]:  [0.0, 0.5, 0.25, 1.0]
    [right]: [0.0, 0.5, 0.25, 1.0]</code></p>
<ul>
<li>What this tells us: This is the confusing part. The values <em>look identical</em>! This is the classic signature of a floating-point precision issue. The actual difference is likely at a very small decimal place that isn't being printed in the summary. The underlying values might be <code>0.5</code> and <code>0.5000000000000001</code>.</li>
</ul>
</li>
</ol>
<p><strong>Root cause identified</strong>: We are using an exact equality check (<code>assert_frame_equal</code>) on columns containing floating-point numbers, which is unreliable.
<strong>Why the current approach can't solve this</strong>: <code>assert_frame_equal</code> by default demands bit-for-bit equality. It's too strict for numerical work.
<strong>What we need</strong>: A way to assert that two numbers are "close enough" or approximately equal.</p>
<h3 id="technique-introduced-pytestapprox">Technique Introduced: <code>pytest.approx</code></h3>
<p>Pytest provides a powerful and intuitive tool for this exact problem: <code>pytest.approx</code>. It allows you to check if a number is equal to another number within a certain tolerance.</p>
<p>You can use it like this:
<code>assert actual_float == pytest.approx(expected_float)</code></p>
<p>It works with simple numbers, lists, NumPy arrays, and dictionaries of numbers.</p>
<h3 id="solution-implementation">Solution Implementation</h3>
<p>Instead of comparing the entire DataFrame at once, we can separate our checks. We'll check the non-numeric columns for exact equality and the numeric <code>price</code> column for approximate equality.</p>
<p><strong>Before (in <code>test_data_processing.py</code>):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># ...</span>
    <span class="c1"># This will fail due to floating point issues!</span>
    <span class="n">assert_frame_equal</span><span class="p">(</span><span class="n">actual_df</span><span class="p">,</span> <span class="n">expected_df</span><span class="p">)</span>
</code></pre></div>

<p><strong>After (in <code>test_data_processing.py</code>):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_data_processing.py (FIXED)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas.testing</span><span class="w"> </span><span class="kn">import</span> <span class="n">assert_frame_equal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytest</span><span class="w"> </span><span class="kn">import</span> <span class="n">approx</span>  <span class="c1"># &lt;-- Import approx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">data_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_preprocess_data_with_scaling_and_approx</span><span class="p">():</span>
    <span class="c1"># 1. Setup</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">200000</span><span class="p">,</span> <span class="mi">350000</span><span class="p">,</span> <span class="mi">275000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">],</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">],</span>
        <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Colonial&#39;</span><span class="p">,</span> <span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Modern&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>

    <span class="c1"># 2. Action</span>
    <span class="n">actual_df</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="p">(</span><span class="n">input_df</span><span class="p">)</span>

    <span class="c1"># 3. Assertion</span>
    <span class="n">expected_prices</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="n">expected_non_numeric_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Colonial&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Modern&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="s1">&#39;style_Ranch&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="n">expected_non_numeric_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">expected_non_numeric_data</span><span class="p">)</span>

    <span class="c1"># Assert the numeric column is &quot;close enough&quot;</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">actual_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">approx</span><span class="p">(</span><span class="n">expected_prices</span><span class="p">)</span>

    <span class="c1"># Assert the rest of the columns are exactly equal</span>
    <span class="c1"># We need to re-order columns to match for a reliable comparison</span>
    <span class="n">actual_other_cols</span> <span class="o">=</span> <span class="n">actual_df</span><span class="p">[</span><span class="n">expected_non_numeric_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="n">assert_frame_equal</span><span class="p">(</span><span class="n">actual_other_cols</span><span class="p">,</span> <span class="n">expected_non_numeric_df</span><span class="p">)</span>
</code></pre></div>

<h3 id="verification">Verification</h3>
<p>Let's run our new test.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">1</span><span class="w"> </span>item

test_data_processing.py<span class="w"> </span>.<span class="w">                                                </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span><span class="w"> </span><span class="m">1</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<p>Success! By separating the exact checks from the approximate checks, we've created a robust test that correctly verifies our logic without being sensitive to tiny floating-point inaccuracies.</p>
<p><strong>Limitation preview:</strong> This test is getting more complex. We're manually defining a lot of data inside the test function. As our pipeline grows, this will become unmanageable. We need a better way to handle test data and setup.</p>
<h2 id="testing-machine-learning-models">Testing Machine Learning Models</h2>
<h2 id="testing-machine-learning-models_1">Testing Machine Learning Models</h2>
<p>We've successfully tested our data processing function. Now we move to the next stage: training and testing a machine learning model. This is where the idea of "correctness" becomes fuzzy. We can't test for exact prediction values, but we can test the model's behavior and properties.</p>
<h3 id="iteration-2-introducing-a-model">Iteration 2: Introducing a Model</h3>
<p><strong>Current state recap:</strong> Our test for <code>preprocess_data</code> is robust against floating-point issues using <code>pytest.approx</code>.</p>
<p><strong>Current limitation:</strong> We are only testing the data transformation, not the model that will use the data.</p>
<p><strong>New scenario introduction:</strong> Let's create a simple <code>train_and_predict</code> function. It will take raw data, use our <code>preprocess_data</code> function, train a basic <code>scikit-learn</code> Linear Regression model, and make predictions.</p>
<p><strong>New file:</strong> <code>model.py</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># model.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">data_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">train_and_predict</span><span class="p">(</span><span class="n">train_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">predict_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trains a model on train_df and makes predictions on predict_df.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Preprocess both training and prediction data</span>
    <span class="n">processed_train_df</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
    <span class="n">processed_predict_df</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="p">(</span><span class="n">predict_df</span><span class="p">)</span>

    <span class="c1"># Ensure prediction data has all columns from training, fill missing with 0</span>
    <span class="c1"># This handles cases where a &#39;style&#39; in predict_df was not in train_df</span>
    <span class="n">train_cols</span> <span class="o">=</span> <span class="n">processed_train_df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">)</span>
    <span class="n">processed_predict_df</span> <span class="o">=</span> <span class="n">processed_predict_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="n">train_cols</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="c1"># Define features (X) and target (y)</span>
    <span class="n">X_train</span> <span class="o">=</span> <span class="n">processed_train_df</span><span class="p">[</span><span class="n">train_cols</span><span class="p">]</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">processed_train_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span>

    <span class="c1"># Train the model</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1"># Make predictions</span>
    <span class="n">X_predict</span> <span class="o">=</span> <span class="n">processed_predict_df</span><span class="p">[</span><span class="n">train_cols</span><span class="p">]</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_predict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">predictions</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</code></pre></div>

<h3 id="how-to-test-a-model">How to Test a Model?</h3>
<p>We can't assert <code>prediction == 12345.67</code>. So what <em>can</em> we test?</p>
<ol>
<li><strong>Output Shape:</strong> If we ask for predictions on 3 houses, we should get back 3 predictions.</li>
<li><strong>Output Type:</strong> The predictions should be a list of floats.</li>
<li><strong>Prediction Range:</strong> For house prices, predictions should probably be positive. A negative price is a sign something is very wrong.</li>
<li><strong>Determinism (Sanity Check):</strong> If we train the same model on the same data twice, we should get the same predictions. (Note: This only works for deterministic models like Linear Regression. For stochastic models, you'd need to set a <code>random_state</code>).</li>
<li><strong>Performance Threshold (Advanced):</strong> On a small, fixed dataset, the model's error (e.g., Mean Squared Error) should be below a certain value. This acts as a regression test for model performance.</li>
</ol>
<p>Let's write a test that covers the first three points.</p>
<p><strong>New test file:</strong> <code>test_model.py</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_model.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">model</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_and_predict</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_train_and_predict_properties</span><span class="p">():</span>
    <span class="c1"># 1. Setup: Create training data and data for prediction</span>
    <span class="n">train_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">200000</span><span class="p">,</span> <span class="mi">350000</span><span class="p">,</span> <span class="mi">275000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">,</span> <span class="mi">450000</span><span class="p">],</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="mf">1992.0</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">,</span> <span class="mf">2005.0</span><span class="p">],</span>
        <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Colonial&#39;</span><span class="p">,</span> <span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Modern&#39;</span><span class="p">,</span> <span class="s1">&#39;Colonial&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">train_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span>

    <span class="n">predict_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1990.0</span><span class="p">,</span> <span class="mf">2015.0</span><span class="p">],</span>
        <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Modern&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">predict_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">predict_data</span><span class="p">)</span>

    <span class="c1"># 2. Action</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">train_and_predict</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="n">predict_df</span><span class="p">)</span>

    <span class="c1"># 3. Assertions</span>
    <span class="c1"># Test output shape</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

    <span class="c1"># Test output type</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">)</span>

    <span class="c1"># Test prediction range (a simple heuristic)</span>
    <span class="c1"># Given our training prices, predictions shouldn&#39;t be negative or astronomical.</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">)</span>
</code></pre></div>

<p>Let's run our new test suite.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

test_data_processing.py<span class="w"> </span>.<span class="w">                                                </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
test_model.py<span class="w"> </span>.<span class="w">                                                          </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<p>It passes. Our test successfully verifies the <em>behavior</em> and <em>contract</em> of our prediction function without being coupled to specific prediction values. This is a much more robust way to test machine learning models.</p>
<p><strong>Limitation preview:</strong> Look at all that setup code! We're creating DataFrames inside <code>test_data_processing.py</code> and <code>test_model.py</code>. This is repetitive and violates the DRY (Don't Repeat Yourself) principle. If we need to add a new column, we have to update it in multiple places. There must be a better way to manage this shared test data setup.</p>
<h2 id="fixtures-for-data-pipelines">Fixtures for Data Pipelines</h2>
<h2 id="fixtures-for-data-pipelines_1">Fixtures for Data Pipelines</h2>
<p>As we've seen, testing data science code involves a lot of setup. We need to create DataFrames, load data, and sometimes even train a model <em>before</em> our test can even begin. Pytest fixtures are the perfect solution for managing this setup code, making our tests cleaner, more modular, and more efficient.</p>
<h3 id="iteration-3-refactoring-setup-with-fixtures">Iteration 3: Refactoring Setup with Fixtures</h3>
<p><strong>Current state recap:</strong> We have two test files, both with significant, manually-created pandas DataFrames inside the test functions.</p>
<p><strong>Current limitation:</strong> The setup code is duplicated and tightly coupled to the tests. This makes maintenance difficult and tests harder to read.</p>
<p><strong>Technique introduced:</strong> We will use pytest fixtures to externalize the creation of our test data. We'll create a <code>conftest.py</code> file to hold fixtures that can be shared across our entire test suite.</p>
<p>We will create two fixtures:
1.  <code>raw_housing_data()</code>: Provides a raw, unprocessed DataFrame for testing.
2.  <code>processed_housing_data()</code>: Depends on the first fixture, runs the data through <code>preprocess_data</code>, and provides the processed DataFrame.</p>
<p><strong>New file:</strong> <code>conftest.py</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># conftest.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">data_processing</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_data</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">raw_housing_data</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fixture for a raw housing data DataFrame.&quot;&quot;&quot;</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">200000</span><span class="p">,</span> <span class="mi">350000</span><span class="p">,</span> <span class="mi">275000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">,</span> <span class="mi">450000</span><span class="p">],</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">,</span> <span class="mf">2005.0</span><span class="p">],</span>
        <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Colonial&#39;</span><span class="p">,</span> <span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Modern&#39;</span><span class="p">,</span> <span class="s1">&#39;Colonial&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">processed_housing_data</span><span class="p">(</span><span class="n">raw_housing_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fixture for processed housing data.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">preprocess_data</span><span class="p">(</span><span class="n">raw_housing_data</span><span class="p">)</span>
</code></pre></div>

<p>By placing these in <code>conftest.py</code>, they are automatically available to all tests. The <code>scope="module"</code> means the fixture will be set up only once per test module, which is more efficient than setting it up for every single test function.</p>
<h3 id="solution-implementation_1">Solution Implementation</h3>
<p>Now we can refactor our test files to use these fixtures. The tests become dramatically simpler and more focused on their specific assertion logic.</p>
<p><strong>Before (in <code>test_data_processing.py</code>):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_data_processing.py (OLD version)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_preprocess_data_with_scaling_and_approx</span><span class="p">():</span>
    <span class="c1"># 1. Setup</span>
    <span class="n">raw_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;price&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">200000</span><span class="p">,</span> <span class="mi">350000</span><span class="p">,</span> <span class="mi">275000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">],</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1985.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1999.0</span><span class="p">,</span> <span class="mf">2010.0</span><span class="p">],</span>
        <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Colonial&#39;</span><span class="p">,</span> <span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Modern&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>

    <span class="c1"># 2. Action</span>
    <span class="n">actual_df</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="p">(</span><span class="n">input_df</span><span class="p">)</span>
    <span class="c1"># ... assertions ...</span>
</code></pre></div>

<p><strong>After (in <code>test_data_processing.py</code>):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_data_processing.py (REFACTORED)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pytest</span><span class="w"> </span><span class="kn">import</span> <span class="n">approx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas.testing</span><span class="w"> </span><span class="kn">import</span> <span class="n">assert_frame_equal</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_preprocess_data_output</span><span class="p">(</span><span class="n">processed_housing_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="c1"># The &#39;processed_housing_data&#39; fixture handles all setup and action!</span>
    <span class="c1"># We just need to assert on the result.</span>
    <span class="n">actual_df</span> <span class="o">=</span> <span class="n">processed_housing_data</span>

    <span class="c1"># Assertions</span>
    <span class="c1"># The median of [1985, 1999, 2010, 2005] is 2002.0</span>
    <span class="c1"># min_price=200k, max_price=500k</span>
    <span class="n">expected_prices</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.83333333</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">actual_df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">approx</span><span class="p">(</span><span class="n">expected_prices</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">actual_df</span><span class="p">[</span><span class="s1">&#39;year_built&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">actual_df</span><span class="p">[</span><span class="s1">&#39;year_built&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">2002.0</span> <span class="c1"># Check median fill</span>
    <span class="k">assert</span> <span class="s1">&#39;style&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">actual_df</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">assert</span> <span class="s1">&#39;style_Ranch&#39;</span> <span class="ow">in</span> <span class="n">actual_df</span><span class="o">.</span><span class="n">columns</span>
</code></pre></div>

<p>And now for <code>test_model.py</code>.</p>
<p><strong>Before (in <code>test_model.py</code>):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_model.py (OLD version)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_train_and_predict_properties</span><span class="p">():</span>
    <span class="c1"># 1. Setup: Create training data and data for prediction</span>
    <span class="n">train_data</span> <span class="o">=</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="n">train_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span>
    <span class="n">predict_data</span> <span class="o">=</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="n">predict_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">predict_data</span><span class="p">)</span>

    <span class="c1"># 2. Action</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">train_and_predict</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="n">predict_df</span><span class="p">)</span>
    <span class="c1"># ... assertions ...</span>
</code></pre></div>

<p><strong>After (in <code>test_model.py</code>):</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_model.py (REFACTORED)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">model</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_and_predict</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_train_and_predict_properties_fixture</span><span class="p">(</span><span class="n">raw_housing_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="c1"># 1. Setup: Use the fixture for training data</span>
    <span class="n">train_df</span> <span class="o">=</span> <span class="n">raw_housing_data</span>

    <span class="c1"># Create a smaller, specific dataset for prediction</span>
    <span class="n">predict_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;bedrooms&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="s1">&#39;year_built&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1990.0</span><span class="p">,</span> <span class="mf">2015.0</span><span class="p">],</span>
        <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Ranch&#39;</span><span class="p">,</span> <span class="s1">&#39;Modern&#39;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">predict_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">predict_data</span><span class="p">)</span>

    <span class="c1"># 2. Action</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">train_and_predict</span><span class="p">(</span><span class="n">train_df</span><span class="p">,</span> <span class="n">predict_df</span><span class="p">)</span>

    <span class="c1"># 3. Assertions</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">)</span>
</code></pre></div>

<h3 id="verification_1">Verification</h3>
<p>Let's run the full suite again.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>pytest<span class="w"> </span>-v
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">2</span><span class="w"> </span>items

test_data_processing.py::test_preprocess_data_output<span class="w"> </span>PASSED<span class="w">              </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
test_model.py::test_train_and_predict_properties_fixture<span class="w"> </span>PASSED<span class="w">          </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span><span class="w"> </span><span class="m">2</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<p>The tests still pass, but now our test code is dramatically cleaner. The logic for creating data is centralized in <code>conftest.py</code>. If we need to update the test dataset, we only have to do it in one place. The tests themselves are now focused purely on the behavior they are meant to verify. This is a huge win for maintainability.</p>
<p><strong>Limitation preview:</strong> Our pipeline produces not just numbers, but also visualizations. How can we test a function that creates a plot? We can't easily compare images in an automated test.</p>
<h2 id="testing-visualization-code">Testing Visualization Code</h2>
<h2 id="testing-visualization-code_1">Testing Visualization Code</h2>
<p>Testing code that generates plots (e.g., with Matplotlib or Seaborn) is notoriously difficult. You can't easily perform an assertion on a PNG file. A single-pixel difference would cause a test to fail, making such tests extremely brittle.</p>
<p>However, this doesn't mean we can't test visualization code at all. We just need to change our approach. Instead of testing the visual <em>output</em>, we test the plot-generating <em>process</em> and the <em>properties</em> of the resulting plot object.</p>
<h3 id="iteration-4-introducing-a-plotting-function">Iteration 4: Introducing a Plotting Function</h3>
<p><strong>Current state recap:</strong> Our data processing and model prediction logic is well-tested and uses fixtures for clean setup.</p>
<p><strong>Current limitation:</strong> We have no tests for any visualization outputs of our project.</p>
<p><strong>New scenario introduction:</strong> Let's add a function that takes a trained model and feature names, and generates a bar chart of feature importances (or coefficients, in the case of linear regression).</p>
<p><strong>New file:</strong> <code>visualization.py</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># visualization.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="k">def</span><span class="w"> </span><span class="nf">plot_feature_coefficients</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">LinearRegression</span><span class="p">,</span> <span class="n">feature_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates and shows a bar plot of model feature coefficients.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;coef_&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model does not have coefficients. Was it trained?&quot;</span><span class="p">)</span>

    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">coef_</span>
    <span class="n">coef_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;feature&#39;</span><span class="p">:</span> <span class="n">feature_names</span><span class="p">,</span> <span class="s1">&#39;coefficient&#39;</span><span class="p">:</span> <span class="n">coefficients</span><span class="p">})</span>
    <span class="n">coef_df</span> <span class="o">=</span> <span class="n">coef_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;coefficient&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">coef_df</span><span class="p">[</span><span class="s1">&#39;feature&#39;</span><span class="p">],</span> <span class="n">coef_df</span><span class="p">[</span><span class="s1">&#39;coefficient&#39;</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Model Feature Coefficients&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Feature&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Coefficient Value&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="c1"># In a real script, you might use plt.show() or fig.savefig()</span>
    <span class="c1"># For testing, we will want to get the Axes object back.</span>
    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div>

<p>Notice the function now returns the <code>ax</code> (Matplotlib Axes) object. This is a crucial change that makes the function testable. Functions that only call <code>plt.show()</code> are very difficult to test.</p>
<h3 id="testing-strategies-for-plots">Testing Strategies for Plots</h3>
<h4 id="strategy-1-the-smoke-test">Strategy 1: The Smoke Test</h4>
<p>The simplest possible test for a plotting function is a "smoke test." It doesn't check for correctness; it only checks if the function runs to completion without raising an error. This is surprisingly useful for catching bugs introduced during refactoring.</p>
<h4 id="strategy-2-inspecting-plot-properties">Strategy 2: Inspecting Plot Properties</h4>
<p>A more powerful approach is to inspect the properties of the returned Axes object. We can't see the plot, but we can ask questions about its structure:
-   Does it have the correct title?
-   Are the axis labels set correctly?
-   Does it have the right number of bars?</p>
<p>Let's create a test file that does both. First, we need a fixture to provide a trained model.</p>
<p><strong>Add to <code>conftest.py</code>:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># conftest.py (add new fixture)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">model</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocess_data</span> <span class="c1"># Assuming preprocess_data is accessible</span>

<span class="c1"># ... existing fixtures ...</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">trained_linear_model</span><span class="p">(</span><span class="n">processed_housing_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fixture for a trained LinearRegression model.&quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">processed_housing_data</span>

    <span class="n">X_train</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">y_train</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
</code></pre></div>

<p>Now we can write the tests.</p>
<p><strong>New test file:</strong> <code>test_visualization.py</code></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># test_visualization.py</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span>
<span class="c1"># Use a non-interactive backend for tests to prevent plots from popping up</span>
<span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;Agg&#39;</span><span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">visualization</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_feature_coefficients</span>

<span class="c1"># Smoke test: Does it run without error?</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_plot_feature_coefficients_smoke</span><span class="p">(</span><span class="n">trained_linear_model</span><span class="p">):</span>
    <span class="n">model</span><span class="p">,</span> <span class="n">feature_names</span> <span class="o">=</span> <span class="n">trained_linear_model</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">plot_feature_coefficients</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">feature_names</span><span class="p">)</span>
        <span class="c1"># Close the plot to free up memory</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Plotting function raised an exception: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Property test: Does the plot have the right components?</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_plot_feature_coefficients_properties</span><span class="p">(</span><span class="n">trained_linear_model</span><span class="p">):</span>
    <span class="n">model</span><span class="p">,</span> <span class="n">feature_names</span> <span class="o">=</span> <span class="n">trained_linear_model</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_feature_coefficients</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">feature_names</span><span class="p">)</span>

    <span class="c1"># Test title</span>
    <span class="k">assert</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_title</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Model Feature Coefficients&quot;</span>

    <span class="c1"># Test axis labels</span>
    <span class="k">assert</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlabel</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Feature&quot;</span>
    <span class="k">assert</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylabel</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Coefficient Value&quot;</span>

    <span class="c1"># Test number of bars</span>
    <span class="c1"># There should be one bar for each feature</span>
    <span class="n">num_features</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_names</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">patches</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_features</span>

    <span class="c1"># Close the plot to free up memory</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>

<h3 id="verification_2">Verification</h3>
<p>Let's run the final test suite.</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="nv">pytest</span>
<span class="o">=============================</span><span class="w"> </span><span class="nb">test</span><span class="w"> </span>session<span class="w"> </span><span class="nv">starts</span><span class="w"> </span><span class="o">==============================</span>
...
collected<span class="w"> </span><span class="m">4</span><span class="w"> </span>items

test_data_processing.py<span class="w"> </span>.<span class="w">                                                </span><span class="o">[</span><span class="w"> </span><span class="m">25</span>%<span class="o">]</span>
test_model.py<span class="w"> </span>.<span class="w">                                                          </span><span class="o">[</span><span class="w"> </span><span class="m">50</span>%<span class="o">]</span>
test_visualization.py<span class="w"> </span>..<span class="w">                                                 </span><span class="o">[</span><span class="m">100</span>%<span class="o">]</span>

<span class="o">==============================</span><span class="w"> </span><span class="m">4</span><span class="w"> </span>passed<span class="w"> </span><span class="k">in</span><span class="w"> </span>...s<span class="w"> </span><span class="o">===============================</span>
</code></pre></div>

<p>All tests pass. We have successfully tested our visualization code without resorting to fragile image comparison. We've verified that it runs and that the key components of the plot are generated as expected.</p>
<h3 id="the-journey-from-problem-to-solution">The Journey: From Problem to Solution</h3>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>Failure Mode / Challenge</th>
<th>Technique Applied</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Need to verify data transformation logic.</td>
<td><code>pandas.testing</code></td>
<td>Basic test for integers and one-hot encoding works.</td>
</tr>
<tr>
<td>1</td>
<td>Exact comparisons fail with floating-point numbers.</td>
<td><code>pytest.approx</code></td>
<td>Test is now robust to small floating-point inaccuracies.</td>
</tr>
<tr>
<td>2</td>
<td>Model predictions are not deterministic or exact.</td>
<td>Property-based testing</td>
<td>Tests verify shape, type, and range of predictions, not exact values.</td>
</tr>
<tr>
<td>3</td>
<td>Test setup code is duplicated and hard to maintain.</td>
<td><code>pytest</code> fixtures</td>
<td>Setup logic is centralized, making tests clean and maintainable.</td>
</tr>
<tr>
<td>4</td>
<td>Visual outputs (plots) cannot be easily asserted on.</td>
<td>Smoke &amp; property testing</td>
<td>Tests verify the plotting function runs and generates correct components.</td>
</tr>
</tbody>
</table>
<p>This chapter has demonstrated a robust, layered approach to testing a data science pipeline. By understanding the unique challenges and applying the right tools‚Äî<code>pytest.approx</code> for floats, property-based assertions for models, and fixtures for setup‚Äîyou can build a reliable test suite that supports, rather than hinders, your data science workflow.</p>
        </div>
        <div class="footer">
            Generated on 2025-11-24 14:31:16 | Made with ‚ù§Ô∏è by GitHub Pages Generator
        </div>
    </div>
    <script>
        // Syntax highlighting for code blocks
        document.addEventListener('DOMContentLoaded', (event) => {
            // Highlight code blocks
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Add copy buttons to code blocks
            document.querySelectorAll('pre').forEach((pre) => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'Copy';
                
                button.addEventListener('click', () => {
                    const code = pre.querySelector('code').textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        button.textContent = 'Copied!';
                        button.classList.add('copied');
                        setTimeout(() => {
                            button.textContent = 'Copy';
                            button.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        button.textContent = 'Error';
                        setTimeout(() => {
                            button.textContent = 'Copy';
                        }, 2000);
                    });
                });
                
                pre.appendChild(button);
            });
        });
    </script>
</body>
</html>